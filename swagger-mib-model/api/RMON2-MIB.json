{
  "openapi": "3.0.0",
  "info": {
    "title": "RMON2-MIB MIB API",
    "version": "1.0.0",
    "description": "The MIB module for managing remote monitoring\n    device implementations. This MIB module\n    augments the original RMON MIB as specified in\n    RFC 1757.\n\n\u26a0\ufe0f **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/RMON2-MIB:protocolDir": {
      "get": {
        "summary": "Get protocolDir data",
        "description": "Retrieve protocolDir operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDir"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMap": {
      "get": {
        "summary": "Get addressMap data",
        "description": "Retrieve addressMap operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMap"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:probeConfig": {
      "get": {
        "summary": "Get probeConfig data",
        "description": "Retrieve probeConfig operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_probeConfig"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDirTable": {
      "get": {
        "summary": "Get protocolDirTable data",
        "description": "Retrieve protocolDirTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDirTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDirTable/protocolDirEntry": {
      "get": {
        "summary": "Get protocolDirEntry list",
        "description": "Retrieve list of protocolDirEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDirEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDirTable/protocolDirEntry={protocolDirID protocolDirParameters}": {
      "get": {
        "summary": "Get protocolDirEntry entry",
        "description": "Retrieve specific protocolDirEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDirID protocolDirParameters",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDirEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistControlTable": {
      "get": {
        "summary": "Get protocolDistControlTable data",
        "description": "Retrieve protocolDistControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistControlTable/protocolDistControlEntry": {
      "get": {
        "summary": "Get protocolDistControlEntry list",
        "description": "Retrieve list of protocolDistControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDistControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistControlTable/protocolDistControlEntry={protocolDistControlIndex}": {
      "get": {
        "summary": "Get protocolDistControlEntry entry",
        "description": "Retrieve specific protocolDistControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDistControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistStatsTable": {
      "get": {
        "summary": "Get protocolDistStatsTable data",
        "description": "Retrieve protocolDistStatsTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistStatsTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistStatsTable/protocolDistStatsEntry": {
      "get": {
        "summary": "Get protocolDistStatsEntry list",
        "description": "Retrieve list of protocolDistStatsEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDistStatsEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistStatsTable/protocolDistStatsEntry={protocolDistControlIndex protocolDirLocalIndex}": {
      "get": {
        "summary": "Get protocolDistStatsEntry entry",
        "description": "Retrieve specific protocolDistStatsEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDistControlIndex protocolDirLocalIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistStatsEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapControlTable": {
      "get": {
        "summary": "Get addressMapControlTable data",
        "description": "Retrieve addressMapControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapControlTable/addressMapControlEntry": {
      "get": {
        "summary": "Get addressMapControlEntry list",
        "description": "Retrieve list of addressMapControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_addressMapControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapControlTable/addressMapControlEntry={addressMapControlIndex}": {
      "get": {
        "summary": "Get addressMapControlEntry entry",
        "description": "Retrieve specific addressMapControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "addressMapControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapTable": {
      "get": {
        "summary": "Get addressMapTable data",
        "description": "Retrieve addressMapTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapTable/addressMapEntry": {
      "get": {
        "summary": "Get addressMapEntry list",
        "description": "Retrieve list of addressMapEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_addressMapEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapTable/addressMapEntry={addressMapTimeMark protocolDirLocalIndex addressMapNetworkAddress addressMapSource}": {
      "get": {
        "summary": "Get addressMapEntry entry",
        "description": "Retrieve specific addressMapEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "addressMapTimeMark protocolDirLocalIndex addressMapNetworkAddress addressMapSource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlHostControlTable": {
      "get": {
        "summary": "Get hlHostControlTable data",
        "description": "Retrieve hlHostControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlHostControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlHostControlTable/hlHostControlEntry": {
      "get": {
        "summary": "Get hlHostControlEntry list",
        "description": "Retrieve list of hlHostControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_hlHostControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlHostControlTable/hlHostControlEntry={hlHostControlIndex}": {
      "get": {
        "summary": "Get hlHostControlEntry entry",
        "description": "Retrieve specific hlHostControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlHostControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlHostTable": {
      "get": {
        "summary": "Get nlHostTable data",
        "description": "Retrieve nlHostTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlHostTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlHostTable/nlHostEntry": {
      "get": {
        "summary": "Get nlHostEntry list",
        "description": "Retrieve list of nlHostEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlHostEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlHostTable/nlHostEntry={hlHostControlIndex nlHostTimeMark protocolDirLocalIndex nlHostAddress}": {
      "get": {
        "summary": "Get nlHostEntry entry",
        "description": "Retrieve specific nlHostEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex nlHostTimeMark protocolDirLocalIndex nlHostAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlHostEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlMatrixControlTable": {
      "get": {
        "summary": "Get hlMatrixControlTable data",
        "description": "Retrieve hlMatrixControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlMatrixControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlMatrixControlTable/hlMatrixControlEntry": {
      "get": {
        "summary": "Get hlMatrixControlEntry list",
        "description": "Retrieve list of hlMatrixControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_hlMatrixControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlMatrixControlTable/hlMatrixControlEntry={hlMatrixControlIndex}": {
      "get": {
        "summary": "Get hlMatrixControlEntry entry",
        "description": "Retrieve specific hlMatrixControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlMatrixControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixSDTable": {
      "get": {
        "summary": "Get nlMatrixSDTable data",
        "description": "Retrieve nlMatrixSDTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixSDTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixSDTable/nlMatrixSDEntry": {
      "get": {
        "summary": "Get nlMatrixSDEntry list",
        "description": "Retrieve list of nlMatrixSDEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixSDEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixSDTable/nlMatrixSDEntry={hlMatrixControlIndex nlMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress}": {
      "get": {
        "summary": "Get nlMatrixSDEntry entry",
        "description": "Retrieve specific nlMatrixSDEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex nlMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixSDEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixDSTable": {
      "get": {
        "summary": "Get nlMatrixDSTable data",
        "description": "Retrieve nlMatrixDSTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixDSTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixDSTable/nlMatrixDSEntry": {
      "get": {
        "summary": "Get nlMatrixDSEntry list",
        "description": "Retrieve list of nlMatrixDSEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixDSEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixDSTable/nlMatrixDSEntry={hlMatrixControlIndex nlMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress}": {
      "get": {
        "summary": "Get nlMatrixDSEntry entry",
        "description": "Retrieve specific nlMatrixDSEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex nlMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixDSEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNControlTable": {
      "get": {
        "summary": "Get nlMatrixTopNControlTable data",
        "description": "Retrieve nlMatrixTopNControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNControlTable/nlMatrixTopNControlEntry": {
      "get": {
        "summary": "Get nlMatrixTopNControlEntry list",
        "description": "Retrieve list of nlMatrixTopNControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNControlTable/nlMatrixTopNControlEntry={nlMatrixTopNControlIndex}": {
      "get": {
        "summary": "Get nlMatrixTopNControlEntry entry",
        "description": "Retrieve specific nlMatrixTopNControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "nlMatrixTopNControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNTable": {
      "get": {
        "summary": "Get nlMatrixTopNTable data",
        "description": "Retrieve nlMatrixTopNTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNTable/nlMatrixTopNEntry": {
      "get": {
        "summary": "Get nlMatrixTopNEntry list",
        "description": "Retrieve list of nlMatrixTopNEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNTable/nlMatrixTopNEntry={nlMatrixTopNControlIndex nlMatrixTopNIndex}": {
      "get": {
        "summary": "Get nlMatrixTopNEntry entry",
        "description": "Retrieve specific nlMatrixTopNEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "nlMatrixTopNControlIndex nlMatrixTopNIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alHostTable": {
      "get": {
        "summary": "Get alHostTable data",
        "description": "Retrieve alHostTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alHostTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alHostTable/alHostEntry": {
      "get": {
        "summary": "Get alHostEntry list",
        "description": "Retrieve list of alHostEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alHostEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alHostTable/alHostEntry={hlHostControlIndex alHostTimeMark protocolDirLocalIndex nlHostAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alHostEntry entry",
        "description": "Retrieve specific alHostEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex alHostTimeMark protocolDirLocalIndex nlHostAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alHostEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixSDTable": {
      "get": {
        "summary": "Get alMatrixSDTable data",
        "description": "Retrieve alMatrixSDTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixSDTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixSDTable/alMatrixSDEntry": {
      "get": {
        "summary": "Get alMatrixSDEntry list",
        "description": "Retrieve list of alMatrixSDEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixSDEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixSDTable/alMatrixSDEntry={hlMatrixControlIndex alMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alMatrixSDEntry entry",
        "description": "Retrieve specific alMatrixSDEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex alMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixSDEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixDSTable": {
      "get": {
        "summary": "Get alMatrixDSTable data",
        "description": "Retrieve alMatrixDSTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixDSTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixDSTable/alMatrixDSEntry": {
      "get": {
        "summary": "Get alMatrixDSEntry list",
        "description": "Retrieve list of alMatrixDSEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixDSEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixDSTable/alMatrixDSEntry={hlMatrixControlIndex alMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alMatrixDSEntry entry",
        "description": "Retrieve specific alMatrixDSEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex alMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixDSEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNControlTable": {
      "get": {
        "summary": "Get alMatrixTopNControlTable data",
        "description": "Retrieve alMatrixTopNControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNControlTable/alMatrixTopNControlEntry": {
      "get": {
        "summary": "Get alMatrixTopNControlEntry list",
        "description": "Retrieve list of alMatrixTopNControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNControlTable/alMatrixTopNControlEntry={alMatrixTopNControlIndex}": {
      "get": {
        "summary": "Get alMatrixTopNControlEntry entry",
        "description": "Retrieve specific alMatrixTopNControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "alMatrixTopNControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNTable": {
      "get": {
        "summary": "Get alMatrixTopNTable data",
        "description": "Retrieve alMatrixTopNTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNTable/alMatrixTopNEntry": {
      "get": {
        "summary": "Get alMatrixTopNEntry list",
        "description": "Retrieve list of alMatrixTopNEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNTable/alMatrixTopNEntry={alMatrixTopNControlIndex alMatrixTopNIndex}": {
      "get": {
        "summary": "Get alMatrixTopNEntry entry",
        "description": "Retrieve specific alMatrixTopNEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "alMatrixTopNControlIndex alMatrixTopNIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryControlTable": {
      "get": {
        "summary": "Get usrHistoryControlTable data",
        "description": "Retrieve usrHistoryControlTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryControlTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryControlTable/usrHistoryControlEntry": {
      "get": {
        "summary": "Get usrHistoryControlEntry list",
        "description": "Retrieve list of usrHistoryControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryControlTable/usrHistoryControlEntry={usrHistoryControlIndex}": {
      "get": {
        "summary": "Get usrHistoryControlEntry entry",
        "description": "Retrieve specific usrHistoryControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryObjectTable": {
      "get": {
        "summary": "Get usrHistoryObjectTable data",
        "description": "Retrieve usrHistoryObjectTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryObjectTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryObjectTable/usrHistoryObjectEntry": {
      "get": {
        "summary": "Get usrHistoryObjectEntry list",
        "description": "Retrieve list of usrHistoryObjectEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryObjectEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryObjectTable/usrHistoryObjectEntry={usrHistoryControlIndex usrHistoryObjectIndex}": {
      "get": {
        "summary": "Get usrHistoryObjectEntry entry",
        "description": "Retrieve specific usrHistoryObjectEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex usrHistoryObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryObjectEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryTable": {
      "get": {
        "summary": "Get usrHistoryTable data",
        "description": "Retrieve usrHistoryTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryTable/usrHistoryEntry": {
      "get": {
        "summary": "Get usrHistoryEntry list",
        "description": "Retrieve list of usrHistoryEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryTable/usrHistoryEntry={usrHistoryControlIndex usrHistorySampleIndex usrHistoryObjectIndex}": {
      "get": {
        "summary": "Get usrHistoryEntry entry",
        "description": "Retrieve specific usrHistoryEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex usrHistorySampleIndex usrHistoryObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConfigTable": {
      "get": {
        "summary": "Get serialConfigTable data",
        "description": "Retrieve serialConfigTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConfigTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConfigTable/serialConfigEntry": {
      "get": {
        "summary": "Get serialConfigEntry list",
        "description": "Retrieve list of serialConfigEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_serialConfigEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConfigTable/serialConfigEntry={ifIndex}": {
      "get": {
        "summary": "Get serialConfigEntry entry",
        "description": "Retrieve specific serialConfigEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConfigEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:netConfigTable": {
      "get": {
        "summary": "Get netConfigTable data",
        "description": "Retrieve netConfigTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_netConfigTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:netConfigTable/netConfigEntry": {
      "get": {
        "summary": "Get netConfigEntry list",
        "description": "Retrieve list of netConfigEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_netConfigEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:netConfigTable/netConfigEntry={ifIndex}": {
      "get": {
        "summary": "Get netConfigEntry entry",
        "description": "Retrieve specific netConfigEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_netConfigEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:trapDestTable": {
      "get": {
        "summary": "Get trapDestTable data",
        "description": "Retrieve trapDestTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_trapDestTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:trapDestTable/trapDestEntry": {
      "get": {
        "summary": "Get trapDestEntry list",
        "description": "Retrieve list of trapDestEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_trapDestEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:trapDestTable/trapDestEntry={trapDestIndex}": {
      "get": {
        "summary": "Get trapDestEntry entry",
        "description": "Retrieve specific trapDestEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "trapDestIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_trapDestEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConnectionTable": {
      "get": {
        "summary": "Get serialConnectionTable data",
        "description": "Retrieve serialConnectionTable operational data from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConnectionTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConnectionTable/serialConnectionEntry": {
      "get": {
        "summary": "Get serialConnectionEntry list",
        "description": "Retrieve list of serialConnectionEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_serialConnectionEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConnectionTable/serialConnectionEntry={serialConnectIndex}": {
      "get": {
        "summary": "Get serialConnectionEntry entry",
        "description": "Retrieve specific serialConnectionEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "serialConnectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConnectionEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDirEntry": {
      "get": {
        "summary": "Get protocolDirEntry list",
        "description": "Retrieve list of protocolDirEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDirEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDirEntry={protocolDirID protocolDirParameters}": {
      "get": {
        "summary": "Get protocolDirEntry entry",
        "description": "Retrieve specific protocolDirEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDirID protocolDirParameters",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDirEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistControlEntry": {
      "get": {
        "summary": "Get protocolDistControlEntry list",
        "description": "Retrieve list of protocolDistControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDistControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistControlEntry={protocolDistControlIndex}": {
      "get": {
        "summary": "Get protocolDistControlEntry entry",
        "description": "Retrieve specific protocolDistControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDistControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistStatsEntry": {
      "get": {
        "summary": "Get protocolDistStatsEntry list",
        "description": "Retrieve list of protocolDistStatsEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_protocolDistStatsEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:protocolDistStatsEntry={protocolDistControlIndex protocolDirLocalIndex}": {
      "get": {
        "summary": "Get protocolDistStatsEntry entry",
        "description": "Retrieve specific protocolDistStatsEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "protocolDistControlIndex protocolDirLocalIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_protocolDistStatsEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapControlEntry": {
      "get": {
        "summary": "Get addressMapControlEntry list",
        "description": "Retrieve list of addressMapControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_addressMapControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapControlEntry={addressMapControlIndex}": {
      "get": {
        "summary": "Get addressMapControlEntry entry",
        "description": "Retrieve specific addressMapControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "addressMapControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapEntry": {
      "get": {
        "summary": "Get addressMapEntry list",
        "description": "Retrieve list of addressMapEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_addressMapEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:addressMapEntry={addressMapTimeMark protocolDirLocalIndex addressMapNetworkAddress addressMapSource}": {
      "get": {
        "summary": "Get addressMapEntry entry",
        "description": "Retrieve specific addressMapEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "addressMapTimeMark protocolDirLocalIndex addressMapNetworkAddress addressMapSource",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_addressMapEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlHostControlEntry": {
      "get": {
        "summary": "Get hlHostControlEntry list",
        "description": "Retrieve list of hlHostControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_hlHostControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlHostControlEntry={hlHostControlIndex}": {
      "get": {
        "summary": "Get hlHostControlEntry entry",
        "description": "Retrieve specific hlHostControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlHostControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlHostEntry": {
      "get": {
        "summary": "Get nlHostEntry list",
        "description": "Retrieve list of nlHostEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlHostEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlHostEntry={hlHostControlIndex nlHostTimeMark protocolDirLocalIndex nlHostAddress}": {
      "get": {
        "summary": "Get nlHostEntry entry",
        "description": "Retrieve specific nlHostEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex nlHostTimeMark protocolDirLocalIndex nlHostAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlHostEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlMatrixControlEntry": {
      "get": {
        "summary": "Get hlMatrixControlEntry list",
        "description": "Retrieve list of hlMatrixControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_hlMatrixControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:hlMatrixControlEntry={hlMatrixControlIndex}": {
      "get": {
        "summary": "Get hlMatrixControlEntry entry",
        "description": "Retrieve specific hlMatrixControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_hlMatrixControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixSDEntry": {
      "get": {
        "summary": "Get nlMatrixSDEntry list",
        "description": "Retrieve list of nlMatrixSDEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixSDEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixSDEntry={hlMatrixControlIndex nlMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress}": {
      "get": {
        "summary": "Get nlMatrixSDEntry entry",
        "description": "Retrieve specific nlMatrixSDEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex nlMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixSDEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixDSEntry": {
      "get": {
        "summary": "Get nlMatrixDSEntry list",
        "description": "Retrieve list of nlMatrixDSEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixDSEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixDSEntry={hlMatrixControlIndex nlMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress}": {
      "get": {
        "summary": "Get nlMatrixDSEntry entry",
        "description": "Retrieve specific nlMatrixDSEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex nlMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixDSEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNControlEntry": {
      "get": {
        "summary": "Get nlMatrixTopNControlEntry list",
        "description": "Retrieve list of nlMatrixTopNControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNControlEntry={nlMatrixTopNControlIndex}": {
      "get": {
        "summary": "Get nlMatrixTopNControlEntry entry",
        "description": "Retrieve specific nlMatrixTopNControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "nlMatrixTopNControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNEntry": {
      "get": {
        "summary": "Get nlMatrixTopNEntry list",
        "description": "Retrieve list of nlMatrixTopNEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:nlMatrixTopNEntry={nlMatrixTopNControlIndex nlMatrixTopNIndex}": {
      "get": {
        "summary": "Get nlMatrixTopNEntry entry",
        "description": "Retrieve specific nlMatrixTopNEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "nlMatrixTopNControlIndex nlMatrixTopNIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_nlMatrixTopNEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alHostEntry": {
      "get": {
        "summary": "Get alHostEntry list",
        "description": "Retrieve list of alHostEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alHostEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alHostEntry={hlHostControlIndex alHostTimeMark protocolDirLocalIndex nlHostAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alHostEntry entry",
        "description": "Retrieve specific alHostEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlHostControlIndex alHostTimeMark protocolDirLocalIndex nlHostAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alHostEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixSDEntry": {
      "get": {
        "summary": "Get alMatrixSDEntry list",
        "description": "Retrieve list of alMatrixSDEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixSDEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixSDEntry={hlMatrixControlIndex alMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alMatrixSDEntry entry",
        "description": "Retrieve specific alMatrixSDEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex alMatrixSDTimeMark protocolDirLocalIndex nlMatrixSDSourceAddress nlMatrixSDDestAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixSDEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixDSEntry": {
      "get": {
        "summary": "Get alMatrixDSEntry list",
        "description": "Retrieve list of alMatrixDSEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixDSEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixDSEntry={hlMatrixControlIndex alMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress protocolDirLocalIndex_2}": {
      "get": {
        "summary": "Get alMatrixDSEntry entry",
        "description": "Retrieve specific alMatrixDSEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "hlMatrixControlIndex alMatrixDSTimeMark protocolDirLocalIndex nlMatrixDSDestAddress nlMatrixDSSourceAddress protocolDirLocalIndex_2",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixDSEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNControlEntry": {
      "get": {
        "summary": "Get alMatrixTopNControlEntry list",
        "description": "Retrieve list of alMatrixTopNControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNControlEntry={alMatrixTopNControlIndex}": {
      "get": {
        "summary": "Get alMatrixTopNControlEntry entry",
        "description": "Retrieve specific alMatrixTopNControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "alMatrixTopNControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNEntry": {
      "get": {
        "summary": "Get alMatrixTopNEntry list",
        "description": "Retrieve list of alMatrixTopNEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:alMatrixTopNEntry={alMatrixTopNControlIndex alMatrixTopNIndex}": {
      "get": {
        "summary": "Get alMatrixTopNEntry entry",
        "description": "Retrieve specific alMatrixTopNEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "alMatrixTopNControlIndex alMatrixTopNIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_alMatrixTopNEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryControlEntry": {
      "get": {
        "summary": "Get usrHistoryControlEntry list",
        "description": "Retrieve list of usrHistoryControlEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryControlEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryControlEntry={usrHistoryControlIndex}": {
      "get": {
        "summary": "Get usrHistoryControlEntry entry",
        "description": "Retrieve specific usrHistoryControlEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryControlEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryObjectEntry": {
      "get": {
        "summary": "Get usrHistoryObjectEntry list",
        "description": "Retrieve list of usrHistoryObjectEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryObjectEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryObjectEntry={usrHistoryControlIndex usrHistoryObjectIndex}": {
      "get": {
        "summary": "Get usrHistoryObjectEntry entry",
        "description": "Retrieve specific usrHistoryObjectEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex usrHistoryObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryObjectEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryEntry": {
      "get": {
        "summary": "Get usrHistoryEntry list",
        "description": "Retrieve list of usrHistoryEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_usrHistoryEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:usrHistoryEntry={usrHistoryControlIndex usrHistorySampleIndex usrHistoryObjectIndex}": {
      "get": {
        "summary": "Get usrHistoryEntry entry",
        "description": "Retrieve specific usrHistoryEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "usrHistoryControlIndex usrHistorySampleIndex usrHistoryObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_usrHistoryEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConfigEntry": {
      "get": {
        "summary": "Get serialConfigEntry list",
        "description": "Retrieve list of serialConfigEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_serialConfigEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConfigEntry={ifIndex}": {
      "get": {
        "summary": "Get serialConfigEntry entry",
        "description": "Retrieve specific serialConfigEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConfigEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:netConfigEntry": {
      "get": {
        "summary": "Get netConfigEntry list",
        "description": "Retrieve list of netConfigEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_netConfigEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:netConfigEntry={ifIndex}": {
      "get": {
        "summary": "Get netConfigEntry entry",
        "description": "Retrieve specific netConfigEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_netConfigEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:trapDestEntry": {
      "get": {
        "summary": "Get trapDestEntry list",
        "description": "Retrieve list of trapDestEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_trapDestEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:trapDestEntry={trapDestIndex}": {
      "get": {
        "summary": "Get trapDestEntry entry",
        "description": "Retrieve specific trapDestEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "trapDestIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_trapDestEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConnectionEntry": {
      "get": {
        "summary": "Get serialConnectionEntry list",
        "description": "Retrieve list of serialConnectionEntry entries from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RMON2-MIB_serialConnectionEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RMON2-MIB:serialConnectionEntry={serialConnectIndex}": {
      "get": {
        "summary": "Get serialConnectionEntry entry",
        "description": "Retrieve specific serialConnectionEntry entry by key from MIB",
        "tags": [
          "RMON2-MIB"
        ],
        "parameters": [
          {
            "name": "serialConnectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RMON2-MIB_serialConnectionEntry"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "RMON2-MIB_RMON2-MIB": {
        "type": "object",
        "description": "The value of sysUpTime at the time the protocol directory\n          was last modified, either through insertions or deletions,\n          or through modifications of either the\n          protocolDirAddressMapConfig, protocolDirHostConfig, or\n          protocolDirMatrixConfig.",
        "properties": {
          "protocolDirLastChange": {
            "type": "string",
            "description": "The value of sysUpTime at the time the protocol directory\n          was last modified, either through insertions or deletions,\n          or through modifications of either the\n          protocolDirAddressMapConfig, protocolDirHostConfig, or\n          protocolDirMatrixConfig.",
            "x-yang-type": "yang:timestamp"
          },
          "addressMapInserts": {
            "type": "integer",
            "description": "The number of times an address mapping entry has been\n          inserted into the addressMapTable.  If an entry is inserted,\n          then deleted, and then inserted, this counter will be\n          incremented by 2.\n          \n          Note that the table size can be determined by subtracting\n          addressMapDeletes from addressMapInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "addressMapDeletes": {
            "type": "integer",
            "description": "The number of times an address mapping entry has been\n          deleted from the addressMapTable (for any reason).  If\n          an entry is deleted, then inserted, and then deleted, this\n          counter will be incremented by 2.\n          \n          Note that the table size can be determined by subtracting\n          addressMapDeletes from addressMapInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "addressMapMaxDesiredEntries": {
            "type": "integer",
            "description": "The maximum number of entries that are desired in the\n          addressMapTable. The probe will not create more than\n          this number of entries in the table, but may choose to create\n          fewer entries in this table for any reason including the lack\n          of resources.\n          \n          If this object is set to a value less than the current number\n          of entries, enough entries are chosen in an\n          implementation-dependent manner and deleted so that the number\n          of entries in the table equals the value of this object.\n          \n          If this value is set to -1, the probe may create any number\n          of entries in this table.\n          \n          This object may be used to control how resources are allocated\n          on the probe for the various RMON functions.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "probeCapabilities": {
            "type": "string",
            "description": "An indication of the RMON MIB groups supported\n          on at least one interface by this probe.",
            "format": "binary"
          },
          "probeSoftwareRev": {
            "type": "string",
            "description": "The software revision of this device.  This string will have\n          a zero length if the revision is unknown.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "probeHardwareRev": {
            "type": "string",
            "description": "The hardware revision of this device.  This string will have\n          a zero length if the revision is unknown.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "probeDateTime": {
            "type": "string",
            "description": "Probe's current date and time.\n          \n          field  octets  contents                  range\n          -----  ------  --------                  -----\n            1      1-2   year                      0..65536\n            2       3    month                     1..12\n            3       4    day                       1..31\n            4       5    hour                      0..23\n            5       6    minutes                   0..59\n            6       7    seconds                   0..60\n                          (use 60 for leap-second)\n            7       8    deci-seconds              0..9\n            8       9    direction from UTC        '+' / '-'\n            9      10    hours from UTC            0..11\n           10      11    minutes from UTC          0..59\n          \n          For example, Tuesday May 26, 1992 at 1:30:15 PM\n          EDT would be displayed as:\n          \n                      1992-5-26,13:30:15.0,-4:0\n          \n          Note that if only local time is known, then\n          timezone information (fields 8-10) is not\n          present, and if no time information is known, the null\n          string is returned.",
            "format": "binary"
          },
          "probeResetControl": {
            "type": "string",
            "description": "Setting this object to warmBoot(2) causes the device to\n          restart the application software with current configuration\n          parameters saved in non-volatile memory.  Setting this\n          object to coldBoot(3) causes the device to reinitialize\n          configuration parameters in non-volatile memory to default\n          values and restart the application software.  When the device\n          is running normally, this variable has a value of\n          running(1)."
          },
          "probeDownloadFile": {
            "type": "string",
            "description": "The file name to be downloaded from the TFTP server when a\n          download is next requested via this MIB.  This value is set to\n          the zero length string when no file name has been specified.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "probeDownloadTFTPServer": {
            "type": "string",
            "description": "The IP address of the TFTP server that contains the boot\n          image to load when a download is next requested via this MIB.\n          This value is set to `0.0.0.0' when no IP address has been\n          specified.",
            "format": "inet:ipv4-address"
          },
          "probeDownloadAction": {
            "type": "string",
            "description": "When this object is set to downloadToRAM(2) or\n          downloadToPROM(3), the device will discontinue its\n          normal operation and begin download of the image specified\n          by probeDownloadFile from the server specified by\n          probeDownloadTFTPServer using the TFTP protocol.  If\n          downloadToRAM(2) is specified, the new image is copied\n          to RAM only (the old image remains unaltered in the flash\n          EPROM).  If downloadToPROM(3) is specified\n          the new image is written to the flash EPROM\n          memory after its checksum has been verified to be correct.\n          When the download process is completed, the device will\n          \n          \n          \n          \n          \n          warm boot to restart the newly loaded application.\n          When the device is not downloading, this object will have\n          a value of notDownloading(1)."
          },
          "probeDownloadStatus": {
            "type": "string",
            "description": "The status of the last download procedure, if any.  This\n          object will have a value of downloadStatusUnknown(2) if no\n          download process has been performed."
          },
          "netDefaultGateway": {
            "type": "string",
            "description": "The IP Address of the default gateway.  If this value is\n          undefined or unknown, it shall have the value 0.0.0.0.",
            "format": "inet:ipv4-address"
          },
          "protocolDirID": {
            "type": "string",
            "description": "A unique identifier for a particular protocol.  Standard\n            identifiers will be defined in a manner such that they\n            can often be used as specifications for new protocols - i.e.\n            a tree-structured assignment mechanism that matches the\n            protocol encapsulation `tree' and which has algorithmic\n            assignment mechanisms for certain subtrees. See RFC XXX for\n            more details.\n            \n            Despite the algorithmic mechanism, the probe will only place\n            entries in here for those protocols it chooses to collect.  In\n            other words, it need not populate this table with all of the\n            possible ethernet protocol types, nor need it create them on\n            the fly when it sees them.  Whether or not it does these\n            things is a matter of product definition (cost/benefit,\n            usability), and is up to the designer of the product.\n            \n            If an entry is written to this table with a protocolDirID that\n            the agent doesn't understand, either directly or\n            algorithmically, the SET request will be rejected with an\n            inconsistentName or badValue (for SNMPv1) error.",
            "format": "binary"
          },
          "protocolDirParameters": {
            "type": "string",
            "description": "A set of parameters for the associated protocolDirID.\n            See the associated RMON2 Protocol Identifiers document\n            for a description of the possible parameters. There\n            will be one octet in this string for each sub-identifier in\n            the protocolDirID, and the parameters will appear here in the\n            same order as the associated sub-identifiers appear in the\n            protocolDirID.\n            \n            Every node in the protocolDirID tree has a different, optional\n            set of parameters defined (that is, the definition of\n            parameters for a node is optional).  The proper parameter\n            value for each node is included in this string.  Note that the\n            inclusion of a parameter value in this string for each node is\n            not optional - what is optional is that a node may have no\n            parameters defined, in which case the parameter field for that\n            node will be zero.",
            "format": "binary"
          },
          "protocolDirLocalIndex": {
            "type": "string",
            "description": "protocolDirLocalIndex",
            "x-yang-type": "leafref"
          },
          "protocolDirDescr": {
            "type": "string",
            "description": "A textual description of the protocol encapsulation.\n            A probe may choose to describe only a subset of the\n            entire encapsulation (e.g. only the highest layer).\n            \n            This object is intended for human consumption only.\n            \n            This object may not be modified if the associated\n            protocolDirStatus object is equal to active(1).",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "protocolDirType": {
            "type": "string",
            "description": "This object describes 2 attributes of this protocol\n            directory entry.\n            \n            The presence or absence of the `extensible' bit describes\n            whether or not this protocol directory entry can be extended\n            \n            \n            \n            \n            \n            by the user by creating protocol directory entries which are\n            children of this protocol.\n            \n            An example of an entry that will often allow extensibility is\n            `ip.udp'.  The probe may automatically populate some children\n            of this node such as `ip.udp.snmp' and `ip.udp.dns'.\n            A probe administrator or user may also populate additional\n            children via remote SNMP requests that create entries in this\n            table.  When a child node is added for a protocol for which the\n            probe has no built in support, extending a parent node (for\n            which the probe does have built in support),\n            that child node is not extendible.  This is termed `limited\n            extensibility'.\n            \n            When a child node is added through this extensibility\n            mechanism, the values of protocolDirLocalIndex and\n            protocolDirType shall be assigned by the agent.\n            \n            The other objects in the entry will be assigned by the\n            manager who is creating the new entry.\n            \n            This object also describes whether or not this agent can\n            recognize addresses for this protocol, should it be a network\n            level protocol.  That is, while a probe may be able to\n            recognize packets of a particular network layer protocol and\n            count them, it takes additional logic to be able to recognize\n            the addresses in this protocol and to populate network layer\n            or application layer tables with the addresses in this\n            protocol.  If this bit is set, the agent will recognize\n            network layer addresses for this protoocl and populate the\n            network and application layer host and matrix tables with\n            these protocols.\n            \n            Note that when an entry is created, the agent will supply\n            values for the bits that match the capabilities of the agent\n            with respect to this protocol.  Note that since row creations\n            usually exercise the limited extensibility feature, these\n            bits will usually be set to zero.",
            "format": "binary"
          },
          "protocolDirAddressMapConfig": {
            "type": "string",
            "description": "This object describes and configures the probe's support for\n            address mapping for this protocol.  When the probe creates\n            entries in this table for all protocols that it understands,\n            it will set the entry to notSupported(1) if it doesn't have\n            the capability to perform address mapping for the protocol or\n            if this protocol is not a network-layer protocol.  When\n            an entry is created in this table by a management operation as\n            part of the limited extensibility feature, the probe must set\n            this value to notSupported(1), because limited extensibility\n            of the protocolDirTable does not extend to interpreting\n            addresses of the extended protocols.\n            \n            If the value of this object is notSupported(1), the probe\n            will not perform address mapping for this protocol and\n            shall not allow this object to be changed to any other value.\n            If the value of this object is supportedOn(3), the probe\n            supports address mapping for this protocol and is configured\n            to perform address mapping for this protocol for all\n            addressMappingControlEntries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports address mapping for this protocol but is configured\n            to not perform address mapping for this protocol for any\n            addressMappingControlEntries and all interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the addressMappingTable."
          },
          "protocolDirHostConfig": {
            "type": "string",
            "description": "This object describes and configures the probe's support for\n            the network layer and application layer host tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlHostTable for this protocol or if the alHostTable is\n            implemented but doesn't have the capability to track this\n            protocol.  Note that if the alHostTable is implemented, the\n            probe may only support a protocol if it is supported in both\n            the nlHostTable and the alHostTable.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate the nlHostTable and alHostTable\n            with addresses it discovers for this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track the nlHostTable or alHostTable for this\n            protocol and shall not allow this object to be changed to any\n            other value. If the value of this object is supportedOn(3),\n            the probe supports tracking of the nlHostTable and alHostTable\n            for this protocol and is configured to track both tables\n            for this protocol for all control entries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports tracking of the nlHostTable and alHostTable for this\n            protocol but is configured to not track these tables\n            for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlHostTable and alHostTable.\n            \n            Note that since each alHostEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
          },
          "protocolDirMatrixConfig": {
            "type": "string",
            "description": "This object describes and configures the probe's support for\n            the network layer and application layer matrix tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlMatrixTables for this protocol or if the alMatrixTables are\n            implemented but don't have the capability to track this\n            protocol.  Note that if the alMatrix tables are implemented,\n            the probe may only support a protocol if it is supported in\n            the the both of the nlMatrixTables and both of the\n            alMatrixTables.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate both of the nlMatrixTables and\n            both of the alMatrixTables with addresses it discovers for\n            this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track either of the nlMatrixTables or the\n            alMatrixTables for this protocol and shall not allow this\n            object to be changed to any other value. If the value of this\n            object is supportedOn(3), the probe supports tracking of both\n            of the nlMatrixTables and (if implemented) both of the\n            alMatrixTables for this protocol and is configured to track\n            these tables for this protocol for all control entries and all\n            interfaces. If the value of this object is supportedOff(2),\n            the probe supports tracking of both of the nlMatrixTables and\n            (if implemented) both of the alMatrixTables for this protocol\n            but is configured to not track these tables for this\n            protocol for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlMatrixTables and the alMatrixTables.\n            \n            Note that since each alMatrixEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
          },
          "protocolDirOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "protocolDirStatus": {
            "type": "string",
            "description": "The status of this protocol directory entry.\n            \n            An entry may not exist in the active state unless all\n            \n            \n            \n            \n            \n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable, nlMatrixSDTable, nlMatrixDSTable,\n            alHostTable, alMatrixSDTable, and alMatrixDSTable shall be\n            deleted.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "protocolDistControlIndex": {
            "type": "string",
            "description": "protocolDistControlIndex",
            "x-yang-type": "leafref"
          },
          "protocolDistControlDataSource": {
            "type": "string",
            "description": "The source of data for the this protocol distribution.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            protocolDistControlStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:DataSource"
          },
          "protocolDistControlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            \n            \n            \n            \n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "protocolDistControlCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this control entry was last\n            activated. This can be used by the management station to\n            ensure that the table has not been deleted and recreated\n            between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "protocolDistControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "protocolDistControlStatus": {
            "type": "string",
            "description": "The status of this row.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the protocolDistStatsTable shall be deleted.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "protocolDistStatsPkts": {
            "type": "string",
            "description": "The number of packets without errors received of this\n            protocol type.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "protocolDistStatsOctets": {
            "type": "string",
            "description": "The number of octets in packets received of this protocol\n            type since it was added to the protocolDistStatsTable\n            (excluding framing bits but including FCS octets), except for\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "addressMapControlIndex": {
            "type": "integer",
            "description": "A unique index for this entry in the addressMapControlTable.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "addressMapControlDataSource": {
            "type": "string",
            "description": "The source of data for this addressMapControlEntry.",
            "x-yang-type": "RMON2-MIB:DataSource"
          },
          "addressMapControlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "addressMapControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "addressMapControlStatus": {
            "type": "string",
            "description": "The status of this addressMap control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the addressMapTable shall be deleted.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "addressMapTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "addressMapNetworkAddress": {
            "type": "string",
            "description": "The network address for this relation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the\n            index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
            "format": "binary"
          },
          "addressMapSource": {
            "type": "string",
            "description": "The interface or port on which the associated network\n            address was most recently seen.\n            \n            \n            \n            \n            \n            If this address mapping was discovered on an interface, this\n            object shall identify the instance of the ifIndex\n            object, defined in [3,5], for the desired interface.\n            For example, if an entry were to receive data from\n            interface #1, this object would be set to ifIndex.1.\n            \n            If this address mapping was discovered on a port, this\n            object shall identify the instance of the rptrGroupPortIndex\n            object, defined in [RFC1516], for the desired port.\n            For example, if an entry were to receive data from\n            group #1, port #1, this object would be set to\n            rptrGroupPortIndex.1.1.\n            \n            Note that while the dataSource associated with this entry\n            may only point to index objects, this object may at times\n            point to repeater port objects. This situation occurs when\n            the dataSource points to an interface which is a locally\n            attached repeater and the agent has additional information\n            about the source port of traffic seen on that repeater.",
            "x-yang-type": "yang:object-identifier-128"
          },
          "addressMapPhysicalAddress": {
            "type": "string",
            "description": "The last source physical address on which the associated\n            network address was seen.  If the protocol of the associated\n            network address was encapsulated inside of a network-level or\n            higher protocol, this will be the address of the next-lower\n            protocol with the addressRecognitionCapable bit enabled and\n            will be formatted as specified for that protocol.",
            "format": "binary"
          },
          "addressMapLastChange": {
            "type": "string",
            "description": "The value of sysUpTime at the time this entry was last\n            created or the values of the physical address changed.\n            \n            This can be used to help detect duplicate address problems, in\n            which case this object will be updated frequently.",
            "x-yang-type": "yang:timestamp"
          },
          "hlHostControlIndex": {
            "type": "string",
            "description": "hlHostControlIndex",
            "x-yang-type": "leafref"
          },
          "hlHostControlDataSource": {
            "type": "string",
            "description": "The source of data for the associated host tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            hlHostControlStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:DataSource"
          },
          "hlHostControlNlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            \n            \n            \n            \n            \n            nlHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlHostTable is inactive because no protocols\n            are enabled in the protocol directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlNlInserts": {
            "type": "integer",
            "description": "The number of times an nlHost entry has been\n            inserted into the nlHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlNlDeletes": {
            "type": "integer",
            "description": "The number of times an nlHost entry has been\n            deleted from the nlHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            \n            \n            \n            \n            \n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlNlMaxDesiredEntries": {
            "type": "integer",
            "description": "The maximum number of entries that are desired in the\n            nlHostTable on behalf of this control entry. The probe will\n            not create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "hlHostControlAlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            alHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            \n            \n            \n            \n            \n            Note that if the alHostTable is not implemented or is inactive\n            because no protocols are enabled in the protocol directory,\n            this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlAlInserts": {
            "type": "integer",
            "description": "The number of times an alHost entry has been\n            inserted into the alHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlAlDeletes": {
            "type": "integer",
            "description": "The number of times an alHost entry has been\n            deleted from the alHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlHostControlAlMaxDesiredEntries": {
            "type": "integer",
            "description": "The maximum number of entries that are desired in the alHost\n            table on behalf of this control entry. The probe will not\n            create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "hlHostControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "hlHostControlStatus": {
            "type": "string",
            "description": "The status of this hlHostControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable and alHostTable shall be deleted.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "nlHostTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "nlHostAddress": {
            "type": "string",
            "description": "nlHostAddress",
            "x-yang-type": "leafref"
          },
          "nlHostInPkts": {
            "type": "string",
            "description": "The number of packets without errors transmitted to\n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlHostOutPkts": {
            "type": "string",
            "description": "The number of packets without errors transmitted by\n            \n            \n            \n            \n            \n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlHostInOctets": {
            "type": "string",
            "description": "The number of octets transmitted to this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlHostOutOctets": {
            "type": "string",
            "description": "The number of octets transmitted by this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlHostOutMacNonUnicastPkts": {
            "type": "string",
            "description": "The number of packets without errors transmitted by this\n            address that were directed to any MAC broadcast addresses\n            or to any MAC multicast addresses since this host was\n            added to the nlHostTable. Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlHostCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "hlMatrixControlIndex": {
            "type": "string",
            "description": "hlMatrixControlIndex",
            "x-yang-type": "leafref"
          },
          "hlMatrixControlDataSource": {
            "type": "string",
            "description": "The source of the data for the associated matrix tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            \n            \n            \n            \n            \n            identified interface.\n            \n            This object may not be modified if the associated\n            hlMatrixControlStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:DataSource"
          },
          "hlMatrixControlNlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlMatrixTables are inactive because no\n            protocols are enabled in the protocol directory, this value\n            should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlNlInserts": {
            "type": "integer",
            "description": "The number of times an nlMatrix entry has been\n            inserted into the nlMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the nlMatrixSDTable and nlMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            \n            \n            \n            \n            Note that the sum of then nlMatrixSDTable and nlMatrixDSTable\n            sizes can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlNlDeletes": {
            "type": "integer",
            "description": "The number of times an nlMatrix entry has been\n            deleted from the nlMatrix tables (for any reason).  If an\n            entry is deleted, then inserted, and then deleted, this\n            counter will be incremented by 2.  The deletion of a\n            conversation from both the nlMatrixSDTable and nlMatrixDSTable\n            shall be counted as two deletions (even though every deletion\n            from one table must be accompanied by a deletion from the\n            other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlNlMaxDesiredEntries": {
            "type": "integer",
            "description": "The maximum number of entries that are desired in the\n            nlMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "hlMatrixControlAlDroppedFrames": {
            "type": "integer",
            "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the alMatrixTables are not implemented or are\n            inactive because no protocols are enabled in the protocol\n            directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlAlInserts": {
            "type": "integer",
            "description": "The number of times an alMatrix entry has been\n            inserted into the alMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            \n            \n            \n            \n            \n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlAlDeletes": {
            "type": "integer",
            "description": "The number of times an alMatrix entry has been\n            deleted from the alMatrix tables.  If an entry is deleted,\n            then inserted, and then deleted, this counter will be\n            incremented by 2.  The deletion of a conversation from both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two deletions (even though every deletion from one table must\n            be accompanied by a deletion from the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "hlMatrixControlAlMaxDesiredEntries": {
            "type": "integer",
            "description": "The maximum number of entries that are desired in the\n            alMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "hlMatrixControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "hlMatrixControlStatus": {
            "type": "string",
            "description": "The status of this hlMatrixControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixSDTable,\n            nlMatrixDSTable, alMatrixSDTable, and the alMatrixDSTable\n            shall be deleted by the agent.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "nlMatrixSDTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "nlMatrixSDSourceAddress": {
            "type": "string",
            "description": "nlMatrixSDSourceAddress",
            "x-yang-type": "leafref"
          },
          "nlMatrixSDDestAddress": {
            "type": "string",
            "description": "nlMatrixSDDestAddress",
            "x-yang-type": "leafref"
          },
          "nlMatrixSDPkts": {
            "type": "string",
            "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixSDTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlMatrixSDOctets": {
            "type": "string",
            "description": "The number of octets transmitted from the source address to\n            the destination address since this entry was added to the\n            nlMatrixSDTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlMatrixSDCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "nlMatrixDSTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "nlMatrixDSSourceAddress": {
            "type": "string",
            "description": "nlMatrixDSSourceAddress",
            "x-yang-type": "leafref"
          },
          "nlMatrixDSDestAddress": {
            "type": "string",
            "description": "nlMatrixDSDestAddress",
            "x-yang-type": "leafref"
          },
          "nlMatrixDSPkts": {
            "type": "string",
            "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixDSTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlMatrixDSOctets": {
            "type": "string",
            "description": "The number of octets transmitted from the source address\n            to the destination address since this entry was added to the\n            nlMatrixDSTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "nlMatrixDSCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "nlMatrixTopNControlIndex": {
            "type": "string",
            "description": "nlMatrixTopNControlIndex",
            "x-yang-type": "leafref"
          },
          "nlMatrixTopNControlMatrixIndex": {
            "type": "integer",
            "description": "The nlMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The nlMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNControlRateBase": {
            "type": "string",
            "description": "The variable for each nlMatrix[SD/DS] entry that the\n            nlMatrixTopNEntries are sorted by.\n            \n            \n            \n            \n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1)."
          },
          "nlMatrixTopNControlTimeRemaining": {
            "type": "integer",
            "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            nlMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of nlMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the nlMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the nlMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNControlGeneratedReports": {
            "type": "integer",
            "description": "The number of reports that have been generated by this entry.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "nlMatrixTopNControlDuration": {
            "type": "integer",
            "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated nlMatrixTopNControlTimeRemaining object is\n            set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the nlMatrixTopNControlTimeRemaining is set.\n            This value shall be zero if no reports have been\n            requested for this nlMatrixTopNControlEntry.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNControlRequestedSize": {
            "type": "integer",
            "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set nlMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNControlGrantedSize": {
            "type": "integer",
            "description": "The maximum number of matrix entries in this report.\n            \n            When the associated nlMatrixTopNControlRequestedSize object is\n            created or modified, the probe should set this\n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            nlMatrixTopNControlRequestedSize object.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNPktRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            \n            \n            \n            \n            \n            matrix entries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNOctetRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of nlMatrixTopNPktRate or nlMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNControlStartTime": {
            "type": "string",
            "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated nlMatrixTopNControlTimeRemaining object was\n            modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
            "x-yang-type": "yang:timestamp"
          },
          "nlMatrixTopNControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "nlMatrixTopNControlStatus": {
            "type": "string",
            "description": "The status of this nlMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            \n            \n            \n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixTopNTable shall be deleted\n            by the agent.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "nlMatrixTopNIndex": {
            "type": "integer",
            "description": "An index that uniquely identifies an entry in\n            the nlMatrixTopNTable among those in the same report.\n            \n            \n            \n            \n            \n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, increasing values of nlMatrixTopNIndex shall\n            be assigned to entries with decreasing values of\n            nlMatrixTopNPktRate until index N is assigned or there are no\n            more nlMatrixTopNEntries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, increasing values of nlMatrixTopNIndex\n            shall be assigned to entries with decreasing values of\n            nlMatrixTopNOctetRate until index N is assigned or there are\n            no more nlMatrixTopNEntries.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNProtocolDirLocalIndex": {
            "type": "integer",
            "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "nlMatrixTopNSourceAddress": {
            "type": "string",
            "description": "The network layer address of the source host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
            "format": "binary"
          },
          "nlMatrixTopNDestAddress": {
            "type": "string",
            "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the nlMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
            "format": "binary"
          },
          "nlMatrixTopNPktRate": {
            "type": "integer",
            "description": "The number of packets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object.\n            If the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNPkts, this variable will be used to sort this\n            report.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "nlMatrixTopNReversePktRate": {
            "type": "integer",
            "description": "The number of packets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object (note\n            that the corresponding nlMatrixSDPkts object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNPkts, the sort of topN entries is based\n            entirely on nlMatrixTopNPktRate, and not on the value of this\n            object.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "nlMatrixTopNOctetRate": {
            "type": "integer",
            "description": "The number of octets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDOctets object.  If\n            the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNOctets, this variable will be used to sort this\n            report.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "nlMatrixTopNReverseOctetRate": {
            "type": "integer",
            "description": "The number of octets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixDSOctets object (note\n            that the corresponding nlMatrixSDOctets object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNOctets, the sort of topN entries is based\n            entirely on nlMatrixTopNOctetRate, and not on the value of\n            this object.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "protocolDirLocalIndex_2": {
            "type": "string",
            "description": "protocolDirLocalIndex_2",
            "x-yang-type": "leafref"
          },
          "alHostTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "alHostInPkts": {
            "type": "string",
            "description": "The number of packets of this protocol type without errors\n            transmitted to this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alHostOutPkts": {
            "type": "string",
            "description": "The number of packets of this protocol type without errors\n            transmitted by this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alHostInOctets": {
            "type": "string",
            "description": "The number of octets transmitted to this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            \n            \n            \n            \n            \n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alHostOutOctets": {
            "type": "string",
            "description": "The number of octets transmitted by this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alHostCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "alMatrixSDTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "alMatrixSDPkts": {
            "type": "string",
            "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alMatrixSDOctets": {
            "type": "string",
            "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alMatrixSDCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "alMatrixDSTimeMark": {
            "type": "string",
            "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
            "x-yang-type": "RMON2-MIB:TimeFilter"
          },
          "alMatrixDSPkts": {
            "type": "string",
            "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alMatrixDSOctets": {
            "type": "string",
            "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
            "x-yang-type": "yang:zero-based-counter32"
          },
          "alMatrixDSCreateTime": {
            "type": "string",
            "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
            "x-yang-type": "RMON2-MIB:LastCreateTime"
          },
          "alMatrixTopNControlIndex": {
            "type": "string",
            "description": "alMatrixTopNControlIndex",
            "x-yang-type": "leafref"
          },
          "alMatrixTopNControlMatrixIndex": {
            "type": "integer",
            "description": "The alMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The alMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNControlRateBase": {
            "type": "string",
            "description": "The variable for each alMatrix[SD/DS] entry that the\n            \n            \n            \n            \n            \n            alMatrixTopNEntries are sorted by, as well as the\n            selector of the view of the matrix table that will be\n            used.\n            \n            The values alMatrixTopNTerminalsPkts and\n            alMatrixTopNTerminalsOctets cause collection only from\n            protocols that have no child protocols that are counted.  The\n            values alMatrixTopNAllPkts and alMatrixTopNAllOctets cause\n            collection from all alMatrix entries.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1)."
          },
          "alMatrixTopNControlTimeRemaining": {
            "type": "integer",
            "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            alMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of alMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the alMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the alMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNControlGeneratedReports": {
            "type": "integer",
            "description": "The number of reports that have been generated by this entry.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "alMatrixTopNControlDuration": {
            "type": "integer",
            "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated alMatrixTopNControlTimeRemaining object\n            is set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the alMatrixTopNControlTimeRemaining is set.\n            \n            This value shall be zero if no reports have been\n            requested for this alMatrixTopNControlEntry.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNControlRequestedSize": {
            "type": "integer",
            "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set alMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNControlGrantedSize": {
            "type": "integer",
            "description": "The maximum number of matrix entries in this report.\n            \n            When the associated alMatrixTopNControlRequestedSize object\n            is created or modified, the probe should set this\n            \n            \n            \n            \n            \n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            alMatrixTopNControlRequestedSize object.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNPktRate shall be placed in this table in\n            decreasing order of this rate until there is no more room or\n            until there are no more matrix entries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNOctetRate shall be placed in this table\n            in decreasing order of this rate until there is no more room\n            or until there are no more matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of alMatrixTopNPktRate or alMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNControlStartTime": {
            "type": "string",
            "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated alMatrixTopNControlTimeRemaining object\n            was modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
            "x-yang-type": "yang:timestamp"
          },
          "alMatrixTopNControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "alMatrixTopNControlStatus": {
            "type": "string",
            "description": "The status of this alMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the alMatrixTopNTable shall be\n            deleted by the agent.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "alMatrixTopNIndex": {
            "type": "integer",
            "description": "An index that uniquely identifies an entry in\n            the alMatrixTopNTable among those in the same report.\n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, increasing\n            values of alMatrixTopNIndex shall be assigned to entries with\n            decreasing values of alMatrixTopNPktRate until index N is\n            assigned or there are no more alMatrixTopNEntries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets,\n            increasing values of alMatrixTopNIndex shall be assigned to\n            entries with decreasing values of alMatrixTopNOctetRate until\n            index N is assigned or there are no more alMatrixTopNEntries.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNProtocolDirLocalIndex": {
            "type": "integer",
            "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNSourceAddress": {
            "type": "string",
            "description": "The network layer address of the source host in this\n            conversation.\n            This is represented as an octet string with\n            specific semantics and length as identified\n            \n            \n            \n            \n            \n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
            "format": "binary"
          },
          "alMatrixTopNDestAddress": {
            "type": "string",
            "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
            "format": "binary"
          },
          "alMatrixTopNAppProtocolDirLocalIndex": {
            "type": "integer",
            "description": "The type of the protocol counted by this matrix entry.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "alMatrixTopNPktRate": {
            "type": "integer",
            "description": "The number of packets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDPkts\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, this\n            variable will be used to sort this report.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "alMatrixTopNReversePktRate": {
            "type": "integer",
            "description": "The number of packets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSPkts object  (note that the corresponding\n            alMatrixSDPkts object selected is the one whose source address\n            is equal to alMatrixTopNDestAddress and whose destination\n            address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            to alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, the sort\n            of topN entries is based entirely on alMatrixTopNPktRate, and\n            not on the value of this object.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "alMatrixTopNOctetRate": {
            "type": "integer",
            "description": "The number of octets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDOctets\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, this\n            variable will be used to sort this report.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "alMatrixTopNReverseOctetRate": {
            "type": "integer",
            "description": "The number of octets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSOctets object  (note that the corresponding\n            alMatrixSDOctets object selected is the one whose source\n            address is equal to alMatrixTopNDestAddress and whose\n            destination address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            \n            \n            \n            \n            \n            to alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, the\n            sort of topN entries is based entirely on\n            alMatrixTopNOctetRate, and not on the value of this object.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "usrHistoryControlIndex": {
            "type": "string",
            "description": "usrHistoryControlIndex",
            "x-yang-type": "leafref"
          },
          "usrHistoryControlObjects": {
            "type": "integer",
            "description": "The number of MIB objects to be collected\n            in the portion of usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            This object may not be modified if the associated instance\n            of usrHistoryControlStatus is equal to active(1).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "usrHistoryControlBucketsRequested": {
            "type": "integer",
            "description": "The requested number of discrete time intervals\n            over which data is to be saved in the part of the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            \n            When this object is created or modified, the probe\n            should set usrHistoryControlBucketsGranted as closely to\n            this object as is possible for the particular probe\n            implementation and available resources.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "usrHistoryControlBucketsGranted": {
            "type": "integer",
            "description": "The number of discrete sampling intervals\n            over which data shall be saved in the part of\n            the usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            When the associated usrHistoryControlBucketsRequested\n            \n            \n            \n            \n            \n            object is created or modified, the probe should set\n            this object as closely to the requested value as is\n            possible for the particular  probe implementation and\n            available resources.  The probe must not lower this\n            value except as a result of a modification to the associated\n            usrHistoryControlBucketsRequested object.\n            \n            The associated usrHistoryControlBucketsRequested object\n            should be set before or at the same time as this object\n            to allow the probe to accurately estimate the resources\n            required for this usrHistoryControlEntry.\n            \n            There will be times when the actual number of buckets\n            associated with this entry is less than the value of\n            this object.  In this case, at the end of each sampling\n            interval, a new bucket will be added to the usrHistoryTable.\n            \n            When the number of buckets reaches the value of this object\n            and a new bucket is to be added to the usrHistoryTable,\n            the oldest bucket associated with this usrHistoryControlEntry\n            shall be deleted by the agent so that the new bucket can be\n            added.\n            \n            When the value of this object changes to a value less than\n            the current value, entries are deleted from the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            Enough of the oldest of these entries shall be deleted by the\n            agent so that their number remains less than or equal to the\n            new value of this object.\n            \n            When the value of this object changes to a value greater\n            than the current value, the number of associated usrHistory\n            entries may be allowed to grow.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "usrHistoryControlInterval": {
            "type": "integer",
            "description": "The interval in seconds over which the data is\n            sampled for each bucket in the part of the usrHistory\n            table associated with this usrHistoryControlEntry.\n            \n            Because the counters in a bucket may overflow at their\n            maximum value with no indication, a prudent manager will\n            take into account the possibility of overflow in any of\n            \n            \n            \n            \n            \n            the associated counters. It is important to consider the\n            minimum time in which any counter could overflow on a\n            particular media type and set the usrHistoryControlInterval\n            object to a value less than this interval.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "usrHistoryControlOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "usrHistoryControlStatus": {
            "type": "string",
            "description": "The status of this variable history control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the usrHistoryTable shall be deleted.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "usrHistoryObjectIndex": {
            "type": "string",
            "description": "usrHistoryObjectIndex",
            "x-yang-type": "leafref"
          },
          "usrHistoryObjectVariable": {
            "type": "string",
            "description": "The object identifier of the particular variable to be\n            sampled.\n            \n            Only variables that resolve to an ASN.1 primitive type of\n            Integer32 (Integer32, Counter, Gauge, or TimeTicks) may be\n            sampled.\n            \n            Because SNMP access control is articulated entirely in terms\n            of the contents of MIB views, no access control mechanism\n            exists that can restrict the value of this object to identify\n            only those objects that exist in a particular MIB view.\n            Because there is thus no acceptable means of restricting the\n            read access that could be obtained through the user history\n            \n            \n            \n            \n            \n            mechanism, the probe must only grant write access to this\n            object in those views that have read access to all objects on\n            the probe.\n            \n            During a set operation, if the supplied variable name is not\n            available in the selected MIB view, a badValue error must be\n            returned.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
            "x-yang-type": "yang:object-identifier-128"
          },
          "usrHistoryObjectSampleType": {
            "type": "string",
            "description": "The method of sampling the selected variable for storage in\n            the usrHistoryTable.\n            \n            If the value of this object is absoluteValue(1), the value of\n            the selected variable will be copied directly into the history\n            bucket.\n            \n            If the value of this object is deltaValue(2), the value of the\n            selected variable at the last sample will be subtracted from\n            the current value, and the difference will be stored in the\n            history bucket. If the associated usrHistoryObjectVariable\n            instance could not be obtained at the previous sample\n            interval, then a delta sample is not possible, and the value\n            of the associated usrHistoryValStatus object for this interval\n            will be valueNotAvailable(1).\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1)."
          },
          "usrHistorySampleIndex": {
            "type": "integer",
            "description": "An index that uniquely identifies the particular sample this\n            entry represents among all samples associated with the same\n            usrHistoryControlEntry. This index starts at 1 and increases\n            by one as each new sample is taken.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "usrHistoryIntervalStart": {
            "type": "string",
            "description": "The value of sysUpTime at the start of the interval over\n            which this sample was measured.  If the probe keeps track of\n            the time of day, it should start the first sample of the\n            history at a time such that when the next hour of the day\n            begins, a sample is started at that instant.\n            \n            Note that following this rule may require the probe to delay\n            collecting the first sample of the history, as each sample\n            must be of the same interval. Also note that the sample which\n            is currently being collected is not accessible in this table\n            until the end of its interval.",
            "x-yang-type": "yang:timestamp"
          },
          "usrHistoryIntervalEnd": {
            "type": "string",
            "description": "The value of sysUpTime at the end of the interval over which\n            this sample was measured.",
            "x-yang-type": "yang:timestamp"
          },
          "usrHistoryAbsValue": {
            "type": "integer",
            "description": "The absolute value (i.e. unsigned value) of the\n            user-specified statistic during the last sampling period. The\n            value during the current sampling period is not made available\n            until the period is completed.\n            \n            To obtain the true value for this sampling interval, the\n            associated instance of usrHistoryValStatus must be checked,\n            and usrHistoryAbsValue adjusted as necessary.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then this object will have a value of zero and the\n            associated instance of usrHistoryValStatus will be set to\n            'valueNotAvailable(1)'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "usrHistoryValStatus": {
            "type": "string",
            "description": "This object indicates the validity and sign of the data in\n            the associated instance of usrHistoryAbsValue.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then 'valueNotAvailable(1)' will be returned.\n            \n            If the sample is valid and actual value of the sample is\n            greater than or equal to zero then 'valuePositive(2)' is\n            returned.\n            \n            If the sample is valid and the actual value of the sample is\n            less than zero, 'valueNegative(3)' will be returned. The\n            associated instance of usrHistoryAbsValue should be multiplied\n            by -1 to obtain the true sample value."
          },
          "ifIndex": {
            "type": "string",
            "description": "ifIndex",
            "x-yang-type": "leafref"
          },
          "serialMode": {
            "type": "string",
            "description": "The type of incoming connection to expect on this serial\n            interface."
          },
          "serialProtocol": {
            "type": "string",
            "description": "The type of data link encapsulation to be used on this\n            serial interface."
          },
          "serialTimeout": {
            "type": "integer",
            "description": "This timeout value is used when the Management Station has\n            initiated the conversation over the serial link. This variable\n            represents the number of seconds of inactivity allowed before\n            terminating the connection on this serial interface. Use the\n            \n            \n            \n            \n            \n            serialDialoutTimeout in the case where the probe has initiated\n            the connection for the purpose of sending a trap.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "serialModemInitString": {
            "type": "string",
            "description": "A control string which controls how a modem attached to this\n            serial interface should be initialized.  The initialization\n            is performed once during startup and again after each\n            connection is terminated if the associated serialMode has the\n            value of modem(2).\n            \n            A control string that is appropriate for a wide variety of\n            modems is: '^s^MATE0Q0V1X4 S0=1 S2=43^M'.",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialModemHangUpString": {
            "type": "string",
            "description": "A control string which specifies how to disconnect a modem\n            connection on this serial interface.  This object is only\n            meaningful if the associated serialMode has the value\n            of modem(2).\n            A control string that is appropriate for a wide variety of\n            modems is: '^d2^s+++^d2^sATH0^M^d2'.",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialModemConnectResp": {
            "type": "string",
            "description": "An ASCII string containing substrings that describe the\n            expected modem connection response code and associated bps\n            rate.  The substrings are delimited by the first character\n            in the string, for example:\n               /CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n               CONNECT 4800/4800/CONNECT 9600/9600\n            will be interpreted as:\n                response code    bps rate\n                CONNECT            300\n                CONNECT 1200      1200\n            \n            \n            \n            \n            \n                CONNECT 2400      2400\n                CONNECT 4800      4800\n                CONNECT 9600      9600\n            The agent will use the information in this string to adjust\n            the bps rate of this serial interface once a modem connection\n            is established.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n             CONNECT 4800/4800/CONNECT 9600/9600/CONNECT 14400/14400/\n            CONNECT 19200/19200/CONNECT 38400/38400/'.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "serialModemNoConnectResp": {
            "type": "string",
            "description": "An ASCII string containing response codes that may be\n            generated by a modem to report the reason why a connection\n            attempt has failed.  The response codes are delimited by\n            the first character in the string, for example:\n               /NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/\n            If one of these response codes is received via this serial\n            interface while attempting to make a modem connection,\n            the agent will issue the hang up command as specified by\n            serialModemHangUpString.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/'.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "serialDialoutTimeout": {
            "type": "integer",
            "description": "This timeout value is used when the probe initiates the\n            serial connection with the intention of contacting a\n            management station. This variable represents the number\n            of seconds of inactivity allowed before terminating the\n            connection on this serial interface.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "serialStatus": {
            "type": "string",
            "description": "The status of this serialConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "netConfigIPAddress": {
            "type": "string",
            "description": "The IP address of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            \n            \n            \n            \n            \n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
            "format": "inet:ipv4-address"
          },
          "netConfigSubnetMask": {
            "type": "string",
            "description": "The subnet mask of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
            "format": "inet:ipv4-address"
          },
          "netConfigStatus": {
            "type": "string",
            "description": "The status of this netConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "trapDestIndex": {
            "type": "integer",
            "description": "A value that uniquely identifies this trapDestEntry.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "trapDestCommunity": {
            "type": "string",
            "description": "A community to which this destination address belongs.\n            This entry is associated with any eventEntries in the RMON\n            \n            \n            \n            \n            \n            MIB whose value of eventCommunity is equal to the value of\n            this object.  Every time an associated event entry sends a\n            trap due to an event, that trap will be sent to each\n            address in the trapDestTable with a trapDestCommunity equal to\n            eventCommunity.\n            \n            This object may not be modified if the associated\n            trapDestStatus object is equal to active(1).",
            "format": "binary"
          },
          "trapDestProtocol": {
            "type": "string",
            "description": "The protocol with which to send this trap."
          },
          "trapDestAddress": {
            "type": "string",
            "description": "The address to send traps on behalf of this entry.\n            \n            If the associated trapDestProtocol object is equal to ip(1),\n            the encoding of this object is the same as the snmpUDPAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpUDPAddress of length 6:\n              --\n              -- octets   contents        encoding\n              --  1-4     IP-address      network-byte order\n              --  5-6     UDP-port        network-byte order\n            \n            If the associated trapDestProtocol object is equal to ipx(2),\n            the encoding of this object is the same as the snmpIPXAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpIPXAddress of length 12:\n              --\n              -- octets   contents            encoding\n              --  1-4     network-number      network-byte order\n              --  5-10    physical-address    network-byte order\n              -- 11-12    socket-number       network-byte order\n            \n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            trapDestStatus object is equal to active(1).",
            "format": "binary"
          },
          "trapDestOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "trapDestStatus": {
            "type": "string",
            "description": "The status of this trap destination entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "serialConnectIndex": {
            "type": "integer",
            "description": "A value that uniquely identifies this serialConnection\n            entry.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "serialConnectDestIpAddress": {
            "type": "string",
            "description": "The IP Address that can be reached at the other end of this\n            serial connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
            "format": "inet:ipv4-address"
          },
          "serialConnectType": {
            "type": "string",
            "description": "The type of outgoing connection to make.  If this object\n            has the value direct(1), then a direct serial connection\n            is assumed.  If this object has the value modem(2),\n            then serialConnectDialString will be used to make a modem\n            connection.  If this object has the value switch(3),\n            \n            \n            \n            \n            \n            then serialConnectSwitchConnectSeq will be used to establish\n            the connection over a serial data switch, and\n            serialConnectSwitchDisconnectSeq will be used to terminate\n            the connection.  If this object has the value\n            modem-switch(4), then a modem connection will be made first\n            followed by the switch connection.\n            \n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1)."
          },
          "serialConnectDialString": {
            "type": "string",
            "description": "A control string which specifies how to dial the phone\n            number in order to establish a modem connection.  The\n            string should include dialing prefix and suffix.  For\n            example: ``^s^MATD9,888-1234^M'' will instruct the Probe\n            to send a carriage return followed by the dialing prefix\n            ``ATD'', the phone number ``9,888-1234'', and a carriage\n            return as the dialing suffix.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialConnectSwitchConnectSeq": {
            "type": "string",
            "description": "A control string which specifies how to establish a\n            data switch connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialConnectSwitchDisconnectSeq": {
            "type": "string",
            "description": "A control string which specifies how to terminate a\n            data switch connection.\n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            serialConnectStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialConnectSwitchResetSeq": {
            "type": "string",
            "description": "A control string which specifies how to reset a data\n            switch in the event of a timeout.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
            "x-yang-type": "RMON2-MIB:ControlString"
          },
          "serialConnectOwner": {
            "type": "string",
            "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
            "x-yang-type": "rmon-mib:OwnerString"
          },
          "serialConnectStatus": {
            "type": "string",
            "description": "The status of this serialConnectionEntry.\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to modem(2) or modem-switch(4)\n            and the serialConnectDialString is a zero-length string or\n            cannot be correctly parsed as a ConnectString, the set\n            request will be rejected with badValue(3).\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to switch(3) or modem-switch(4)\n            and the serialConnectSwitchConnectSeq,\n            the serialConnectSwitchDisconnectSeq, or\n            the serialConnectSwitchResetSeq are zero-length strings\n            or cannot be correctly parsed as ConnectStrings, the set\n            request will be rejected with badValue(3).\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "protocolDir": {
            "type": "object",
            "description": "The value of sysUpTime at the time the protocol directory\n          was last modified, either through insertions or deletions,\n          or through modifications of either the\n          protocolDirAddressMapConfig, protocolDirHostConfig, or\n          protocolDirMatrixConfig.",
            "properties": {
              "protocolDirLastChange": {
                "type": "string",
                "description": "The value of sysUpTime at the time the protocol directory\n          was last modified, either through insertions or deletions,\n          or through modifications of either the\n          protocolDirAddressMapConfig, protocolDirHostConfig, or\n          protocolDirMatrixConfig.",
                "x-yang-type": "yang:timestamp"
              }
            }
          },
          "addressMap": {
            "type": "object",
            "description": "The number of times an address mapping entry has been\n          inserted into the addressMapTable.  If an entry is inserted,\n          then deleted, and then inserted, this counter will be\n          incremented by 2.\n          \n          Note that the table size can be determined by subtracting\n          addressMapDeletes from addressMapInserts.",
            "properties": {
              "addressMapInserts": {
                "type": "integer",
                "description": "The number of times an address mapping entry has been\n          inserted into the addressMapTable.  If an entry is inserted,\n          then deleted, and then inserted, this counter will be\n          incremented by 2.\n          \n          Note that the table size can be determined by subtracting\n          addressMapDeletes from addressMapInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "addressMapDeletes": {
                "type": "integer",
                "description": "The number of times an address mapping entry has been\n          deleted from the addressMapTable (for any reason).  If\n          an entry is deleted, then inserted, and then deleted, this\n          counter will be incremented by 2.\n          \n          Note that the table size can be determined by subtracting\n          addressMapDeletes from addressMapInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "addressMapMaxDesiredEntries": {
                "type": "integer",
                "description": "The maximum number of entries that are desired in the\n          addressMapTable. The probe will not create more than\n          this number of entries in the table, but may choose to create\n          fewer entries in this table for any reason including the lack\n          of resources.\n          \n          If this object is set to a value less than the current number\n          of entries, enough entries are chosen in an\n          implementation-dependent manner and deleted so that the number\n          of entries in the table equals the value of this object.\n          \n          If this value is set to -1, the probe may create any number\n          of entries in this table.\n          \n          This object may be used to control how resources are allocated\n          on the probe for the various RMON functions.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "probeConfig": {
            "type": "object",
            "description": "An indication of the RMON MIB groups supported\n          on at least one interface by this probe.",
            "properties": {
              "probeCapabilities": {
                "type": "string",
                "description": "An indication of the RMON MIB groups supported\n          on at least one interface by this probe.",
                "format": "binary"
              },
              "probeSoftwareRev": {
                "type": "string",
                "description": "The software revision of this device.  This string will have\n          a zero length if the revision is unknown.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "probeHardwareRev": {
                "type": "string",
                "description": "The hardware revision of this device.  This string will have\n          a zero length if the revision is unknown.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "probeDateTime": {
                "type": "string",
                "description": "Probe's current date and time.\n          \n          field  octets  contents                  range\n          -----  ------  --------                  -----\n            1      1-2   year                      0..65536\n            2       3    month                     1..12\n            3       4    day                       1..31\n            4       5    hour                      0..23\n            5       6    minutes                   0..59\n            6       7    seconds                   0..60\n                          (use 60 for leap-second)\n            7       8    deci-seconds              0..9\n            8       9    direction from UTC        '+' / '-'\n            9      10    hours from UTC            0..11\n           10      11    minutes from UTC          0..59\n          \n          For example, Tuesday May 26, 1992 at 1:30:15 PM\n          EDT would be displayed as:\n          \n                      1992-5-26,13:30:15.0,-4:0\n          \n          Note that if only local time is known, then\n          timezone information (fields 8-10) is not\n          present, and if no time information is known, the null\n          string is returned.",
                "format": "binary"
              },
              "probeResetControl": {
                "type": "string",
                "description": "Setting this object to warmBoot(2) causes the device to\n          restart the application software with current configuration\n          parameters saved in non-volatile memory.  Setting this\n          object to coldBoot(3) causes the device to reinitialize\n          configuration parameters in non-volatile memory to default\n          values and restart the application software.  When the device\n          is running normally, this variable has a value of\n          running(1)."
              },
              "probeDownloadFile": {
                "type": "string",
                "description": "The file name to be downloaded from the TFTP server when a\n          download is next requested via this MIB.  This value is set to\n          the zero length string when no file name has been specified.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "probeDownloadTFTPServer": {
                "type": "string",
                "description": "The IP address of the TFTP server that contains the boot\n          image to load when a download is next requested via this MIB.\n          This value is set to `0.0.0.0' when no IP address has been\n          specified.",
                "format": "inet:ipv4-address"
              },
              "probeDownloadAction": {
                "type": "string",
                "description": "When this object is set to downloadToRAM(2) or\n          downloadToPROM(3), the device will discontinue its\n          normal operation and begin download of the image specified\n          by probeDownloadFile from the server specified by\n          probeDownloadTFTPServer using the TFTP protocol.  If\n          downloadToRAM(2) is specified, the new image is copied\n          to RAM only (the old image remains unaltered in the flash\n          EPROM).  If downloadToPROM(3) is specified\n          the new image is written to the flash EPROM\n          memory after its checksum has been verified to be correct.\n          When the download process is completed, the device will\n          \n          \n          \n          \n          \n          warm boot to restart the newly loaded application.\n          When the device is not downloading, this object will have\n          a value of notDownloading(1)."
              },
              "probeDownloadStatus": {
                "type": "string",
                "description": "The status of the last download procedure, if any.  This\n          object will have a value of downloadStatusUnknown(2) if no\n          download process has been performed."
              },
              "netDefaultGateway": {
                "type": "string",
                "description": "The IP Address of the default gateway.  If this value is\n          undefined or unknown, it shall have the value 0.0.0.0.",
                "format": "inet:ipv4-address"
              }
            }
          },
          "protocolDirTable": {
            "type": "object",
            "description": "protocolDirTable",
            "properties": {
              "protocolDirID": {
                "type": "string",
                "description": "A unique identifier for a particular protocol.  Standard\n            identifiers will be defined in a manner such that they\n            can often be used as specifications for new protocols - i.e.\n            a tree-structured assignment mechanism that matches the\n            protocol encapsulation `tree' and which has algorithmic\n            assignment mechanisms for certain subtrees. See RFC XXX for\n            more details.\n            \n            Despite the algorithmic mechanism, the probe will only place\n            entries in here for those protocols it chooses to collect.  In\n            other words, it need not populate this table with all of the\n            possible ethernet protocol types, nor need it create them on\n            the fly when it sees them.  Whether or not it does these\n            things is a matter of product definition (cost/benefit,\n            usability), and is up to the designer of the product.\n            \n            If an entry is written to this table with a protocolDirID that\n            the agent doesn't understand, either directly or\n            algorithmically, the SET request will be rejected with an\n            inconsistentName or badValue (for SNMPv1) error.",
                "format": "binary"
              },
              "protocolDirParameters": {
                "type": "string",
                "description": "A set of parameters for the associated protocolDirID.\n            See the associated RMON2 Protocol Identifiers document\n            for a description of the possible parameters. There\n            will be one octet in this string for each sub-identifier in\n            the protocolDirID, and the parameters will appear here in the\n            same order as the associated sub-identifiers appear in the\n            protocolDirID.\n            \n            Every node in the protocolDirID tree has a different, optional\n            set of parameters defined (that is, the definition of\n            parameters for a node is optional).  The proper parameter\n            value for each node is included in this string.  Note that the\n            inclusion of a parameter value in this string for each node is\n            not optional - what is optional is that a node may have no\n            parameters defined, in which case the parameter field for that\n            node will be zero.",
                "format": "binary"
              },
              "protocolDirLocalIndex": {
                "type": "integer",
                "description": "The locally arbitrary, but unique identifier associated\n            with this protocolDir entry.\n            \n            The value for each supported protocol must remain constant at\n            least from one re-initialization of the entity's network\n            management system to the next re-initialization, except that\n            if a protocol is deleted and re-created, it must be re-created\n            with a new value that has not been used since the last\n            re-initialization.\n            \n            The specific value is meaningful only within a given SNMP\n            entity. A protocolDirLocalIndex must not be re-used until the\n            next agent-restart in the event the protocol directory entry\n            is deleted.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "protocolDirDescr": {
                "type": "string",
                "description": "A textual description of the protocol encapsulation.\n            A probe may choose to describe only a subset of the\n            entire encapsulation (e.g. only the highest layer).\n            \n            This object is intended for human consumption only.\n            \n            This object may not be modified if the associated\n            protocolDirStatus object is equal to active(1).",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "protocolDirType": {
                "type": "string",
                "description": "This object describes 2 attributes of this protocol\n            directory entry.\n            \n            The presence or absence of the `extensible' bit describes\n            whether or not this protocol directory entry can be extended\n            \n            \n            \n            \n            \n            by the user by creating protocol directory entries which are\n            children of this protocol.\n            \n            An example of an entry that will often allow extensibility is\n            `ip.udp'.  The probe may automatically populate some children\n            of this node such as `ip.udp.snmp' and `ip.udp.dns'.\n            A probe administrator or user may also populate additional\n            children via remote SNMP requests that create entries in this\n            table.  When a child node is added for a protocol for which the\n            probe has no built in support, extending a parent node (for\n            which the probe does have built in support),\n            that child node is not extendible.  This is termed `limited\n            extensibility'.\n            \n            When a child node is added through this extensibility\n            mechanism, the values of protocolDirLocalIndex and\n            protocolDirType shall be assigned by the agent.\n            \n            The other objects in the entry will be assigned by the\n            manager who is creating the new entry.\n            \n            This object also describes whether or not this agent can\n            recognize addresses for this protocol, should it be a network\n            level protocol.  That is, while a probe may be able to\n            recognize packets of a particular network layer protocol and\n            count them, it takes additional logic to be able to recognize\n            the addresses in this protocol and to populate network layer\n            or application layer tables with the addresses in this\n            protocol.  If this bit is set, the agent will recognize\n            network layer addresses for this protoocl and populate the\n            network and application layer host and matrix tables with\n            these protocols.\n            \n            Note that when an entry is created, the agent will supply\n            values for the bits that match the capabilities of the agent\n            with respect to this protocol.  Note that since row creations\n            usually exercise the limited extensibility feature, these\n            bits will usually be set to zero.",
                "format": "binary"
              },
              "protocolDirAddressMapConfig": {
                "type": "string",
                "description": "This object describes and configures the probe's support for\n            address mapping for this protocol.  When the probe creates\n            entries in this table for all protocols that it understands,\n            it will set the entry to notSupported(1) if it doesn't have\n            the capability to perform address mapping for the protocol or\n            if this protocol is not a network-layer protocol.  When\n            an entry is created in this table by a management operation as\n            part of the limited extensibility feature, the probe must set\n            this value to notSupported(1), because limited extensibility\n            of the protocolDirTable does not extend to interpreting\n            addresses of the extended protocols.\n            \n            If the value of this object is notSupported(1), the probe\n            will not perform address mapping for this protocol and\n            shall not allow this object to be changed to any other value.\n            If the value of this object is supportedOn(3), the probe\n            supports address mapping for this protocol and is configured\n            to perform address mapping for this protocol for all\n            addressMappingControlEntries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports address mapping for this protocol but is configured\n            to not perform address mapping for this protocol for any\n            addressMappingControlEntries and all interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the addressMappingTable."
              },
              "protocolDirHostConfig": {
                "type": "string",
                "description": "This object describes and configures the probe's support for\n            the network layer and application layer host tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlHostTable for this protocol or if the alHostTable is\n            implemented but doesn't have the capability to track this\n            protocol.  Note that if the alHostTable is implemented, the\n            probe may only support a protocol if it is supported in both\n            the nlHostTable and the alHostTable.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate the nlHostTable and alHostTable\n            with addresses it discovers for this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track the nlHostTable or alHostTable for this\n            protocol and shall not allow this object to be changed to any\n            other value. If the value of this object is supportedOn(3),\n            the probe supports tracking of the nlHostTable and alHostTable\n            for this protocol and is configured to track both tables\n            for this protocol for all control entries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports tracking of the nlHostTable and alHostTable for this\n            protocol but is configured to not track these tables\n            for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlHostTable and alHostTable.\n            \n            Note that since each alHostEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
              },
              "protocolDirMatrixConfig": {
                "type": "string",
                "description": "This object describes and configures the probe's support for\n            the network layer and application layer matrix tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlMatrixTables for this protocol or if the alMatrixTables are\n            implemented but don't have the capability to track this\n            protocol.  Note that if the alMatrix tables are implemented,\n            the probe may only support a protocol if it is supported in\n            the the both of the nlMatrixTables and both of the\n            alMatrixTables.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate both of the nlMatrixTables and\n            both of the alMatrixTables with addresses it discovers for\n            this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track either of the nlMatrixTables or the\n            alMatrixTables for this protocol and shall not allow this\n            object to be changed to any other value. If the value of this\n            object is supportedOn(3), the probe supports tracking of both\n            of the nlMatrixTables and (if implemented) both of the\n            alMatrixTables for this protocol and is configured to track\n            these tables for this protocol for all control entries and all\n            interfaces. If the value of this object is supportedOff(2),\n            the probe supports tracking of both of the nlMatrixTables and\n            (if implemented) both of the alMatrixTables for this protocol\n            but is configured to not track these tables for this\n            protocol for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlMatrixTables and the alMatrixTables.\n            \n            Note that since each alMatrixEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
              },
              "protocolDirOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "protocolDirStatus": {
                "type": "string",
                "description": "The status of this protocol directory entry.\n            \n            An entry may not exist in the active state unless all\n            \n            \n            \n            \n            \n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable, nlMatrixSDTable, nlMatrixDSTable,\n            alHostTable, alMatrixSDTable, and alMatrixDSTable shall be\n            deleted.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "protocolDistControlTable": {
            "type": "object",
            "description": "protocolDistControlTable",
            "properties": {
              "protocolDistControlIndex": {
                "type": "integer",
                "description": "A unique index for this protocolDistControlEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "protocolDistControlDataSource": {
                "type": "string",
                "description": "The source of data for the this protocol distribution.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            protocolDistControlStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:DataSource"
              },
              "protocolDistControlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            \n            \n            \n            \n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "protocolDistControlCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this control entry was last\n            activated. This can be used by the management station to\n            ensure that the table has not been deleted and recreated\n            between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              },
              "protocolDistControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "protocolDistControlStatus": {
                "type": "string",
                "description": "The status of this row.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the protocolDistStatsTable shall be deleted.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "protocolDistStatsTable": {
            "type": "object",
            "description": "protocolDistStatsTable",
            "properties": {
              "protocolDistControlIndex": {
                "type": "string",
                "description": "protocolDistControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "protocolDistStatsPkts": {
                "type": "string",
                "description": "The number of packets without errors received of this\n            protocol type.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "protocolDistStatsOctets": {
                "type": "string",
                "description": "The number of octets in packets received of this protocol\n            type since it was added to the protocolDistStatsTable\n            (excluding framing bits but including FCS octets), except for\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              }
            }
          },
          "addressMapControlTable": {
            "type": "object",
            "description": "addressMapControlTable",
            "properties": {
              "addressMapControlIndex": {
                "type": "integer",
                "description": "A unique index for this entry in the addressMapControlTable.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "addressMapControlDataSource": {
                "type": "string",
                "description": "The source of data for this addressMapControlEntry.",
                "x-yang-type": "RMON2-MIB:DataSource"
              },
              "addressMapControlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "addressMapControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "addressMapControlStatus": {
                "type": "string",
                "description": "The status of this addressMap control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the addressMapTable shall be deleted.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "addressMapTable": {
            "type": "object",
            "description": "addressMapTable",
            "properties": {
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "addressMapTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "addressMapNetworkAddress": {
                "type": "string",
                "description": "The network address for this relation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the\n            index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "addressMapSource": {
                "type": "string",
                "description": "The interface or port on which the associated network\n            address was most recently seen.\n            \n            \n            \n            \n            \n            If this address mapping was discovered on an interface, this\n            object shall identify the instance of the ifIndex\n            object, defined in [3,5], for the desired interface.\n            For example, if an entry were to receive data from\n            interface #1, this object would be set to ifIndex.1.\n            \n            If this address mapping was discovered on a port, this\n            object shall identify the instance of the rptrGroupPortIndex\n            object, defined in [RFC1516], for the desired port.\n            For example, if an entry were to receive data from\n            group #1, port #1, this object would be set to\n            rptrGroupPortIndex.1.1.\n            \n            Note that while the dataSource associated with this entry\n            may only point to index objects, this object may at times\n            point to repeater port objects. This situation occurs when\n            the dataSource points to an interface which is a locally\n            attached repeater and the agent has additional information\n            about the source port of traffic seen on that repeater.",
                "x-yang-type": "yang:object-identifier-128"
              },
              "addressMapPhysicalAddress": {
                "type": "string",
                "description": "The last source physical address on which the associated\n            network address was seen.  If the protocol of the associated\n            network address was encapsulated inside of a network-level or\n            higher protocol, this will be the address of the next-lower\n            protocol with the addressRecognitionCapable bit enabled and\n            will be formatted as specified for that protocol.",
                "format": "binary"
              },
              "addressMapLastChange": {
                "type": "string",
                "description": "The value of sysUpTime at the time this entry was last\n            created or the values of the physical address changed.\n            \n            This can be used to help detect duplicate address problems, in\n            which case this object will be updated frequently.",
                "x-yang-type": "yang:timestamp"
              }
            }
          },
          "hlHostControlTable": {
            "type": "object",
            "description": "hlHostControlTable",
            "properties": {
              "hlHostControlIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry in the\n            hlHostControlTable.  Each such entry defines\n            a function that discovers hosts on a particular\n            interface and places statistics about them in the\n            nlHostTable, and optionally in the alHostTable, on\n            behalf of this hlHostControlEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlHostControlDataSource": {
                "type": "string",
                "description": "The source of data for the associated host tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            hlHostControlStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:DataSource"
              },
              "hlHostControlNlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            \n            \n            \n            \n            \n            nlHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlHostTable is inactive because no protocols\n            are enabled in the protocol directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlNlInserts": {
                "type": "integer",
                "description": "The number of times an nlHost entry has been\n            inserted into the nlHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlNlDeletes": {
                "type": "integer",
                "description": "The number of times an nlHost entry has been\n            deleted from the nlHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            \n            \n            \n            \n            \n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlNlMaxDesiredEntries": {
                "type": "integer",
                "description": "The maximum number of entries that are desired in the\n            nlHostTable on behalf of this control entry. The probe will\n            not create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlHostControlAlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            alHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            \n            \n            \n            \n            \n            Note that if the alHostTable is not implemented or is inactive\n            because no protocols are enabled in the protocol directory,\n            this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlAlInserts": {
                "type": "integer",
                "description": "The number of times an alHost entry has been\n            inserted into the alHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlAlDeletes": {
                "type": "integer",
                "description": "The number of times an alHost entry has been\n            deleted from the alHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlHostControlAlMaxDesiredEntries": {
                "type": "integer",
                "description": "The maximum number of entries that are desired in the alHost\n            table on behalf of this control entry. The probe will not\n            create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlHostControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "hlHostControlStatus": {
                "type": "string",
                "description": "The status of this hlHostControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable and alHostTable shall be deleted.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "nlHostTable": {
            "type": "object",
            "description": "nlHostTable",
            "properties": {
              "hlHostControlIndex": {
                "type": "string",
                "description": "hlHostControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlHostTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "nlHostAddress": {
                "type": "string",
                "description": "The network address for this nlHostEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlHostInPkts": {
                "type": "string",
                "description": "The number of packets without errors transmitted to\n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlHostOutPkts": {
                "type": "string",
                "description": "The number of packets without errors transmitted by\n            \n            \n            \n            \n            \n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlHostInOctets": {
                "type": "string",
                "description": "The number of octets transmitted to this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlHostOutOctets": {
                "type": "string",
                "description": "The number of octets transmitted by this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlHostOutMacNonUnicastPkts": {
                "type": "string",
                "description": "The number of packets without errors transmitted by this\n            address that were directed to any MAC broadcast addresses\n            or to any MAC multicast addresses since this host was\n            added to the nlHostTable. Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlHostCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "hlMatrixControlTable": {
            "type": "object",
            "description": "hlMatrixControlTable",
            "properties": {
              "hlMatrixControlIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry in the\n            hlMatrixControlTable.  Each such entry defines\n            a function that discovers conversations on a particular\n            interface and places statistics about them in the\n            nlMatrixSDTable and the nlMatrixDSTable, and optionally the\n            alMatrixSDTable and alMatrixDSTable, on behalf of this\n            hlMatrixControlEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlMatrixControlDataSource": {
                "type": "string",
                "description": "The source of the data for the associated matrix tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            \n            \n            \n            \n            \n            identified interface.\n            \n            This object may not be modified if the associated\n            hlMatrixControlStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:DataSource"
              },
              "hlMatrixControlNlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlMatrixTables are inactive because no\n            protocols are enabled in the protocol directory, this value\n            should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlNlInserts": {
                "type": "integer",
                "description": "The number of times an nlMatrix entry has been\n            inserted into the nlMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the nlMatrixSDTable and nlMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            \n            \n            \n            \n            Note that the sum of then nlMatrixSDTable and nlMatrixDSTable\n            sizes can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlNlDeletes": {
                "type": "integer",
                "description": "The number of times an nlMatrix entry has been\n            deleted from the nlMatrix tables (for any reason).  If an\n            entry is deleted, then inserted, and then deleted, this\n            counter will be incremented by 2.  The deletion of a\n            conversation from both the nlMatrixSDTable and nlMatrixDSTable\n            shall be counted as two deletions (even though every deletion\n            from one table must be accompanied by a deletion from the\n            other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlNlMaxDesiredEntries": {
                "type": "integer",
                "description": "The maximum number of entries that are desired in the\n            nlMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlMatrixControlAlDroppedFrames": {
                "type": "integer",
                "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the alMatrixTables are not implemented or are\n            inactive because no protocols are enabled in the protocol\n            directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlAlInserts": {
                "type": "integer",
                "description": "The number of times an alMatrix entry has been\n            inserted into the alMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            \n            \n            \n            \n            \n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlAlDeletes": {
                "type": "integer",
                "description": "The number of times an alMatrix entry has been\n            deleted from the alMatrix tables.  If an entry is deleted,\n            then inserted, and then deleted, this counter will be\n            incremented by 2.  The deletion of a conversation from both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two deletions (even though every deletion from one table must\n            be accompanied by a deletion from the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "hlMatrixControlAlMaxDesiredEntries": {
                "type": "integer",
                "description": "The maximum number of entries that are desired in the\n            alMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "hlMatrixControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "hlMatrixControlStatus": {
                "type": "string",
                "description": "The status of this hlMatrixControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixSDTable,\n            nlMatrixDSTable, alMatrixSDTable, and the alMatrixDSTable\n            shall be deleted by the agent.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "nlMatrixSDTable": {
            "type": "object",
            "description": "nlMatrixSDTable",
            "properties": {
              "hlMatrixControlIndex": {
                "type": "string",
                "description": "hlMatrixControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlMatrixSDTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "nlMatrixSDSourceAddress": {
                "type": "string",
                "description": "The network source address for this nlMatrixSDEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixSDDestAddress": {
                "type": "string",
                "description": "The network destination address for this\n            nlMatrixSDEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixSDPkts": {
                "type": "string",
                "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixSDTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlMatrixSDOctets": {
                "type": "string",
                "description": "The number of octets transmitted from the source address to\n            the destination address since this entry was added to the\n            nlMatrixSDTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlMatrixSDCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "nlMatrixDSTable": {
            "type": "object",
            "description": "nlMatrixDSTable",
            "properties": {
              "hlMatrixControlIndex": {
                "type": "string",
                "description": "hlMatrixControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlMatrixDSTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "nlMatrixDSSourceAddress": {
                "type": "string",
                "description": "The network source address for this nlMatrixDSEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixDSDestAddress": {
                "type": "string",
                "description": "The network destination address for this\n            nlMatrixDSEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixDSPkts": {
                "type": "string",
                "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixDSTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlMatrixDSOctets": {
                "type": "string",
                "description": "The number of octets transmitted from the source address\n            to the destination address since this entry was added to the\n            nlMatrixDSTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "nlMatrixDSCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "nlMatrixTopNControlTable": {
            "type": "object",
            "description": "A set of parameters that control the creation of a\n        report of the top N matrix entries according to\n        a selected metric.",
            "properties": {
              "nlMatrixTopNControlIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry\n            in the nlMatrixTopNControlTable.  Each such\n            entry defines one top N report prepared for\n            one interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlMatrixIndex": {
                "type": "integer",
                "description": "The nlMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The nlMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlRateBase": {
                "type": "string",
                "description": "The variable for each nlMatrix[SD/DS] entry that the\n            nlMatrixTopNEntries are sorted by.\n            \n            \n            \n            \n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1)."
              },
              "nlMatrixTopNControlTimeRemaining": {
                "type": "integer",
                "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            nlMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of nlMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the nlMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the nlMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlGeneratedReports": {
                "type": "integer",
                "description": "The number of reports that have been generated by this entry.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "nlMatrixTopNControlDuration": {
                "type": "integer",
                "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated nlMatrixTopNControlTimeRemaining object is\n            set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the nlMatrixTopNControlTimeRemaining is set.\n            This value shall be zero if no reports have been\n            requested for this nlMatrixTopNControlEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlRequestedSize": {
                "type": "integer",
                "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set nlMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlGrantedSize": {
                "type": "integer",
                "description": "The maximum number of matrix entries in this report.\n            \n            When the associated nlMatrixTopNControlRequestedSize object is\n            created or modified, the probe should set this\n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            nlMatrixTopNControlRequestedSize object.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNPktRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            \n            \n            \n            \n            \n            matrix entries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNOctetRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of nlMatrixTopNPktRate or nlMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNControlStartTime": {
                "type": "string",
                "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated nlMatrixTopNControlTimeRemaining object was\n            modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
                "x-yang-type": "yang:timestamp"
              },
              "nlMatrixTopNControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "nlMatrixTopNControlStatus": {
                "type": "string",
                "description": "The status of this nlMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            \n            \n            \n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixTopNTable shall be deleted\n            by the agent.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "nlMatrixTopNTable": {
            "type": "object",
            "description": "A set of statistics for those network layer matrix entries\n        that have counted the highest number of octets or packets.",
            "properties": {
              "nlMatrixTopNControlIndex": {
                "type": "string",
                "description": "nlMatrixTopNControlIndex",
                "x-yang-type": "leafref"
              },
              "nlMatrixTopNIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry in\n            the nlMatrixTopNTable among those in the same report.\n            \n            \n            \n            \n            \n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, increasing values of nlMatrixTopNIndex shall\n            be assigned to entries with decreasing values of\n            nlMatrixTopNPktRate until index N is assigned or there are no\n            more nlMatrixTopNEntries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, increasing values of nlMatrixTopNIndex\n            shall be assigned to entries with decreasing values of\n            nlMatrixTopNOctetRate until index N is assigned or there are\n            no more nlMatrixTopNEntries.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNProtocolDirLocalIndex": {
                "type": "integer",
                "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "nlMatrixTopNSourceAddress": {
                "type": "string",
                "description": "The network layer address of the source host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixTopNDestAddress": {
                "type": "string",
                "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the nlMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "nlMatrixTopNPktRate": {
                "type": "integer",
                "description": "The number of packets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object.\n            If the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNPkts, this variable will be used to sort this\n            report.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "nlMatrixTopNReversePktRate": {
                "type": "integer",
                "description": "The number of packets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object (note\n            that the corresponding nlMatrixSDPkts object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNPkts, the sort of topN entries is based\n            entirely on nlMatrixTopNPktRate, and not on the value of this\n            object.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "nlMatrixTopNOctetRate": {
                "type": "integer",
                "description": "The number of octets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDOctets object.  If\n            the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNOctets, this variable will be used to sort this\n            report.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "nlMatrixTopNReverseOctetRate": {
                "type": "integer",
                "description": "The number of octets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixDSOctets object (note\n            that the corresponding nlMatrixSDOctets object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNOctets, the sort of topN entries is based\n            entirely on nlMatrixTopNOctetRate, and not on the value of\n            this object.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "alHostTable": {
            "type": "object",
            "description": "alHostTable",
            "properties": {
              "hlHostControlIndex": {
                "type": "string",
                "description": "hlHostControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlHostAddress": {
                "type": "string",
                "description": "nlHostAddress",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex_2": {
                "type": "string",
                "description": "protocolDirLocalIndex_2",
                "x-yang-type": "leafref"
              },
              "alHostTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "alHostInPkts": {
                "type": "string",
                "description": "The number of packets of this protocol type without errors\n            transmitted to this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alHostOutPkts": {
                "type": "string",
                "description": "The number of packets of this protocol type without errors\n            transmitted by this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alHostInOctets": {
                "type": "string",
                "description": "The number of octets transmitted to this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            \n            \n            \n            \n            \n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alHostOutOctets": {
                "type": "string",
                "description": "The number of octets transmitted by this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alHostCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "alMatrixSDTable": {
            "type": "object",
            "description": "alMatrixSDTable",
            "properties": {
              "hlMatrixControlIndex": {
                "type": "string",
                "description": "hlMatrixControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlMatrixSDSourceAddress": {
                "type": "string",
                "description": "nlMatrixSDSourceAddress",
                "x-yang-type": "leafref"
              },
              "nlMatrixSDDestAddress": {
                "type": "string",
                "description": "nlMatrixSDDestAddress",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex_2": {
                "type": "string",
                "description": "protocolDirLocalIndex_2",
                "x-yang-type": "leafref"
              },
              "alMatrixSDTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "alMatrixSDPkts": {
                "type": "string",
                "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alMatrixSDOctets": {
                "type": "string",
                "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alMatrixSDCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "alMatrixDSTable": {
            "type": "object",
            "description": "alMatrixDSTable",
            "properties": {
              "hlMatrixControlIndex": {
                "type": "string",
                "description": "hlMatrixControlIndex",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex": {
                "type": "string",
                "description": "protocolDirLocalIndex",
                "x-yang-type": "leafref"
              },
              "nlMatrixDSDestAddress": {
                "type": "string",
                "description": "nlMatrixDSDestAddress",
                "x-yang-type": "leafref"
              },
              "nlMatrixDSSourceAddress": {
                "type": "string",
                "description": "nlMatrixDSSourceAddress",
                "x-yang-type": "leafref"
              },
              "protocolDirLocalIndex_2": {
                "type": "string",
                "description": "protocolDirLocalIndex_2",
                "x-yang-type": "leafref"
              },
              "alMatrixDSTimeMark": {
                "type": "string",
                "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
                "x-yang-type": "RMON2-MIB:TimeFilter"
              },
              "alMatrixDSPkts": {
                "type": "string",
                "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alMatrixDSOctets": {
                "type": "string",
                "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
                "x-yang-type": "yang:zero-based-counter32"
              },
              "alMatrixDSCreateTime": {
                "type": "string",
                "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
                "x-yang-type": "RMON2-MIB:LastCreateTime"
              }
            }
          },
          "alMatrixTopNControlTable": {
            "type": "object",
            "description": "A set of parameters that control the creation of a\n        report of the top N matrix entries according to\n        a selected metric.",
            "properties": {
              "alMatrixTopNControlIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry\n            in the alMatrixTopNControlTable.  Each such\n            entry defines one top N report prepared for\n            one interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlMatrixIndex": {
                "type": "integer",
                "description": "The alMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The alMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlRateBase": {
                "type": "string",
                "description": "The variable for each alMatrix[SD/DS] entry that the\n            \n            \n            \n            \n            \n            alMatrixTopNEntries are sorted by, as well as the\n            selector of the view of the matrix table that will be\n            used.\n            \n            The values alMatrixTopNTerminalsPkts and\n            alMatrixTopNTerminalsOctets cause collection only from\n            protocols that have no child protocols that are counted.  The\n            values alMatrixTopNAllPkts and alMatrixTopNAllOctets cause\n            collection from all alMatrix entries.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1)."
              },
              "alMatrixTopNControlTimeRemaining": {
                "type": "integer",
                "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            alMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of alMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the alMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the alMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlGeneratedReports": {
                "type": "integer",
                "description": "The number of reports that have been generated by this entry.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "alMatrixTopNControlDuration": {
                "type": "integer",
                "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated alMatrixTopNControlTimeRemaining object\n            is set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the alMatrixTopNControlTimeRemaining is set.\n            \n            This value shall be zero if no reports have been\n            requested for this alMatrixTopNControlEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlRequestedSize": {
                "type": "integer",
                "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set alMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlGrantedSize": {
                "type": "integer",
                "description": "The maximum number of matrix entries in this report.\n            \n            When the associated alMatrixTopNControlRequestedSize object\n            is created or modified, the probe should set this\n            \n            \n            \n            \n            \n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            alMatrixTopNControlRequestedSize object.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNPktRate shall be placed in this table in\n            decreasing order of this rate until there is no more room or\n            until there are no more matrix entries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNOctetRate shall be placed in this table\n            in decreasing order of this rate until there is no more room\n            or until there are no more matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of alMatrixTopNPktRate or alMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNControlStartTime": {
                "type": "string",
                "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated alMatrixTopNControlTimeRemaining object\n            was modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
                "x-yang-type": "yang:timestamp"
              },
              "alMatrixTopNControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "alMatrixTopNControlStatus": {
                "type": "string",
                "description": "The status of this alMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the alMatrixTopNTable shall be\n            deleted by the agent.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "alMatrixTopNTable": {
            "type": "object",
            "description": "A set of statistics for those application layer matrix\n        entries that have counted the highest number of octets or\n        packets.",
            "properties": {
              "alMatrixTopNControlIndex": {
                "type": "string",
                "description": "alMatrixTopNControlIndex",
                "x-yang-type": "leafref"
              },
              "alMatrixTopNIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry in\n            the alMatrixTopNTable among those in the same report.\n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, increasing\n            values of alMatrixTopNIndex shall be assigned to entries with\n            decreasing values of alMatrixTopNPktRate until index N is\n            assigned or there are no more alMatrixTopNEntries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets,\n            increasing values of alMatrixTopNIndex shall be assigned to\n            entries with decreasing values of alMatrixTopNOctetRate until\n            index N is assigned or there are no more alMatrixTopNEntries.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNProtocolDirLocalIndex": {
                "type": "integer",
                "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNSourceAddress": {
                "type": "string",
                "description": "The network layer address of the source host in this\n            conversation.\n            This is represented as an octet string with\n            specific semantics and length as identified\n            \n            \n            \n            \n            \n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "alMatrixTopNDestAddress": {
                "type": "string",
                "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
                "format": "binary"
              },
              "alMatrixTopNAppProtocolDirLocalIndex": {
                "type": "integer",
                "description": "The type of the protocol counted by this matrix entry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "alMatrixTopNPktRate": {
                "type": "integer",
                "description": "The number of packets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDPkts\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, this\n            variable will be used to sort this report.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "alMatrixTopNReversePktRate": {
                "type": "integer",
                "description": "The number of packets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSPkts object  (note that the corresponding\n            alMatrixSDPkts object selected is the one whose source address\n            is equal to alMatrixTopNDestAddress and whose destination\n            address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            to alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, the sort\n            of topN entries is based entirely on alMatrixTopNPktRate, and\n            not on the value of this object.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "alMatrixTopNOctetRate": {
                "type": "integer",
                "description": "The number of octets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDOctets\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, this\n            variable will be used to sort this report.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "alMatrixTopNReverseOctetRate": {
                "type": "integer",
                "description": "The number of octets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSOctets object  (note that the corresponding\n            alMatrixSDOctets object selected is the one whose source\n            address is equal to alMatrixTopNDestAddress and whose\n            destination address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            \n            \n            \n            \n            \n            to alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, the\n            sort of topN entries is based entirely on\n            alMatrixTopNOctetRate, and not on the value of this object.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "usrHistoryControlTable": {
            "type": "object",
            "description": "A list of data-collection configuration entries.",
            "properties": {
              "usrHistoryControlIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies an entry in the\n            usrHistoryControlTable.  Each such entry defines a\n            set of samples at a particular interval for a specified\n            set of MIB instances available from the managed system.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryControlObjects": {
                "type": "integer",
                "description": "The number of MIB objects to be collected\n            in the portion of usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            This object may not be modified if the associated instance\n            of usrHistoryControlStatus is equal to active(1).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryControlBucketsRequested": {
                "type": "integer",
                "description": "The requested number of discrete time intervals\n            over which data is to be saved in the part of the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            \n            When this object is created or modified, the probe\n            should set usrHistoryControlBucketsGranted as closely to\n            this object as is possible for the particular probe\n            implementation and available resources.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryControlBucketsGranted": {
                "type": "integer",
                "description": "The number of discrete sampling intervals\n            over which data shall be saved in the part of\n            the usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            When the associated usrHistoryControlBucketsRequested\n            \n            \n            \n            \n            \n            object is created or modified, the probe should set\n            this object as closely to the requested value as is\n            possible for the particular  probe implementation and\n            available resources.  The probe must not lower this\n            value except as a result of a modification to the associated\n            usrHistoryControlBucketsRequested object.\n            \n            The associated usrHistoryControlBucketsRequested object\n            should be set before or at the same time as this object\n            to allow the probe to accurately estimate the resources\n            required for this usrHistoryControlEntry.\n            \n            There will be times when the actual number of buckets\n            associated with this entry is less than the value of\n            this object.  In this case, at the end of each sampling\n            interval, a new bucket will be added to the usrHistoryTable.\n            \n            When the number of buckets reaches the value of this object\n            and a new bucket is to be added to the usrHistoryTable,\n            the oldest bucket associated with this usrHistoryControlEntry\n            shall be deleted by the agent so that the new bucket can be\n            added.\n            \n            When the value of this object changes to a value less than\n            the current value, entries are deleted from the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            Enough of the oldest of these entries shall be deleted by the\n            agent so that their number remains less than or equal to the\n            new value of this object.\n            \n            When the value of this object changes to a value greater\n            than the current value, the number of associated usrHistory\n            entries may be allowed to grow.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryControlInterval": {
                "type": "integer",
                "description": "The interval in seconds over which the data is\n            sampled for each bucket in the part of the usrHistory\n            table associated with this usrHistoryControlEntry.\n            \n            Because the counters in a bucket may overflow at their\n            maximum value with no indication, a prudent manager will\n            take into account the possibility of overflow in any of\n            \n            \n            \n            \n            \n            the associated counters. It is important to consider the\n            minimum time in which any counter could overflow on a\n            particular media type and set the usrHistoryControlInterval\n            object to a value less than this interval.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryControlOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "usrHistoryControlStatus": {
                "type": "string",
                "description": "The status of this variable history control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the usrHistoryTable shall be deleted.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "usrHistoryObjectTable": {
            "type": "object",
            "description": "A list of data-collection configuration entries.",
            "properties": {
              "usrHistoryControlIndex": {
                "type": "string",
                "description": "usrHistoryControlIndex",
                "x-yang-type": "leafref"
              },
              "usrHistoryObjectIndex": {
                "type": "integer",
                "description": "An index used to uniquely identify an entry in the\n            usrHistoryObject table.  Each such entry defines a\n            MIB instance to be collected periodically.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryObjectVariable": {
                "type": "string",
                "description": "The object identifier of the particular variable to be\n            sampled.\n            \n            Only variables that resolve to an ASN.1 primitive type of\n            Integer32 (Integer32, Counter, Gauge, or TimeTicks) may be\n            sampled.\n            \n            Because SNMP access control is articulated entirely in terms\n            of the contents of MIB views, no access control mechanism\n            exists that can restrict the value of this object to identify\n            only those objects that exist in a particular MIB view.\n            Because there is thus no acceptable means of restricting the\n            read access that could be obtained through the user history\n            \n            \n            \n            \n            \n            mechanism, the probe must only grant write access to this\n            object in those views that have read access to all objects on\n            the probe.\n            \n            During a set operation, if the supplied variable name is not\n            available in the selected MIB view, a badValue error must be\n            returned.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
                "x-yang-type": "yang:object-identifier-128"
              },
              "usrHistoryObjectSampleType": {
                "type": "string",
                "description": "The method of sampling the selected variable for storage in\n            the usrHistoryTable.\n            \n            If the value of this object is absoluteValue(1), the value of\n            the selected variable will be copied directly into the history\n            bucket.\n            \n            If the value of this object is deltaValue(2), the value of the\n            selected variable at the last sample will be subtracted from\n            the current value, and the difference will be stored in the\n            history bucket. If the associated usrHistoryObjectVariable\n            instance could not be obtained at the previous sample\n            interval, then a delta sample is not possible, and the value\n            of the associated usrHistoryValStatus object for this interval\n            will be valueNotAvailable(1).\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1)."
              }
            }
          },
          "usrHistoryTable": {
            "type": "object",
            "description": "A list of user defined history entries.",
            "properties": {
              "usrHistoryControlIndex": {
                "type": "string",
                "description": "usrHistoryControlIndex",
                "x-yang-type": "leafref"
              },
              "usrHistoryObjectIndex": {
                "type": "string",
                "description": "usrHistoryObjectIndex",
                "x-yang-type": "leafref"
              },
              "usrHistorySampleIndex": {
                "type": "integer",
                "description": "An index that uniquely identifies the particular sample this\n            entry represents among all samples associated with the same\n            usrHistoryControlEntry. This index starts at 1 and increases\n            by one as each new sample is taken.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "usrHistoryIntervalStart": {
                "type": "string",
                "description": "The value of sysUpTime at the start of the interval over\n            which this sample was measured.  If the probe keeps track of\n            the time of day, it should start the first sample of the\n            history at a time such that when the next hour of the day\n            begins, a sample is started at that instant.\n            \n            Note that following this rule may require the probe to delay\n            collecting the first sample of the history, as each sample\n            must be of the same interval. Also note that the sample which\n            is currently being collected is not accessible in this table\n            until the end of its interval.",
                "x-yang-type": "yang:timestamp"
              },
              "usrHistoryIntervalEnd": {
                "type": "string",
                "description": "The value of sysUpTime at the end of the interval over which\n            this sample was measured.",
                "x-yang-type": "yang:timestamp"
              },
              "usrHistoryAbsValue": {
                "type": "integer",
                "description": "The absolute value (i.e. unsigned value) of the\n            user-specified statistic during the last sampling period. The\n            value during the current sampling period is not made available\n            until the period is completed.\n            \n            To obtain the true value for this sampling interval, the\n            associated instance of usrHistoryValStatus must be checked,\n            and usrHistoryAbsValue adjusted as necessary.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then this object will have a value of zero and the\n            associated instance of usrHistoryValStatus will be set to\n            'valueNotAvailable(1)'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "usrHistoryValStatus": {
                "type": "string",
                "description": "This object indicates the validity and sign of the data in\n            the associated instance of usrHistoryAbsValue.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then 'valueNotAvailable(1)' will be returned.\n            \n            If the sample is valid and actual value of the sample is\n            greater than or equal to zero then 'valuePositive(2)' is\n            returned.\n            \n            If the sample is valid and the actual value of the sample is\n            less than zero, 'valueNegative(3)' will be returned. The\n            associated instance of usrHistoryAbsValue should be multiplied\n            by -1 to obtain the true sample value."
              }
            }
          },
          "serialConfigTable": {
            "type": "object",
            "description": "A table of serial interface configuration entries.  This data\n        will be stored in non-volatile memory and preserved across\n        probe resets or power loss.",
            "properties": {
              "ifIndex": {
                "type": "string",
                "description": "ifIndex",
                "x-yang-type": "leafref"
              },
              "serialMode": {
                "type": "string",
                "description": "The type of incoming connection to expect on this serial\n            interface."
              },
              "serialProtocol": {
                "type": "string",
                "description": "The type of data link encapsulation to be used on this\n            serial interface."
              },
              "serialTimeout": {
                "type": "integer",
                "description": "This timeout value is used when the Management Station has\n            initiated the conversation over the serial link. This variable\n            represents the number of seconds of inactivity allowed before\n            terminating the connection on this serial interface. Use the\n            \n            \n            \n            \n            \n            serialDialoutTimeout in the case where the probe has initiated\n            the connection for the purpose of sending a trap.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "serialModemInitString": {
                "type": "string",
                "description": "A control string which controls how a modem attached to this\n            serial interface should be initialized.  The initialization\n            is performed once during startup and again after each\n            connection is terminated if the associated serialMode has the\n            value of modem(2).\n            \n            A control string that is appropriate for a wide variety of\n            modems is: '^s^MATE0Q0V1X4 S0=1 S2=43^M'.",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialModemHangUpString": {
                "type": "string",
                "description": "A control string which specifies how to disconnect a modem\n            connection on this serial interface.  This object is only\n            meaningful if the associated serialMode has the value\n            of modem(2).\n            A control string that is appropriate for a wide variety of\n            modems is: '^d2^s+++^d2^sATH0^M^d2'.",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialModemConnectResp": {
                "type": "string",
                "description": "An ASCII string containing substrings that describe the\n            expected modem connection response code and associated bps\n            rate.  The substrings are delimited by the first character\n            in the string, for example:\n               /CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n               CONNECT 4800/4800/CONNECT 9600/9600\n            will be interpreted as:\n                response code    bps rate\n                CONNECT            300\n                CONNECT 1200      1200\n            \n            \n            \n            \n            \n                CONNECT 2400      2400\n                CONNECT 4800      4800\n                CONNECT 9600      9600\n            The agent will use the information in this string to adjust\n            the bps rate of this serial interface once a modem connection\n            is established.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n             CONNECT 4800/4800/CONNECT 9600/9600/CONNECT 14400/14400/\n            CONNECT 19200/19200/CONNECT 38400/38400/'.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "serialModemNoConnectResp": {
                "type": "string",
                "description": "An ASCII string containing response codes that may be\n            generated by a modem to report the reason why a connection\n            attempt has failed.  The response codes are delimited by\n            the first character in the string, for example:\n               /NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/\n            If one of these response codes is received via this serial\n            interface while attempting to make a modem connection,\n            the agent will issue the hang up command as specified by\n            serialModemHangUpString.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/'.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "serialDialoutTimeout": {
                "type": "integer",
                "description": "This timeout value is used when the probe initiates the\n            serial connection with the intention of contacting a\n            management station. This variable represents the number\n            of seconds of inactivity allowed before terminating the\n            connection on this serial interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "serialStatus": {
                "type": "string",
                "description": "The status of this serialConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "netConfigTable": {
            "type": "object",
            "description": "A table of netConfigEntries.",
            "properties": {
              "ifIndex": {
                "type": "string",
                "description": "ifIndex",
                "x-yang-type": "leafref"
              },
              "netConfigIPAddress": {
                "type": "string",
                "description": "The IP address of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            \n            \n            \n            \n            \n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
                "format": "inet:ipv4-address"
              },
              "netConfigSubnetMask": {
                "type": "string",
                "description": "The subnet mask of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
                "format": "inet:ipv4-address"
              },
              "netConfigStatus": {
                "type": "string",
                "description": "The status of this netConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "trapDestTable": {
            "type": "object",
            "description": "A list of trap destination entries.",
            "properties": {
              "trapDestIndex": {
                "type": "integer",
                "description": "A value that uniquely identifies this trapDestEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "trapDestCommunity": {
                "type": "string",
                "description": "A community to which this destination address belongs.\n            This entry is associated with any eventEntries in the RMON\n            \n            \n            \n            \n            \n            MIB whose value of eventCommunity is equal to the value of\n            this object.  Every time an associated event entry sends a\n            trap due to an event, that trap will be sent to each\n            address in the trapDestTable with a trapDestCommunity equal to\n            eventCommunity.\n            \n            This object may not be modified if the associated\n            trapDestStatus object is equal to active(1).",
                "format": "binary"
              },
              "trapDestProtocol": {
                "type": "string",
                "description": "The protocol with which to send this trap."
              },
              "trapDestAddress": {
                "type": "string",
                "description": "The address to send traps on behalf of this entry.\n            \n            If the associated trapDestProtocol object is equal to ip(1),\n            the encoding of this object is the same as the snmpUDPAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpUDPAddress of length 6:\n              --\n              -- octets   contents        encoding\n              --  1-4     IP-address      network-byte order\n              --  5-6     UDP-port        network-byte order\n            \n            If the associated trapDestProtocol object is equal to ipx(2),\n            the encoding of this object is the same as the snmpIPXAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpIPXAddress of length 12:\n              --\n              -- octets   contents            encoding\n              --  1-4     network-number      network-byte order\n              --  5-10    physical-address    network-byte order\n              -- 11-12    socket-number       network-byte order\n            \n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            trapDestStatus object is equal to active(1).",
                "format": "binary"
              },
              "trapDestOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "trapDestStatus": {
                "type": "string",
                "description": "The status of this trap destination entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "serialConnectionTable": {
            "type": "object",
            "description": "A list of serialConnectionEntries.",
            "properties": {
              "serialConnectIndex": {
                "type": "integer",
                "description": "A value that uniquely identifies this serialConnection\n            entry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "serialConnectDestIpAddress": {
                "type": "string",
                "description": "The IP Address that can be reached at the other end of this\n            serial connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
                "format": "inet:ipv4-address"
              },
              "serialConnectType": {
                "type": "string",
                "description": "The type of outgoing connection to make.  If this object\n            has the value direct(1), then a direct serial connection\n            is assumed.  If this object has the value modem(2),\n            then serialConnectDialString will be used to make a modem\n            connection.  If this object has the value switch(3),\n            \n            \n            \n            \n            \n            then serialConnectSwitchConnectSeq will be used to establish\n            the connection over a serial data switch, and\n            serialConnectSwitchDisconnectSeq will be used to terminate\n            the connection.  If this object has the value\n            modem-switch(4), then a modem connection will be made first\n            followed by the switch connection.\n            \n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1)."
              },
              "serialConnectDialString": {
                "type": "string",
                "description": "A control string which specifies how to dial the phone\n            number in order to establish a modem connection.  The\n            string should include dialing prefix and suffix.  For\n            example: ``^s^MATD9,888-1234^M'' will instruct the Probe\n            to send a carriage return followed by the dialing prefix\n            ``ATD'', the phone number ``9,888-1234'', and a carriage\n            return as the dialing suffix.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialConnectSwitchConnectSeq": {
                "type": "string",
                "description": "A control string which specifies how to establish a\n            data switch connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialConnectSwitchDisconnectSeq": {
                "type": "string",
                "description": "A control string which specifies how to terminate a\n            data switch connection.\n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            serialConnectStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialConnectSwitchResetSeq": {
                "type": "string",
                "description": "A control string which specifies how to reset a data\n            switch in the event of a timeout.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
                "x-yang-type": "RMON2-MIB:ControlString"
              },
              "serialConnectOwner": {
                "type": "string",
                "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
                "x-yang-type": "rmon-mib:OwnerString"
              },
              "serialConnectStatus": {
                "type": "string",
                "description": "The status of this serialConnectionEntry.\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to modem(2) or modem-switch(4)\n            and the serialConnectDialString is a zero-length string or\n            cannot be correctly parsed as a ConnectString, the set\n            request will be rejected with badValue(3).\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to switch(3) or modem-switch(4)\n            and the serialConnectSwitchConnectSeq,\n            the serialConnectSwitchDisconnectSeq, or\n            the serialConnectSwitchResetSeq are zero-length strings\n            or cannot be correctly parsed as ConnectStrings, the set\n            request will be rejected with badValue(3).\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          }
        }
      },
      "RMON2-MIB_protocolDirEntry": {
        "type": "array",
        "description": "A conceptual row in the protocolDirTable.\n          \n          An example of the indexing of this entry is\n          protocolDirLocalIndex.8.0.0.0.1.0.0.8.0.2.0.0, which is the\n          encoding of a length of 8, followed by 8 subids encoding the\n          protocolDirID of 1.2048, followed by a length of 2 and the\n          2 subids encoding zero-valued parameters.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "protocolDirID": {
              "type": "string",
              "description": "A unique identifier for a particular protocol.  Standard\n            identifiers will be defined in a manner such that they\n            can often be used as specifications for new protocols - i.e.\n            a tree-structured assignment mechanism that matches the\n            protocol encapsulation `tree' and which has algorithmic\n            assignment mechanisms for certain subtrees. See RFC XXX for\n            more details.\n            \n            Despite the algorithmic mechanism, the probe will only place\n            entries in here for those protocols it chooses to collect.  In\n            other words, it need not populate this table with all of the\n            possible ethernet protocol types, nor need it create them on\n            the fly when it sees them.  Whether or not it does these\n            things is a matter of product definition (cost/benefit,\n            usability), and is up to the designer of the product.\n            \n            If an entry is written to this table with a protocolDirID that\n            the agent doesn't understand, either directly or\n            algorithmically, the SET request will be rejected with an\n            inconsistentName or badValue (for SNMPv1) error.",
              "format": "binary"
            },
            "protocolDirParameters": {
              "type": "string",
              "description": "A set of parameters for the associated protocolDirID.\n            See the associated RMON2 Protocol Identifiers document\n            for a description of the possible parameters. There\n            will be one octet in this string for each sub-identifier in\n            the protocolDirID, and the parameters will appear here in the\n            same order as the associated sub-identifiers appear in the\n            protocolDirID.\n            \n            Every node in the protocolDirID tree has a different, optional\n            set of parameters defined (that is, the definition of\n            parameters for a node is optional).  The proper parameter\n            value for each node is included in this string.  Note that the\n            inclusion of a parameter value in this string for each node is\n            not optional - what is optional is that a node may have no\n            parameters defined, in which case the parameter field for that\n            node will be zero.",
              "format": "binary"
            },
            "protocolDirLocalIndex": {
              "type": "integer",
              "description": "The locally arbitrary, but unique identifier associated\n            with this protocolDir entry.\n            \n            The value for each supported protocol must remain constant at\n            least from one re-initialization of the entity's network\n            management system to the next re-initialization, except that\n            if a protocol is deleted and re-created, it must be re-created\n            with a new value that has not been used since the last\n            re-initialization.\n            \n            The specific value is meaningful only within a given SNMP\n            entity. A protocolDirLocalIndex must not be re-used until the\n            next agent-restart in the event the protocol directory entry\n            is deleted.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "protocolDirDescr": {
              "type": "string",
              "description": "A textual description of the protocol encapsulation.\n            A probe may choose to describe only a subset of the\n            entire encapsulation (e.g. only the highest layer).\n            \n            This object is intended for human consumption only.\n            \n            This object may not be modified if the associated\n            protocolDirStatus object is equal to active(1).",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "protocolDirType": {
              "type": "string",
              "description": "This object describes 2 attributes of this protocol\n            directory entry.\n            \n            The presence or absence of the `extensible' bit describes\n            whether or not this protocol directory entry can be extended\n            \n            \n            \n            \n            \n            by the user by creating protocol directory entries which are\n            children of this protocol.\n            \n            An example of an entry that will often allow extensibility is\n            `ip.udp'.  The probe may automatically populate some children\n            of this node such as `ip.udp.snmp' and `ip.udp.dns'.\n            A probe administrator or user may also populate additional\n            children via remote SNMP requests that create entries in this\n            table.  When a child node is added for a protocol for which the\n            probe has no built in support, extending a parent node (for\n            which the probe does have built in support),\n            that child node is not extendible.  This is termed `limited\n            extensibility'.\n            \n            When a child node is added through this extensibility\n            mechanism, the values of protocolDirLocalIndex and\n            protocolDirType shall be assigned by the agent.\n            \n            The other objects in the entry will be assigned by the\n            manager who is creating the new entry.\n            \n            This object also describes whether or not this agent can\n            recognize addresses for this protocol, should it be a network\n            level protocol.  That is, while a probe may be able to\n            recognize packets of a particular network layer protocol and\n            count them, it takes additional logic to be able to recognize\n            the addresses in this protocol and to populate network layer\n            or application layer tables with the addresses in this\n            protocol.  If this bit is set, the agent will recognize\n            network layer addresses for this protoocl and populate the\n            network and application layer host and matrix tables with\n            these protocols.\n            \n            Note that when an entry is created, the agent will supply\n            values for the bits that match the capabilities of the agent\n            with respect to this protocol.  Note that since row creations\n            usually exercise the limited extensibility feature, these\n            bits will usually be set to zero.",
              "format": "binary"
            },
            "protocolDirAddressMapConfig": {
              "type": "string",
              "description": "This object describes and configures the probe's support for\n            address mapping for this protocol.  When the probe creates\n            entries in this table for all protocols that it understands,\n            it will set the entry to notSupported(1) if it doesn't have\n            the capability to perform address mapping for the protocol or\n            if this protocol is not a network-layer protocol.  When\n            an entry is created in this table by a management operation as\n            part of the limited extensibility feature, the probe must set\n            this value to notSupported(1), because limited extensibility\n            of the protocolDirTable does not extend to interpreting\n            addresses of the extended protocols.\n            \n            If the value of this object is notSupported(1), the probe\n            will not perform address mapping for this protocol and\n            shall not allow this object to be changed to any other value.\n            If the value of this object is supportedOn(3), the probe\n            supports address mapping for this protocol and is configured\n            to perform address mapping for this protocol for all\n            addressMappingControlEntries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports address mapping for this protocol but is configured\n            to not perform address mapping for this protocol for any\n            addressMappingControlEntries and all interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the addressMappingTable."
            },
            "protocolDirHostConfig": {
              "type": "string",
              "description": "This object describes and configures the probe's support for\n            the network layer and application layer host tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlHostTable for this protocol or if the alHostTable is\n            implemented but doesn't have the capability to track this\n            protocol.  Note that if the alHostTable is implemented, the\n            probe may only support a protocol if it is supported in both\n            the nlHostTable and the alHostTable.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate the nlHostTable and alHostTable\n            with addresses it discovers for this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track the nlHostTable or alHostTable for this\n            protocol and shall not allow this object to be changed to any\n            other value. If the value of this object is supportedOn(3),\n            the probe supports tracking of the nlHostTable and alHostTable\n            for this protocol and is configured to track both tables\n            for this protocol for all control entries and all interfaces.\n            If the value of this object is supportedOff(2), the probe\n            supports tracking of the nlHostTable and alHostTable for this\n            protocol but is configured to not track these tables\n            for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlHostTable and alHostTable.\n            \n            Note that since each alHostEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
            },
            "protocolDirMatrixConfig": {
              "type": "string",
              "description": "This object describes and configures the probe's support for\n            the network layer and application layer matrix tables for this\n            protocol.  When the probe creates entries in this table for\n            all protocols that it understands, it will set the entry to\n            notSupported(1) if it doesn't have the capability to track the\n            nlMatrixTables for this protocol or if the alMatrixTables are\n            implemented but don't have the capability to track this\n            protocol.  Note that if the alMatrix tables are implemented,\n            the probe may only support a protocol if it is supported in\n            the the both of the nlMatrixTables and both of the\n            alMatrixTables.\n            \n            \n            \n            \n            \n            If the associated protocolDirType object has the\n            addressRecognitionCapable bit set, then this is a network\n            layer protocol for which the probe recognizes addresses, and\n            thus the probe will populate both of the nlMatrixTables and\n            both of the alMatrixTables with addresses it discovers for\n            this protocol.\n            \n            If the value of this object is notSupported(1), the probe\n            will not track either of the nlMatrixTables or the\n            alMatrixTables for this protocol and shall not allow this\n            object to be changed to any other value. If the value of this\n            object is supportedOn(3), the probe supports tracking of both\n            of the nlMatrixTables and (if implemented) both of the\n            alMatrixTables for this protocol and is configured to track\n            these tables for this protocol for all control entries and all\n            interfaces. If the value of this object is supportedOff(2),\n            the probe supports tracking of both of the nlMatrixTables and\n            (if implemented) both of the alMatrixTables for this protocol\n            but is configured to not track these tables for this\n            protocol for any control entries or interfaces.\n            Whenever this value changes from supportedOn(3) to\n            supportedOff(2), the probe shall delete all related entries in\n            the nlMatrixTables and the alMatrixTables.\n            \n            Note that since each alMatrixEntry references 2 protocol\n            directory entries, one for the network address and one for the\n            type of the highest protocol recognized, that an entry will\n            only be created in that table if this value is supportedOn(3)\n            for both protocols."
            },
            "protocolDirOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "protocolDirStatus": {
              "type": "string",
              "description": "The status of this protocol directory entry.\n            \n            An entry may not exist in the active state unless all\n            \n            \n            \n            \n            \n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable, nlMatrixSDTable, nlMatrixDSTable,\n            alHostTable, alMatrixSDTable, and alMatrixDSTable shall be\n            deleted.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_protocolDistControlEntry": {
        "type": "array",
        "description": "A conceptual row in the protocolDistControlTable.\n          \n          An example of the indexing of this entry is\n          \n          \n          \n          \n          \n          protocolDistControlDroppedFrames.7",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "protocolDistControlIndex": {
              "type": "integer",
              "description": "A unique index for this protocolDistControlEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "protocolDistControlDataSource": {
              "type": "string",
              "description": "The source of data for the this protocol distribution.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            protocolDistControlStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:DataSource"
            },
            "protocolDistControlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            \n            \n            \n            \n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "protocolDistControlCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this control entry was last\n            activated. This can be used by the management station to\n            ensure that the table has not been deleted and recreated\n            between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            },
            "protocolDistControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "protocolDistControlStatus": {
              "type": "string",
              "description": "The status of this row.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the protocolDistStatsTable shall be deleted.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_protocolDistStatsEntry": {
        "type": "array",
        "description": "protocolDistStatsEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "protocolDistControlIndex": {
              "type": "string",
              "description": "protocolDistControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "protocolDistStatsPkts": {
              "type": "string",
              "description": "The number of packets without errors received of this\n            protocol type.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "protocolDistStatsOctets": {
              "type": "string",
              "description": "The number of octets in packets received of this protocol\n            type since it was added to the protocolDistStatsTable\n            (excluding framing bits but including FCS octets), except for\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            }
          }
        }
      },
      "RMON2-MIB_addressMapControlEntry": {
        "type": "array",
        "description": "A conceptual row in the addressMapControlTable.\n          \n          \n          \n          \n          \n          An example of the indexing of this entry is\n          addressMapControlDroppedFrames.1",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "addressMapControlIndex": {
              "type": "integer",
              "description": "A unique index for this entry in the addressMapControlTable.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "addressMapControlDataSource": {
              "type": "string",
              "description": "The source of data for this addressMapControlEntry.",
              "x-yang-type": "RMON2-MIB:DataSource"
            },
            "addressMapControlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "addressMapControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "addressMapControlStatus": {
              "type": "string",
              "description": "The status of this addressMap control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the addressMapTable shall be deleted.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_addressMapEntry": {
        "type": "array",
        "description": "A conceptual row in the addressMapTable.\n          The protocolDirLocalIndex in the index identifies the network\n          layer protocol of the addressMapNetworkAddress.\n          \n          \n          \n          \n          \n          An example of the indexing of this entry is\n          addressMapSource.783495.18.4.128.2.6.6.11.1.3.6.1.2.1.2.2.1.1.1",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "addressMapTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "addressMapNetworkAddress": {
              "type": "string",
              "description": "The network address for this relation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the\n            index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "addressMapSource": {
              "type": "string",
              "description": "The interface or port on which the associated network\n            address was most recently seen.\n            \n            \n            \n            \n            \n            If this address mapping was discovered on an interface, this\n            object shall identify the instance of the ifIndex\n            object, defined in [3,5], for the desired interface.\n            For example, if an entry were to receive data from\n            interface #1, this object would be set to ifIndex.1.\n            \n            If this address mapping was discovered on a port, this\n            object shall identify the instance of the rptrGroupPortIndex\n            object, defined in [RFC1516], for the desired port.\n            For example, if an entry were to receive data from\n            group #1, port #1, this object would be set to\n            rptrGroupPortIndex.1.1.\n            \n            Note that while the dataSource associated with this entry\n            may only point to index objects, this object may at times\n            point to repeater port objects. This situation occurs when\n            the dataSource points to an interface which is a locally\n            attached repeater and the agent has additional information\n            about the source port of traffic seen on that repeater.",
              "x-yang-type": "yang:object-identifier-128"
            },
            "addressMapPhysicalAddress": {
              "type": "string",
              "description": "The last source physical address on which the associated\n            network address was seen.  If the protocol of the associated\n            network address was encapsulated inside of a network-level or\n            higher protocol, this will be the address of the next-lower\n            protocol with the addressRecognitionCapable bit enabled and\n            will be formatted as specified for that protocol.",
              "format": "binary"
            },
            "addressMapLastChange": {
              "type": "string",
              "description": "The value of sysUpTime at the time this entry was last\n            created or the values of the physical address changed.\n            \n            This can be used to help detect duplicate address problems, in\n            which case this object will be updated frequently.",
              "x-yang-type": "yang:timestamp"
            }
          }
        }
      },
      "RMON2-MIB_hlHostControlEntry": {
        "type": "array",
        "description": "A conceptual row in the hlHostControlTable.\n          \n          An example of the indexing of this entry is\n          hlHostControlNlDroppedFrames.1",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlHostControlIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry in the\n            hlHostControlTable.  Each such entry defines\n            a function that discovers hosts on a particular\n            interface and places statistics about them in the\n            nlHostTable, and optionally in the alHostTable, on\n            behalf of this hlHostControlEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlHostControlDataSource": {
              "type": "string",
              "description": "The source of data for the associated host tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            identified interface.\n            \n            This object may not be modified if the associated\n            hlHostControlStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:DataSource"
            },
            "hlHostControlNlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            \n            \n            \n            \n            \n            nlHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlHostTable is inactive because no protocols\n            are enabled in the protocol directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlNlInserts": {
              "type": "integer",
              "description": "The number of times an nlHost entry has been\n            inserted into the nlHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlNlDeletes": {
              "type": "integer",
              "description": "The number of times an nlHost entry has been\n            deleted from the nlHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            \n            \n            \n            \n            \n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlNlDeletes from hlHostControlNlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlNlMaxDesiredEntries": {
              "type": "integer",
              "description": "The maximum number of entries that are desired in the\n            nlHostTable on behalf of this control entry. The probe will\n            not create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlHostControlAlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for the associated\n            alHost entries for whatever reason.  Most often, this event\n            occurs when the probe is out of some resources and decides to\n            shed load from this collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            \n            \n            \n            \n            \n            Note that if the alHostTable is not implemented or is inactive\n            because no protocols are enabled in the protocol directory,\n            this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlAlInserts": {
              "type": "integer",
              "description": "The number of times an alHost entry has been\n            inserted into the alHost table.  If an entry is inserted, then\n            deleted, and then inserted, this counter will be incremented\n            by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlAlDeletes": {
              "type": "integer",
              "description": "The number of times an alHost entry has been\n            deleted from the alHost table (for any reason).  If an entry\n            is deleted, then inserted, and then deleted, this counter will\n            be incremented by 2.\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlHostControlAlDeletes from hlHostControlAlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlHostControlAlMaxDesiredEntries": {
              "type": "integer",
              "description": "The maximum number of entries that are desired in the alHost\n            table on behalf of this control entry. The probe will not\n            create more than this number of associated entries in the\n            table, but may choose to create fewer entries in this table\n            for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            hlHostControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlHostControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "hlHostControlStatus": {
              "type": "string",
              "description": "The status of this hlHostControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the nlHostTable and alHostTable shall be deleted.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_nlHostEntry": {
        "type": "array",
        "description": "nlHostEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlHostControlIndex": {
              "type": "string",
              "description": "hlHostControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlHostTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "nlHostAddress": {
              "type": "string",
              "description": "The network address for this nlHostEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlHostInPkts": {
              "type": "string",
              "description": "The number of packets without errors transmitted to\n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlHostOutPkts": {
              "type": "string",
              "description": "The number of packets without errors transmitted by\n            \n            \n            \n            \n            \n            this address since it was added to the nlHostTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlHostInOctets": {
              "type": "string",
              "description": "The number of octets transmitted to this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlHostOutOctets": {
              "type": "string",
              "description": "The number of octets transmitted by this address\n            since it was added to the nlHostTable (excluding\n            framing bits but including FCS octets), excluding\n            those octets in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlHostOutMacNonUnicastPkts": {
              "type": "string",
              "description": "The number of packets without errors transmitted by this\n            address that were directed to any MAC broadcast addresses\n            or to any MAC multicast addresses since this host was\n            added to the nlHostTable. Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlHostCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_hlMatrixControlEntry": {
        "type": "array",
        "description": "A conceptual row in the hlMatrixControlTable.\n          \n          An example of indexing of this entry is\n          hlMatrixControlNlDroppedFrames.1",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlMatrixControlIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry in the\n            hlMatrixControlTable.  Each such entry defines\n            a function that discovers conversations on a particular\n            interface and places statistics about them in the\n            nlMatrixSDTable and the nlMatrixDSTable, and optionally the\n            alMatrixSDTable and alMatrixDSTable, on behalf of this\n            hlMatrixControlEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlMatrixControlDataSource": {
              "type": "string",
              "description": "The source of the data for the associated matrix tables.\n            \n            The statistics in this group reflect all packets\n            on the local network segment attached to the\n            \n            \n            \n            \n            \n            identified interface.\n            \n            This object may not be modified if the associated\n            hlMatrixControlStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:DataSource"
            },
            "hlMatrixControlNlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the nlMatrixTables are inactive because no\n            protocols are enabled in the protocol directory, this value\n            should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlNlInserts": {
              "type": "integer",
              "description": "The number of times an nlMatrix entry has been\n            inserted into the nlMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the nlMatrixSDTable and nlMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            \n            \n            \n            \n            Note that the sum of then nlMatrixSDTable and nlMatrixDSTable\n            sizes can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlNlDeletes": {
              "type": "integer",
              "description": "The number of times an nlMatrix entry has been\n            deleted from the nlMatrix tables (for any reason).  If an\n            entry is deleted, then inserted, and then deleted, this\n            counter will be incremented by 2.  The deletion of a\n            conversation from both the nlMatrixSDTable and nlMatrixDSTable\n            shall be counted as two deletions (even though every deletion\n            from one table must be accompanied by a deletion from the\n            other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlNlDeletes from hlMatrixControlNlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlNlMaxDesiredEntries": {
              "type": "integer",
              "description": "The maximum number of entries that are desired in the\n            nlMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlMatrixControlAlDroppedFrames": {
              "type": "integer",
              "description": "The total number of frames which were received by the probe\n            and therefore not accounted for in the *StatsDropEvents, but\n            for which the probe chose not to count for this entry for\n            whatever reason.  Most often, this event occurs when the probe\n            is out of some resources and decides to shed load from this\n            collection.\n            \n            This count does not include packets that were not counted\n            because they had MAC-layer errors.\n            \n            Note that if the alMatrixTables are not implemented or are\n            inactive because no protocols are enabled in the protocol\n            directory, this value should be 0.\n            \n            Note that, unlike the dropEvents counter, this number is the\n            exact number of frames dropped.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlAlInserts": {
              "type": "integer",
              "description": "The number of times an alMatrix entry has been\n            inserted into the alMatrix tables.  If an entry is inserted,\n            then deleted, and then inserted, this counter will be\n            incremented by 2.  The addition of a conversation into both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two insertions (even though every addition into one table must\n            be accompanied by an insertion into the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            \n            \n            \n            \n            \n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlAlDeletes": {
              "type": "integer",
              "description": "The number of times an alMatrix entry has been\n            deleted from the alMatrix tables.  If an entry is deleted,\n            then inserted, and then deleted, this counter will be\n            incremented by 2.  The deletion of a conversation from both\n            the alMatrixSDTable and alMatrixDSTable shall be counted as\n            two deletions (even though every deletion from one table must\n            be accompanied by a deletion from the other).\n            \n            To allow for efficient implementation strategies, agents may\n            delay updating this object for short periods of time.  For\n            example, an implementation strategy may allow internal\n            data structures to differ from those visible via SNMP for\n            short periods of time.  This counter may reflect the internal\n            data structures for those short periods of time.\n            \n            Note that the table size can be determined by subtracting\n            hlMatrixControlAlDeletes from hlMatrixControlAlInserts.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "hlMatrixControlAlMaxDesiredEntries": {
              "type": "integer",
              "description": "The maximum number of entries that are desired in the\n            alMatrix tables on behalf of this control entry. The probe\n            will not create more than this number of associated entries in\n            the table, but may choose to create fewer entries in this\n            table for any reason including the lack of resources.\n            \n            If this object is set to a value less than the current number\n            of entries, enough entries are chosen in an\n            implementation-dependent manner and deleted so that the number\n            of entries in the table equals the value of this object.\n            \n            If this value is set to -1, the probe may create any number\n            of entries in this table.  If the associated\n            \n            \n            \n            \n            \n            hlMatrixControlStatus object is equal to `active', this\n            object may not be modified.\n            \n            This object may be used to control how resources are allocated\n            on the probe for the various RMON functions.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "hlMatrixControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "hlMatrixControlStatus": {
              "type": "string",
              "description": "The status of this hlMatrixControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixSDTable,\n            nlMatrixDSTable, alMatrixSDTable, and the alMatrixDSTable\n            shall be deleted by the agent.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_nlMatrixSDEntry": {
        "type": "array",
        "description": "nlMatrixSDEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlMatrixControlIndex": {
              "type": "string",
              "description": "hlMatrixControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlMatrixSDTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "nlMatrixSDSourceAddress": {
              "type": "string",
              "description": "The network source address for this nlMatrixSDEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixSDDestAddress": {
              "type": "string",
              "description": "The network destination address for this\n            nlMatrixSDEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixSDPkts": {
              "type": "string",
              "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixSDTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlMatrixSDOctets": {
              "type": "string",
              "description": "The number of octets transmitted from the source address to\n            the destination address since this entry was added to the\n            nlMatrixSDTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlMatrixSDCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_nlMatrixDSEntry": {
        "type": "array",
        "description": "nlMatrixDSEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlMatrixControlIndex": {
              "type": "string",
              "description": "hlMatrixControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlMatrixDSTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "nlMatrixDSSourceAddress": {
              "type": "string",
              "description": "The network source address for this nlMatrixDSEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixDSDestAddress": {
              "type": "string",
              "description": "The network destination address for this\n            nlMatrixDSEntry.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the protocolDirLocalIndex component of the index.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixDSPkts": {
              "type": "string",
              "description": "The number of packets without errors transmitted from the\n            source address to the destination address since this entry was\n            added to the nlMatrixDSTable.  Note that this is the number of\n            link-layer packets, so if a single network-layer packet is\n            fragmented into several link-layer frames, this counter is\n            incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlMatrixDSOctets": {
              "type": "string",
              "description": "The number of octets transmitted from the source address\n            to the destination address since this entry was added to the\n            nlMatrixDSTable (excluding framing bits but\n            including FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "nlMatrixDSCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_nlMatrixTopNControlEntry": {
        "type": "array",
        "description": "A conceptual row in the nlMatrixTopNControlTable.\n          \n          An example of the indexing of this table is\n          nlMatrixTopNControlDuration.3",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "nlMatrixTopNControlIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry\n            in the nlMatrixTopNControlTable.  Each such\n            entry defines one top N report prepared for\n            one interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlMatrixIndex": {
              "type": "integer",
              "description": "The nlMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The nlMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlRateBase": {
              "type": "string",
              "description": "The variable for each nlMatrix[SD/DS] entry that the\n            nlMatrixTopNEntries are sorted by.\n            \n            \n            \n            \n            \n            This object may not be modified if the associated\n            nlMatrixTopNControlStatus object is equal to active(1)."
            },
            "nlMatrixTopNControlTimeRemaining": {
              "type": "integer",
              "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            nlMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of nlMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the nlMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the nlMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlGeneratedReports": {
              "type": "integer",
              "description": "The number of reports that have been generated by this entry.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "nlMatrixTopNControlDuration": {
              "type": "integer",
              "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated nlMatrixTopNControlTimeRemaining object is\n            set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the nlMatrixTopNControlTimeRemaining is set.\n            This value shall be zero if no reports have been\n            requested for this nlMatrixTopNControlEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlRequestedSize": {
              "type": "integer",
              "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set nlMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlGrantedSize": {
              "type": "integer",
              "description": "The maximum number of matrix entries in this report.\n            \n            When the associated nlMatrixTopNControlRequestedSize object is\n            created or modified, the probe should set this\n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            nlMatrixTopNControlRequestedSize object.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNPktRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            \n            \n            \n            \n            \n            matrix entries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, when the next topN report is generated,\n            matrix entries with the highest value of nlMatrixTopNOctetRate\n            shall be placed in this table in decreasing order of this rate\n            until there is no more room or until there are no more\n            matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of nlMatrixTopNPktRate or nlMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNControlStartTime": {
              "type": "string",
              "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated nlMatrixTopNControlTimeRemaining object was\n            modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
              "x-yang-type": "yang:timestamp"
            },
            "nlMatrixTopNControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "nlMatrixTopNControlStatus": {
              "type": "string",
              "description": "The status of this nlMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            \n            \n            \n            \n            If this object is not equal to active(1), all\n            associated entries in the nlMatrixTopNTable shall be deleted\n            by the agent.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_nlMatrixTopNEntry": {
        "type": "array",
        "description": "A conceptual row in the nlMatrixTopNTable.\n          \n          The nlMatrixTopNControlIndex value in the index identifies the\n          nlMatrixTopNControlEntry on whose behalf this entry was\n          created.\n          \n          An example of the indexing of this table is\n          nlMatrixTopNPktRate.3.10",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "nlMatrixTopNControlIndex": {
              "type": "string",
              "description": "nlMatrixTopNControlIndex",
              "x-yang-type": "leafref"
            },
            "nlMatrixTopNIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry in\n            the nlMatrixTopNTable among those in the same report.\n            \n            \n            \n            \n            \n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNPkts, increasing values of nlMatrixTopNIndex shall\n            be assigned to entries with decreasing values of\n            nlMatrixTopNPktRate until index N is assigned or there are no\n            more nlMatrixTopNEntries.\n            \n            If the value of nlMatrixTopNControlRateBase is equal to\n            nlMatrixTopNOctets, increasing values of nlMatrixTopNIndex\n            shall be assigned to entries with decreasing values of\n            nlMatrixTopNOctetRate until index N is assigned or there are\n            no more nlMatrixTopNEntries.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNProtocolDirLocalIndex": {
              "type": "integer",
              "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "nlMatrixTopNSourceAddress": {
              "type": "string",
              "description": "The network layer address of the source host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the protocolDirLocalIndex indicates an\n            encapsulation of ip, this object is encoded as a length\n            octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixTopNDestAddress": {
              "type": "string",
              "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated nlMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the nlMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "nlMatrixTopNPktRate": {
              "type": "integer",
              "description": "The number of packets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object.\n            If the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNPkts, this variable will be used to sort this\n            report.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "nlMatrixTopNReversePktRate": {
              "type": "integer",
              "description": "The number of packets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDPkts object (note\n            that the corresponding nlMatrixSDPkts object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNPkts, the sort of topN entries is based\n            entirely on nlMatrixTopNPktRate, and not on the value of this\n            object.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "nlMatrixTopNOctetRate": {
              "type": "integer",
              "description": "The number of octets seen from the source host\n            to the destination host during this sampling interval, counted\n            using the rules for counting the nlMatrixSDOctets object.  If\n            the value of nlMatrixTopNControlRateBase is\n            nlMatrixTopNOctets, this variable will be used to sort this\n            report.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "nlMatrixTopNReverseOctetRate": {
              "type": "integer",
              "description": "The number of octets seen from the destination host to the\n            source host during this sampling interval, counted\n            using the rules for counting the nlMatrixDSOctets object (note\n            that the corresponding nlMatrixSDOctets object selected is the\n            one whose source address is equal to nlMatrixTopNDestAddress\n            and whose destination address is equal to\n            nlMatrixTopNSourceAddress.)\n            \n            Note that if the value of nlMatrixTopNControlRateBase is equal\n            to nlMatrixTopNOctets, the sort of topN entries is based\n            entirely on nlMatrixTopNOctetRate, and not on the value of\n            this object.",
              "minimum": 0,
              "maximum": 4294967295
            }
          }
        }
      },
      "RMON2-MIB_alHostEntry": {
        "type": "array",
        "description": "alHostEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlHostControlIndex": {
              "type": "string",
              "description": "hlHostControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlHostAddress": {
              "type": "string",
              "description": "nlHostAddress",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex_2": {
              "type": "string",
              "description": "protocolDirLocalIndex_2",
              "x-yang-type": "leafref"
            },
            "alHostTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "alHostInPkts": {
              "type": "string",
              "description": "The number of packets of this protocol type without errors\n            transmitted to this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alHostOutPkts": {
              "type": "string",
              "description": "The number of packets of this protocol type without errors\n            transmitted by this address since it was added to the\n            alHostTable.  Note that this is the number of link-layer\n            packets, so if a single network-layer packet is fragmented\n            into several link-layer frames, this counter is incremented\n            several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alHostInOctets": {
              "type": "string",
              "description": "The number of octets transmitted to this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            \n            \n            \n            \n            \n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alHostOutOctets": {
              "type": "string",
              "description": "The number of octets transmitted by this address\n            of this protocol type since it was added to the\n            alHostTable (excluding framing bits but including\n            FCS octets), excluding those octets in packets that\n            contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alHostCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_alMatrixSDEntry": {
        "type": "array",
        "description": "alMatrixSDEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlMatrixControlIndex": {
              "type": "string",
              "description": "hlMatrixControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlMatrixSDSourceAddress": {
              "type": "string",
              "description": "nlMatrixSDSourceAddress",
              "x-yang-type": "leafref"
            },
            "nlMatrixSDDestAddress": {
              "type": "string",
              "description": "nlMatrixSDDestAddress",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex_2": {
              "type": "string",
              "description": "protocolDirLocalIndex_2",
              "x-yang-type": "leafref"
            },
            "alMatrixSDTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "alMatrixSDPkts": {
              "type": "string",
              "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alMatrixSDOctets": {
              "type": "string",
              "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixSDTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alMatrixSDCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_alMatrixDSEntry": {
        "type": "array",
        "description": "alMatrixDSEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "hlMatrixControlIndex": {
              "type": "string",
              "description": "hlMatrixControlIndex",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex": {
              "type": "string",
              "description": "protocolDirLocalIndex",
              "x-yang-type": "leafref"
            },
            "nlMatrixDSDestAddress": {
              "type": "string",
              "description": "nlMatrixDSDestAddress",
              "x-yang-type": "leafref"
            },
            "nlMatrixDSSourceAddress": {
              "type": "string",
              "description": "nlMatrixDSSourceAddress",
              "x-yang-type": "leafref"
            },
            "protocolDirLocalIndex_2": {
              "type": "string",
              "description": "protocolDirLocalIndex_2",
              "x-yang-type": "leafref"
            },
            "alMatrixDSTimeMark": {
              "type": "string",
              "description": "A TimeFilter for this entry.  See the TimeFilter textual\n            convention to see how this works.",
              "x-yang-type": "RMON2-MIB:TimeFilter"
            },
            "alMatrixDSPkts": {
              "type": "string",
              "description": "The number of packets of this protocol type without errors\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable.  Note that\n            this is the number of link-layer packets, so if a single\n            network-layer packet is fragmented into several link-layer\n            frames, this counter is incremented several times.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alMatrixDSOctets": {
              "type": "string",
              "description": "The number of octets in packets of this protocol type\n            transmitted from the source address to the destination address\n            since this entry was added to the alMatrixDSTable (excluding\n            framing bits but including FCS octets), excluding those octets\n            in packets that contained errors.\n            \n            Note this doesn't count just those octets in the particular\n            protocol frames, but includes the entire packet that contained\n            the protocol.",
              "x-yang-type": "yang:zero-based-counter32"
            },
            "alMatrixDSCreateTime": {
              "type": "string",
              "description": "The value of sysUpTime when this entry was last activated.\n            This can be used by the management station to ensure that the\n            entry has not been deleted and recreated between polls.",
              "x-yang-type": "RMON2-MIB:LastCreateTime"
            }
          }
        }
      },
      "RMON2-MIB_alMatrixTopNControlEntry": {
        "type": "array",
        "description": "A conceptual row in the alMatrixTopNControlTable.\n          \n          An example of the indexing of this table is\n          alMatrixTopNControlDuration.3",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "alMatrixTopNControlIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry\n            in the alMatrixTopNControlTable.  Each such\n            entry defines one top N report prepared for\n            one interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlMatrixIndex": {
              "type": "integer",
              "description": "The alMatrix[SD/DS] table for which a top N report will be\n            prepared on behalf of this entry.  The alMatrix[SD/DS] table\n            is identified by the value of the hlMatrixControlIndex\n            for that table - that value is used here to identify the\n            particular table.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlRateBase": {
              "type": "string",
              "description": "The variable for each alMatrix[SD/DS] entry that the\n            \n            \n            \n            \n            \n            alMatrixTopNEntries are sorted by, as well as the\n            selector of the view of the matrix table that will be\n            used.\n            \n            The values alMatrixTopNTerminalsPkts and\n            alMatrixTopNTerminalsOctets cause collection only from\n            protocols that have no child protocols that are counted.  The\n            values alMatrixTopNAllPkts and alMatrixTopNAllOctets cause\n            collection from all alMatrix entries.\n            \n            This object may not be modified if the associated\n            alMatrixTopNControlStatus object is equal to active(1)."
            },
            "alMatrixTopNControlTimeRemaining": {
              "type": "integer",
              "description": "The number of seconds left in the report currently\n            being collected.  When this object is modified by\n            the management station, a new collection is started,\n            possibly aborting a currently running report.  The\n            new value is used as the requested duration of this\n            report, and is immediately loaded into the associated\n            alMatrixTopNControlDuration object.\n            When the report finishes, the probe will automatically\n            start another collection with the same initial value\n            of alMatrixTopNControlTimeRemaining.  Thus the management\n            station may simply read the resulting reports repeatedly,\n            checking the startTime and duration each time to ensure that a\n            report was not missed or that the report parameters were not\n            changed.\n            \n            While the value of this object is non-zero, it decrements\n            by one per second until it reaches zero.  At the time\n            that this object decrements to zero, the report is made\n            accessible in the alMatrixTopNTable, overwriting any report\n            that may be there.\n            \n            When this object is modified by the management station, any\n            associated entries in the alMatrixTopNTable shall be deleted.\n            \n            (Note that this is a different algorithm than the one used in\n            the hostTopNTable).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlGeneratedReports": {
              "type": "integer",
              "description": "The number of reports that have been generated by this entry.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "alMatrixTopNControlDuration": {
              "type": "integer",
              "description": "The number of seconds that this report has collected\n            during the last sampling interval.\n            \n            When the associated alMatrixTopNControlTimeRemaining object\n            is set, this object shall be set by the probe to the\n            same value and shall not be modified until the next\n            time the alMatrixTopNControlTimeRemaining is set.\n            \n            This value shall be zero if no reports have been\n            requested for this alMatrixTopNControlEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlRequestedSize": {
              "type": "integer",
              "description": "The maximum number of matrix entries requested for this report.\n            \n            When this object is created or modified, the probe\n            should set alMatrixTopNControlGrantedSize as closely to this\n            object as is possible for the particular probe\n            implementation and available resources.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlGrantedSize": {
              "type": "integer",
              "description": "The maximum number of matrix entries in this report.\n            \n            When the associated alMatrixTopNControlRequestedSize object\n            is created or modified, the probe should set this\n            \n            \n            \n            \n            \n            object as closely to the requested value as is\n            possible for the particular implementation and\n            available resources. The probe must not lower this\n            value except as a result of a set to the associated\n            alMatrixTopNControlRequestedSize object.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNPktRate shall be placed in this table in\n            decreasing order of this rate until there is no more room or\n            until there are no more matrix entries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, when the\n            next topN report is generated, matrix entries with the highest\n            value of alMatrixTopNOctetRate shall be placed in this table\n            in decreasing order of this rate until there is no more room\n            or until there are no more matrix entries.\n            \n            It is an implementation-specific matter how entries with the\n            same value of alMatrixTopNPktRate or alMatrixTopNOctetRate are\n            sorted.  It is also an implementation-specific matter as to\n            whether or not zero-valued entries are available.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNControlStartTime": {
              "type": "string",
              "description": "The value of sysUpTime when this top N report was\n            last started.  In other words, this is the time that\n            the associated alMatrixTopNControlTimeRemaining object\n            was modified to start the requested report or the time\n            the report was last automatically (re)started.\n            \n            This object may be used by the management station to\n            determine if a report was missed or not.",
              "x-yang-type": "yang:timestamp"
            },
            "alMatrixTopNControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "alMatrixTopNControlStatus": {
              "type": "string",
              "description": "The status of this alMatrixTopNControlEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all\n            associated entries in the alMatrixTopNTable shall be\n            deleted by the agent.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_alMatrixTopNEntry": {
        "type": "array",
        "description": "A conceptual row in the alMatrixTopNTable.\n          \n          The alMatrixTopNControlIndex value in the index identifies\n          the alMatrixTopNControlEntry on whose behalf this entry was\n          created.\n          \n          An example of the indexing of this table is\n          alMatrixTopNPktRate.3.10",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "alMatrixTopNControlIndex": {
              "type": "string",
              "description": "alMatrixTopNControlIndex",
              "x-yang-type": "leafref"
            },
            "alMatrixTopNIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry in\n            the alMatrixTopNTable among those in the same report.\n            This index is between 1 and N, where N is the\n            number of entries in this report.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, increasing\n            values of alMatrixTopNIndex shall be assigned to entries with\n            decreasing values of alMatrixTopNPktRate until index N is\n            assigned or there are no more alMatrixTopNEntries.\n            \n            If the value of alMatrixTopNControlRateBase is equal to\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets,\n            increasing values of alMatrixTopNIndex shall be assigned to\n            entries with decreasing values of alMatrixTopNOctetRate until\n            index N is assigned or there are no more alMatrixTopNEntries.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNProtocolDirLocalIndex": {
              "type": "integer",
              "description": "The protocolDirLocalIndex of the network layer protocol of\n            this entry's network address.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNSourceAddress": {
              "type": "string",
              "description": "The network layer address of the source host in this\n            conversation.\n            This is represented as an octet string with\n            specific semantics and length as identified\n            \n            \n            \n            \n            \n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "alMatrixTopNDestAddress": {
              "type": "string",
              "description": "The network layer address of the destination host in this\n            conversation.\n            \n            This is represented as an octet string with\n            specific semantics and length as identified\n            by the associated alMatrixTopNProtocolDirLocalIndex.\n            \n            For example, if the alMatrixTopNProtocolDirLocalIndex\n            indicates an encapsulation of ip, this object is encoded as a\n            length octet of 4, followed by the 4 octets of the ip address,\n            in network byte order.",
              "format": "binary"
            },
            "alMatrixTopNAppProtocolDirLocalIndex": {
              "type": "integer",
              "description": "The type of the protocol counted by this matrix entry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "alMatrixTopNPktRate": {
              "type": "integer",
              "description": "The number of packets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDPkts\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, this\n            variable will be used to sort this report.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "alMatrixTopNReversePktRate": {
              "type": "integer",
              "description": "The number of packets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSPkts object  (note that the corresponding\n            alMatrixSDPkts object selected is the one whose source address\n            is equal to alMatrixTopNDestAddress and whose destination\n            address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            to alMatrixTopNTerminalsPkts or alMatrixTopNAllPkts, the sort\n            of topN entries is based entirely on alMatrixTopNPktRate, and\n            not on the value of this object.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "alMatrixTopNOctetRate": {
              "type": "integer",
              "description": "The number of octets seen of this protocol from the source\n            host to the destination host during this sampling interval,\n            counted using the rules for counting the alMatrixSDOctets\n            object.\n            \n            If the value of alMatrixTopNControlRateBase is\n            alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, this\n            variable will be used to sort this report.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "alMatrixTopNReverseOctetRate": {
              "type": "integer",
              "description": "The number of octets seen of this protocol from the\n            destination host to the source host during this sampling\n            interval, counted using the rules for counting the\n            alMatrixDSOctets object  (note that the corresponding\n            alMatrixSDOctets object selected is the one whose source\n            address is equal to alMatrixTopNDestAddress and whose\n            destination address is equal to alMatrixTopNSourceAddress.)\n            \n            Note that if the value of alMatrixTopNControlRateBase is equal\n            \n            \n            \n            \n            \n            to alMatrixTopNTerminalsOctets or alMatrixTopNAllOctets, the\n            sort of topN entries is based entirely on\n            alMatrixTopNOctetRate, and not on the value of this object.",
              "minimum": 0,
              "maximum": 4294967295
            }
          }
        }
      },
      "RMON2-MIB_usrHistoryControlEntry": {
        "type": "array",
        "description": "A list of parameters that set up a group of user-defined\n          MIB objects to be sampled periodically (called a\n          bucket-group).\n          \n          For example, an instance of usrHistoryControlInterval\n          might be named usrHistoryControlInterval.1",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "usrHistoryControlIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies an entry in the\n            usrHistoryControlTable.  Each such entry defines a\n            set of samples at a particular interval for a specified\n            set of MIB instances available from the managed system.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryControlObjects": {
              "type": "integer",
              "description": "The number of MIB objects to be collected\n            in the portion of usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            This object may not be modified if the associated instance\n            of usrHistoryControlStatus is equal to active(1).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryControlBucketsRequested": {
              "type": "integer",
              "description": "The requested number of discrete time intervals\n            over which data is to be saved in the part of the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            \n            When this object is created or modified, the probe\n            should set usrHistoryControlBucketsGranted as closely to\n            this object as is possible for the particular probe\n            implementation and available resources.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryControlBucketsGranted": {
              "type": "integer",
              "description": "The number of discrete sampling intervals\n            over which data shall be saved in the part of\n            the usrHistoryTable associated with this\n            usrHistoryControlEntry.\n            \n            When the associated usrHistoryControlBucketsRequested\n            \n            \n            \n            \n            \n            object is created or modified, the probe should set\n            this object as closely to the requested value as is\n            possible for the particular  probe implementation and\n            available resources.  The probe must not lower this\n            value except as a result of a modification to the associated\n            usrHistoryControlBucketsRequested object.\n            \n            The associated usrHistoryControlBucketsRequested object\n            should be set before or at the same time as this object\n            to allow the probe to accurately estimate the resources\n            required for this usrHistoryControlEntry.\n            \n            There will be times when the actual number of buckets\n            associated with this entry is less than the value of\n            this object.  In this case, at the end of each sampling\n            interval, a new bucket will be added to the usrHistoryTable.\n            \n            When the number of buckets reaches the value of this object\n            and a new bucket is to be added to the usrHistoryTable,\n            the oldest bucket associated with this usrHistoryControlEntry\n            shall be deleted by the agent so that the new bucket can be\n            added.\n            \n            When the value of this object changes to a value less than\n            the current value, entries are deleted from the\n            usrHistoryTable associated with this usrHistoryControlEntry.\n            Enough of the oldest of these entries shall be deleted by the\n            agent so that their number remains less than or equal to the\n            new value of this object.\n            \n            When the value of this object changes to a value greater\n            than the current value, the number of associated usrHistory\n            entries may be allowed to grow.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryControlInterval": {
              "type": "integer",
              "description": "The interval in seconds over which the data is\n            sampled for each bucket in the part of the usrHistory\n            table associated with this usrHistoryControlEntry.\n            \n            Because the counters in a bucket may overflow at their\n            maximum value with no indication, a prudent manager will\n            take into account the possibility of overflow in any of\n            \n            \n            \n            \n            \n            the associated counters. It is important to consider the\n            minimum time in which any counter could overflow on a\n            particular media type and set the usrHistoryControlInterval\n            object to a value less than this interval.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryControlOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "usrHistoryControlStatus": {
              "type": "string",
              "description": "The status of this variable history control entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.\n            \n            If this object is not equal to active(1), all associated\n            entries in the usrHistoryTable shall be deleted.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_usrHistoryObjectEntry": {
        "type": "array",
        "description": "usrHistoryObjectEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "usrHistoryControlIndex": {
              "type": "string",
              "description": "usrHistoryControlIndex",
              "x-yang-type": "leafref"
            },
            "usrHistoryObjectIndex": {
              "type": "integer",
              "description": "An index used to uniquely identify an entry in the\n            usrHistoryObject table.  Each such entry defines a\n            MIB instance to be collected periodically.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryObjectVariable": {
              "type": "string",
              "description": "The object identifier of the particular variable to be\n            sampled.\n            \n            Only variables that resolve to an ASN.1 primitive type of\n            Integer32 (Integer32, Counter, Gauge, or TimeTicks) may be\n            sampled.\n            \n            Because SNMP access control is articulated entirely in terms\n            of the contents of MIB views, no access control mechanism\n            exists that can restrict the value of this object to identify\n            only those objects that exist in a particular MIB view.\n            Because there is thus no acceptable means of restricting the\n            read access that could be obtained through the user history\n            \n            \n            \n            \n            \n            mechanism, the probe must only grant write access to this\n            object in those views that have read access to all objects on\n            the probe.\n            \n            During a set operation, if the supplied variable name is not\n            available in the selected MIB view, a badValue error must be\n            returned.\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1).",
              "x-yang-type": "yang:object-identifier-128"
            },
            "usrHistoryObjectSampleType": {
              "type": "string",
              "description": "The method of sampling the selected variable for storage in\n            the usrHistoryTable.\n            \n            If the value of this object is absoluteValue(1), the value of\n            the selected variable will be copied directly into the history\n            bucket.\n            \n            If the value of this object is deltaValue(2), the value of the\n            selected variable at the last sample will be subtracted from\n            the current value, and the difference will be stored in the\n            history bucket. If the associated usrHistoryObjectVariable\n            instance could not be obtained at the previous sample\n            interval, then a delta sample is not possible, and the value\n            of the associated usrHistoryValStatus object for this interval\n            will be valueNotAvailable(1).\n            \n            This object may not be modified if the associated\n            usrHistoryControlStatus object is equal to active(1)."
            }
          }
        }
      },
      "RMON2-MIB_usrHistoryEntry": {
        "type": "array",
        "description": "usrHistoryEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "usrHistoryControlIndex": {
              "type": "string",
              "description": "usrHistoryControlIndex",
              "x-yang-type": "leafref"
            },
            "usrHistoryObjectIndex": {
              "type": "string",
              "description": "usrHistoryObjectIndex",
              "x-yang-type": "leafref"
            },
            "usrHistorySampleIndex": {
              "type": "integer",
              "description": "An index that uniquely identifies the particular sample this\n            entry represents among all samples associated with the same\n            usrHistoryControlEntry. This index starts at 1 and increases\n            by one as each new sample is taken.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "usrHistoryIntervalStart": {
              "type": "string",
              "description": "The value of sysUpTime at the start of the interval over\n            which this sample was measured.  If the probe keeps track of\n            the time of day, it should start the first sample of the\n            history at a time such that when the next hour of the day\n            begins, a sample is started at that instant.\n            \n            Note that following this rule may require the probe to delay\n            collecting the first sample of the history, as each sample\n            must be of the same interval. Also note that the sample which\n            is currently being collected is not accessible in this table\n            until the end of its interval.",
              "x-yang-type": "yang:timestamp"
            },
            "usrHistoryIntervalEnd": {
              "type": "string",
              "description": "The value of sysUpTime at the end of the interval over which\n            this sample was measured.",
              "x-yang-type": "yang:timestamp"
            },
            "usrHistoryAbsValue": {
              "type": "integer",
              "description": "The absolute value (i.e. unsigned value) of the\n            user-specified statistic during the last sampling period. The\n            value during the current sampling period is not made available\n            until the period is completed.\n            \n            To obtain the true value for this sampling interval, the\n            associated instance of usrHistoryValStatus must be checked,\n            and usrHistoryAbsValue adjusted as necessary.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then this object will have a value of zero and the\n            associated instance of usrHistoryValStatus will be set to\n            'valueNotAvailable(1)'.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "usrHistoryValStatus": {
              "type": "string",
              "description": "This object indicates the validity and sign of the data in\n            the associated instance of usrHistoryAbsValue.\n            \n            If the MIB instance could not be accessed during the sampling\n            interval, then 'valueNotAvailable(1)' will be returned.\n            \n            If the sample is valid and actual value of the sample is\n            greater than or equal to zero then 'valuePositive(2)' is\n            returned.\n            \n            If the sample is valid and the actual value of the sample is\n            less than zero, 'valueNegative(3)' will be returned. The\n            associated instance of usrHistoryAbsValue should be multiplied\n            by -1 to obtain the true sample value."
            }
          }
        }
      },
      "RMON2-MIB_serialConfigEntry": {
        "type": "array",
        "description": "A set of configuration parameters for a particular\n          serial interface on this device. If the device has no serial\n          interfaces, this table is empty.\n          \n          The index is composed of the ifIndex assigned to this serial\n          line interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ifIndex": {
              "type": "string",
              "description": "ifIndex",
              "x-yang-type": "leafref"
            },
            "serialMode": {
              "type": "string",
              "description": "The type of incoming connection to expect on this serial\n            interface."
            },
            "serialProtocol": {
              "type": "string",
              "description": "The type of data link encapsulation to be used on this\n            serial interface."
            },
            "serialTimeout": {
              "type": "integer",
              "description": "This timeout value is used when the Management Station has\n            initiated the conversation over the serial link. This variable\n            represents the number of seconds of inactivity allowed before\n            terminating the connection on this serial interface. Use the\n            \n            \n            \n            \n            \n            serialDialoutTimeout in the case where the probe has initiated\n            the connection for the purpose of sending a trap.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "serialModemInitString": {
              "type": "string",
              "description": "A control string which controls how a modem attached to this\n            serial interface should be initialized.  The initialization\n            is performed once during startup and again after each\n            connection is terminated if the associated serialMode has the\n            value of modem(2).\n            \n            A control string that is appropriate for a wide variety of\n            modems is: '^s^MATE0Q0V1X4 S0=1 S2=43^M'.",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialModemHangUpString": {
              "type": "string",
              "description": "A control string which specifies how to disconnect a modem\n            connection on this serial interface.  This object is only\n            meaningful if the associated serialMode has the value\n            of modem(2).\n            A control string that is appropriate for a wide variety of\n            modems is: '^d2^s+++^d2^sATH0^M^d2'.",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialModemConnectResp": {
              "type": "string",
              "description": "An ASCII string containing substrings that describe the\n            expected modem connection response code and associated bps\n            rate.  The substrings are delimited by the first character\n            in the string, for example:\n               /CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n               CONNECT 4800/4800/CONNECT 9600/9600\n            will be interpreted as:\n                response code    bps rate\n                CONNECT            300\n                CONNECT 1200      1200\n            \n            \n            \n            \n            \n                CONNECT 2400      2400\n                CONNECT 4800      4800\n                CONNECT 9600      9600\n            The agent will use the information in this string to adjust\n            the bps rate of this serial interface once a modem connection\n            is established.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/CONNECT/300/CONNECT 1200/1200/CONNECT 2400/2400/\n             CONNECT 4800/4800/CONNECT 9600/9600/CONNECT 14400/14400/\n            CONNECT 19200/19200/CONNECT 38400/38400/'.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "serialModemNoConnectResp": {
              "type": "string",
              "description": "An ASCII string containing response codes that may be\n            generated by a modem to report the reason why a connection\n            attempt has failed.  The response codes are delimited by\n            the first character in the string, for example:\n               /NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/\n            If one of these response codes is received via this serial\n            interface while attempting to make a modem connection,\n            the agent will issue the hang up command as specified by\n            serialModemHangUpString.\n            \n            A value that is appropriate for a wide variety of modems is:\n            '/NO CARRIER/BUSY/NO DIALTONE/NO ANSWER/ERROR/'.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "serialDialoutTimeout": {
              "type": "integer",
              "description": "This timeout value is used when the probe initiates the\n            serial connection with the intention of contacting a\n            management station. This variable represents the number\n            of seconds of inactivity allowed before terminating the\n            connection on this serial interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "serialStatus": {
              "type": "string",
              "description": "The status of this serialConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_netConfigEntry": {
        "type": "array",
        "description": "A set of configuration parameters for a particular\n          network interface on this device. If the device has no network\n          interface, this table is empty.\n          \n          The index is composed of the ifIndex assigned to the\n          corresponding interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ifIndex": {
              "type": "string",
              "description": "ifIndex",
              "x-yang-type": "leafref"
            },
            "netConfigIPAddress": {
              "type": "string",
              "description": "The IP address of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            \n            \n            \n            \n            \n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
              "format": "inet:ipv4-address"
            },
            "netConfigSubnetMask": {
              "type": "string",
              "description": "The subnet mask of this Net interface.  The default value\n            for this object is 0.0.0.0.  If either the netConfigIPAddress\n            or netConfigSubnetMask are 0.0.0.0, then when the device\n            boots, it may use BOOTP to try to figure out what these\n            values should be. If BOOTP fails, before the device\n            can talk on the network, this value must be configured\n            (e.g., through a terminal attached to the device). If BOOTP is\n            used, care should be taken to not send BOOTP broadcasts too\n            frequently and to eventually send very infrequently if no\n            replies are received.",
              "format": "inet:ipv4-address"
            },
            "netConfigStatus": {
              "type": "string",
              "description": "The status of this netConfigEntry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_trapDestEntry": {
        "type": "array",
        "description": "This entry includes a destination IP address to which to send\n          traps for this community.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "trapDestIndex": {
              "type": "integer",
              "description": "A value that uniquely identifies this trapDestEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "trapDestCommunity": {
              "type": "string",
              "description": "A community to which this destination address belongs.\n            This entry is associated with any eventEntries in the RMON\n            \n            \n            \n            \n            \n            MIB whose value of eventCommunity is equal to the value of\n            this object.  Every time an associated event entry sends a\n            trap due to an event, that trap will be sent to each\n            address in the trapDestTable with a trapDestCommunity equal to\n            eventCommunity.\n            \n            This object may not be modified if the associated\n            trapDestStatus object is equal to active(1).",
              "format": "binary"
            },
            "trapDestProtocol": {
              "type": "string",
              "description": "The protocol with which to send this trap."
            },
            "trapDestAddress": {
              "type": "string",
              "description": "The address to send traps on behalf of this entry.\n            \n            If the associated trapDestProtocol object is equal to ip(1),\n            the encoding of this object is the same as the snmpUDPAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpUDPAddress of length 6:\n              --\n              -- octets   contents        encoding\n              --  1-4     IP-address      network-byte order\n              --  5-6     UDP-port        network-byte order\n            \n            If the associated trapDestProtocol object is equal to ipx(2),\n            the encoding of this object is the same as the snmpIPXAddress\n            textual convention in [RFC1906]:\n              -- for a SnmpIPXAddress of length 12:\n              --\n              -- octets   contents            encoding\n              --  1-4     network-number      network-byte order\n              --  5-10    physical-address    network-byte order\n              -- 11-12    socket-number       network-byte order\n            \n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            trapDestStatus object is equal to active(1).",
              "format": "binary"
            },
            "trapDestOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "trapDestStatus": {
              "type": "string",
              "description": "The status of this trap destination entry.\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "RMON2-MIB_serialConnectionEntry": {
        "type": "array",
        "description": "Configuration for a SLIP link over a serial line.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "serialConnectIndex": {
              "type": "integer",
              "description": "A value that uniquely identifies this serialConnection\n            entry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "serialConnectDestIpAddress": {
              "type": "string",
              "description": "The IP Address that can be reached at the other end of this\n            serial connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
              "format": "inet:ipv4-address"
            },
            "serialConnectType": {
              "type": "string",
              "description": "The type of outgoing connection to make.  If this object\n            has the value direct(1), then a direct serial connection\n            is assumed.  If this object has the value modem(2),\n            then serialConnectDialString will be used to make a modem\n            connection.  If this object has the value switch(3),\n            \n            \n            \n            \n            \n            then serialConnectSwitchConnectSeq will be used to establish\n            the connection over a serial data switch, and\n            serialConnectSwitchDisconnectSeq will be used to terminate\n            the connection.  If this object has the value\n            modem-switch(4), then a modem connection will be made first\n            followed by the switch connection.\n            \n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1)."
            },
            "serialConnectDialString": {
              "type": "string",
              "description": "A control string which specifies how to dial the phone\n            number in order to establish a modem connection.  The\n            string should include dialing prefix and suffix.  For\n            example: ``^s^MATD9,888-1234^M'' will instruct the Probe\n            to send a carriage return followed by the dialing prefix\n            ``ATD'', the phone number ``9,888-1234'', and a carriage\n            return as the dialing suffix.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialConnectSwitchConnectSeq": {
              "type": "string",
              "description": "A control string which specifies how to establish a\n            data switch connection.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialConnectSwitchDisconnectSeq": {
              "type": "string",
              "description": "A control string which specifies how to terminate a\n            data switch connection.\n            This object may not be modified if the associated\n            \n            \n            \n            \n            \n            serialConnectStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialConnectSwitchResetSeq": {
              "type": "string",
              "description": "A control string which specifies how to reset a data\n            switch in the event of a timeout.\n            This object may not be modified if the associated\n            serialConnectStatus object is equal to active(1).",
              "x-yang-type": "RMON2-MIB:ControlString"
            },
            "serialConnectOwner": {
              "type": "string",
              "description": "The entity that configured this entry and is\n            therefore using the resources assigned to it.",
              "x-yang-type": "rmon-mib:OwnerString"
            },
            "serialConnectStatus": {
              "type": "string",
              "description": "The status of this serialConnectionEntry.\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to modem(2) or modem-switch(4)\n            and the serialConnectDialString is a zero-length string or\n            cannot be correctly parsed as a ConnectString, the set\n            request will be rejected with badValue(3).\n            \n            If the manager attempts to set this object to active(1) when\n            the serialConnectType is set to switch(3) or modem-switch(4)\n            and the serialConnectSwitchConnectSeq,\n            the serialConnectSwitchDisconnectSeq, or\n            the serialConnectSwitchResetSeq are zero-length strings\n            or cannot be correctly parsed as ConnectStrings, the set\n            request will be rejected with badValue(3).\n            \n            An entry may not exist in the active state unless all\n            objects in the entry have an appropriate value.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "RMON2-MIB",
      "description": "MIB operations for RMON2-MIB"
    }
  ]
}