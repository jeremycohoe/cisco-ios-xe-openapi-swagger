{
  "openapi": "3.0.0",
  "info": {
    "title": "TUNNEL-MIB MIB API",
    "version": "1.0.0",
    "description": "The MIB module for management of IP Tunnels,\n    independent of the specific encapsulation scheme in\n    use.\n    \n    Copyright (C) The Internet Society (2005).  This\n    version of this MIB module is part of RFC 4087;  see\n    the RFC itself for full legal notices.\n\n‚ö†Ô∏è **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n\n\n**üìä YANG Tree:** [View TUNNEL-MIB structure](https://jeremycohoe.github.io/cisco-ios-xe-openapi-swagger/yang-trees/TUNNEL-MIB.html)",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/TUNNEL-MIB:tunnelIfTable": {
      "get": {
        "summary": "Get tunnelIfTable data",
        "description": "Retrieve tunnelIfTable operational data from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "The (conceptual) table containing information on\n        configured tunnels.",
                  "properties": {
                    "tunnelIfEntry": {
                      "type": "array",
                      "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "ifIndex": {
                            "type": "string",
                            "description": "ifIndex",
                            "x-yang-type": "leafref"
                          },
                          "tunnelIfLocalAddress": {
                            "type": "string",
                            "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                            "format": "inet:ipv4-address"
                          },
                          "tunnelIfRemoteAddress": {
                            "type": "string",
                            "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                            "format": "inet:ipv4-address"
                          },
                          "tunnelIfEncapsMethod": {
                            "type": "string",
                            "description": "The encapsulation method used by the tunnel.",
                            "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                          },
                          "tunnelIfHopLimit": {
                            "type": "integer",
                            "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "tunnelIfSecurity": {
                            "type": "string",
                            "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                          },
                          "tunnelIfTOS": {
                            "type": "integer",
                            "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "tunnelIfFlowLabel": {
                            "type": "integer",
                            "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "tunnelIfAddressType": {
                            "type": "string",
                            "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                            "x-yang-type": "inet-address:InetAddressType"
                          },
                          "tunnelIfLocalInetAddress": {
                            "type": "string",
                            "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "tunnelIfRemoteInetAddress": {
                            "type": "string",
                            "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "tunnelIfEncapsLimit": {
                            "type": "integer",
                            "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelIfTable": {
                    "tunnelIfEntry": [
                      {
                        "ifIndex": "1",
                        "tunnelIfLocalAddress": "192.168.1.1",
                        "tunnelIfRemoteAddress": "192.168.1.1",
                        "tunnelIfEncapsMethod": "example-string",
                        "tunnelIfHopLimit": -2147483648,
                        "tunnelIfSecurity": "example-string",
                        "tunnelIfTOS": -2147483648,
                        "tunnelIfFlowLabel": -2147483648,
                        "tunnelIfAddressType": "192.168.1.1",
                        "tunnelIfLocalInetAddress": "192.168.1.1",
                        "tunnelIfRemoteInetAddress": "192.168.1.1",
                        "tunnelIfEncapsLimit": -2147483648
                      },
                      {
                        "ifIndex": "2",
                        "tunnelIfLocalAddress": "192.168.1.1",
                        "tunnelIfRemoteAddress": "192.168.1.1",
                        "tunnelIfEncapsMethod": "example-string",
                        "tunnelIfHopLimit": -2147483648,
                        "tunnelIfSecurity": "example-string",
                        "tunnelIfTOS": -2147483648,
                        "tunnelIfFlowLabel": -2147483648,
                        "tunnelIfAddressType": "192.168.1.1",
                        "tunnelIfLocalInetAddress": "192.168.1.1",
                        "tunnelIfRemoteInetAddress": "192.168.1.1",
                        "tunnelIfEncapsLimit": -2147483648
                      },
                      {
                        "ifIndex": "3",
                        "tunnelIfLocalAddress": "192.168.1.1",
                        "tunnelIfRemoteAddress": "192.168.1.1",
                        "tunnelIfEncapsMethod": "example-string",
                        "tunnelIfHopLimit": -2147483648,
                        "tunnelIfSecurity": "example-string",
                        "tunnelIfTOS": -2147483648,
                        "tunnelIfFlowLabel": -2147483648,
                        "tunnelIfAddressType": "192.168.1.1",
                        "tunnelIfLocalInetAddress": "192.168.1.1",
                        "tunnelIfRemoteInetAddress": "192.168.1.1",
                        "tunnelIfEncapsLimit": -2147483648
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelIfTable/tunnelIfEntry": {
      "get": {
        "summary": "Get tunnelIfEntry list",
        "description": "Retrieve list of tunnelIfEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ifIndex": {
                        "type": "string",
                        "description": "ifIndex",
                        "x-yang-type": "leafref"
                      },
                      "tunnelIfLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelIfRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelIfEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelIfHopLimit": {
                        "type": "integer",
                        "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfSecurity": {
                        "type": "string",
                        "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                      },
                      "tunnelIfTOS": {
                        "type": "integer",
                        "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfFlowLabel": {
                        "type": "integer",
                        "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfAddressType": {
                        "type": "string",
                        "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "tunnelIfLocalInetAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelIfRemoteInetAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelIfEncapsLimit": {
                        "type": "integer",
                        "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelIfEntry": [
                    {
                      "ifIndex": "example-string",
                      "tunnelIfLocalAddress": "192.168.1.1",
                      "tunnelIfRemoteAddress": "192.168.1.1",
                      "tunnelIfEncapsMethod": "example-string",
                      "tunnelIfHopLimit": -2147483648,
                      "tunnelIfSecurity": "example-string",
                      "tunnelIfTOS": -2147483648,
                      "tunnelIfFlowLabel": -2147483648,
                      "tunnelIfAddressType": "192.168.1.1",
                      "tunnelIfLocalInetAddress": "192.168.1.1",
                      "tunnelIfRemoteInetAddress": "192.168.1.1",
                      "tunnelIfEncapsLimit": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelIfTable/tunnelIfEntry={ifIndex}": {
      "get": {
        "summary": "Get tunnelIfEntry entry",
        "description": "Retrieve specific tunnelIfEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ifIndex": {
                      "type": "string",
                      "description": "ifIndex",
                      "x-yang-type": "leafref"
                    },
                    "tunnelIfLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelIfHopLimit": {
                      "type": "integer",
                      "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfSecurity": {
                      "type": "string",
                      "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                    },
                    "tunnelIfTOS": {
                      "type": "integer",
                      "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfFlowLabel": {
                      "type": "integer",
                      "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfAddressType": {
                      "type": "string",
                      "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelIfLocalInetAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfRemoteInetAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfEncapsLimit": {
                      "type": "integer",
                      "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelIfEntry": {
                    "ifIndex": "example-string",
                    "tunnelIfLocalAddress": "192.168.1.1",
                    "tunnelIfRemoteAddress": "192.168.1.1",
                    "tunnelIfEncapsMethod": "example-string",
                    "tunnelIfHopLimit": -2147483648,
                    "tunnelIfSecurity": "example-string",
                    "tunnelIfTOS": -2147483648,
                    "tunnelIfFlowLabel": -2147483648,
                    "tunnelIfAddressType": "192.168.1.1",
                    "tunnelIfLocalInetAddress": "192.168.1.1",
                    "tunnelIfRemoteInetAddress": "192.168.1.1",
                    "tunnelIfEncapsLimit": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelConfigTable": {
      "get": {
        "summary": "Get tunnelConfigTable data",
        "description": "Retrieve tunnelConfigTable operational data from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "tunnelConfigTable",
                  "properties": {
                    "tunnelConfigEntry": {
                      "type": "array",
                      "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "tunnelConfigLocalAddress": {
                            "type": "string",
                            "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                            "format": "inet:ipv4-address"
                          },
                          "tunnelConfigRemoteAddress": {
                            "type": "string",
                            "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                            "format": "inet:ipv4-address"
                          },
                          "tunnelConfigEncapsMethod": {
                            "type": "string",
                            "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                            "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                          },
                          "tunnelConfigID": {
                            "type": "integer",
                            "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "tunnelConfigIfIndex": {
                            "type": "string",
                            "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                            "x-yang-type": "if-mib:InterfaceIndexOrZero"
                          },
                          "tunnelConfigStatus": {
                            "type": "string",
                            "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelConfigTable": {
                    "tunnelConfigEntry": [
                      {
                        "tunnelConfigLocalAddress": "192.168.1.1",
                        "tunnelConfigRemoteAddress": "192.168.1.1",
                        "tunnelConfigEncapsMethod": "example-string",
                        "tunnelConfigID": -2147483648,
                        "tunnelConfigIfIndex": "1",
                        "tunnelConfigStatus": "up(1)"
                      },
                      {
                        "tunnelConfigLocalAddress": "192.168.1.1",
                        "tunnelConfigRemoteAddress": "192.168.1.1",
                        "tunnelConfigEncapsMethod": "example-string",
                        "tunnelConfigID": -2147483648,
                        "tunnelConfigIfIndex": "2",
                        "tunnelConfigStatus": "up(1)"
                      },
                      {
                        "tunnelConfigLocalAddress": "192.168.1.1",
                        "tunnelConfigRemoteAddress": "192.168.1.1",
                        "tunnelConfigEncapsMethod": "example-string",
                        "tunnelConfigID": -2147483648,
                        "tunnelConfigIfIndex": "3",
                        "tunnelConfigStatus": "up(1)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelConfigTable/tunnelConfigEntry": {
      "get": {
        "summary": "Get tunnelConfigEntry list",
        "description": "Retrieve list of tunnelConfigEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "tunnelConfigLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelConfigRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelConfigEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelConfigID": {
                        "type": "integer",
                        "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelConfigIfIndex": {
                        "type": "string",
                        "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "tunnelConfigStatus": {
                        "type": "string",
                        "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelConfigEntry": [
                    {
                      "tunnelConfigLocalAddress": "192.168.1.1",
                      "tunnelConfigRemoteAddress": "192.168.1.1",
                      "tunnelConfigEncapsMethod": "example-string",
                      "tunnelConfigID": -2147483648,
                      "tunnelConfigIfIndex": "example-string",
                      "tunnelConfigStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelConfigTable/tunnelConfigEntry={tunnelConfigLocalAddress tunnelConfigRemoteAddress tunnelConfigEncapsMethod tunnelConfigID}": {
      "get": {
        "summary": "Get tunnelConfigEntry entry",
        "description": "Retrieve specific tunnelConfigEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "tunnelConfigLocalAddress tunnelConfigRemoteAddress tunnelConfigEncapsMethod tunnelConfigID",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tunnelConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelConfigEntry": {
                    "tunnelConfigLocalAddress": "192.168.1.1",
                    "tunnelConfigRemoteAddress": "192.168.1.1",
                    "tunnelConfigEncapsMethod": "example-string",
                    "tunnelConfigID": -2147483648,
                    "tunnelConfigIfIndex": "example-string",
                    "tunnelConfigStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelInetConfigTable": {
      "get": {
        "summary": "Get tunnelInetConfigTable data",
        "description": "Retrieve tunnelInetConfigTable operational data from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "The (conceptual) table containing information on\n        configured tunnels.  This table can be used to map a\n        set of tunnel endpoints to the associated ifIndex\n        value.  It can also be used for row creation.  Note\n        that every row in the tunnelIfTable with a fixed\n        destination address should have a corresponding row in\n        the tunnelInetConfigTable, regardless of whether it\n        was created via SNMP.",
                  "properties": {
                    "tunnelInetConfigEntry": {
                      "type": "array",
                      "description": "tunnelInetConfigEntry",
                      "items": {
                        "type": "object",
                        "properties": {
                          "tunnelInetConfigAddressType": {
                            "type": "string",
                            "description": "The address type over which the tunnel encapsulates\n            packets.",
                            "x-yang-type": "inet-address:InetAddressType"
                          },
                          "tunnelInetConfigLocalAddress": {
                            "type": "string",
                            "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "tunnelInetConfigRemoteAddress": {
                            "type": "string",
                            "description": "The address of the remote endpoint of the tunnel.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "tunnelInetConfigEncapsMethod": {
                            "type": "string",
                            "description": "The encapsulation method used by the tunnel.",
                            "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                          },
                          "tunnelInetConfigID": {
                            "type": "integer",
                            "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "tunnelInetConfigIfIndex": {
                            "type": "string",
                            "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                            "x-yang-type": "if-mib:InterfaceIndexOrZero"
                          },
                          "tunnelInetConfigStatus": {
                            "type": "string",
                            "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          },
                          "tunnelInetConfigStorageType": {
                            "type": "string",
                            "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                            "x-yang-type": "snmpv2-tc:StorageType"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelInetConfigTable": {
                    "tunnelInetConfigEntry": [
                      {
                        "tunnelInetConfigAddressType": "192.168.1.1",
                        "tunnelInetConfigLocalAddress": "192.168.1.1",
                        "tunnelInetConfigRemoteAddress": "192.168.1.1",
                        "tunnelInetConfigEncapsMethod": "example-string",
                        "tunnelInetConfigID": -2147483648,
                        "tunnelInetConfigIfIndex": "1",
                        "tunnelInetConfigStatus": "up(1)",
                        "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "tunnelInetConfigAddressType": "192.168.1.1",
                        "tunnelInetConfigLocalAddress": "192.168.1.1",
                        "tunnelInetConfigRemoteAddress": "192.168.1.1",
                        "tunnelInetConfigEncapsMethod": "example-string",
                        "tunnelInetConfigID": -2147483648,
                        "tunnelInetConfigIfIndex": "2",
                        "tunnelInetConfigStatus": "up(1)",
                        "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "tunnelInetConfigAddressType": "192.168.1.1",
                        "tunnelInetConfigLocalAddress": "192.168.1.1",
                        "tunnelInetConfigRemoteAddress": "192.168.1.1",
                        "tunnelInetConfigEncapsMethod": "example-string",
                        "tunnelInetConfigID": -2147483648,
                        "tunnelInetConfigIfIndex": "3",
                        "tunnelInetConfigStatus": "up(1)",
                        "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelInetConfigTable/tunnelInetConfigEntry": {
      "get": {
        "summary": "Get tunnelInetConfigEntry list",
        "description": "Retrieve list of tunnelInetConfigEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "tunnelInetConfigEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "tunnelInetConfigAddressType": {
                        "type": "string",
                        "description": "The address type over which the tunnel encapsulates\n            packets.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "tunnelInetConfigLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelInetConfigRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelInetConfigEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelInetConfigID": {
                        "type": "integer",
                        "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelInetConfigIfIndex": {
                        "type": "string",
                        "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "tunnelInetConfigStatus": {
                        "type": "string",
                        "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "tunnelInetConfigStorageType": {
                        "type": "string",
                        "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelInetConfigEntry": [
                    {
                      "tunnelInetConfigAddressType": "192.168.1.1",
                      "tunnelInetConfigLocalAddress": "192.168.1.1",
                      "tunnelInetConfigRemoteAddress": "192.168.1.1",
                      "tunnelInetConfigEncapsMethod": "example-string",
                      "tunnelInetConfigID": -2147483648,
                      "tunnelInetConfigIfIndex": "example-string",
                      "tunnelInetConfigStatus": "up(1)",
                      "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelInetConfigTable/tunnelInetConfigEntry={tunnelInetConfigAddressType tunnelInetConfigLocalAddress tunnelInetConfigRemoteAddress tunnelInetConfigEncapsMethod tunnelInetConfigID}": {
      "get": {
        "summary": "Get tunnelInetConfigEntry entry",
        "description": "Retrieve specific tunnelInetConfigEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "tunnelInetConfigAddressType tunnelInetConfigLocalAddress tunnelInetConfigRemoteAddress tunnelInetConfigEncapsMethod tunnelInetConfigID",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tunnelInetConfigAddressType": {
                      "type": "string",
                      "description": "The address type over which the tunnel encapsulates\n            packets.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelInetConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelInetConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelInetConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelInetConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "tunnelInetConfigStorageType": {
                      "type": "string",
                      "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelInetConfigEntry": {
                    "tunnelInetConfigAddressType": "192.168.1.1",
                    "tunnelInetConfigLocalAddress": "192.168.1.1",
                    "tunnelInetConfigRemoteAddress": "192.168.1.1",
                    "tunnelInetConfigEncapsMethod": "example-string",
                    "tunnelInetConfigID": -2147483648,
                    "tunnelInetConfigIfIndex": "example-string",
                    "tunnelInetConfigStatus": "up(1)",
                    "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelIfEntry": {
      "get": {
        "summary": "Get tunnelIfEntry list",
        "description": "Retrieve list of tunnelIfEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "ifIndex": {
                        "type": "string",
                        "description": "ifIndex",
                        "x-yang-type": "leafref"
                      },
                      "tunnelIfLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelIfRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelIfEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelIfHopLimit": {
                        "type": "integer",
                        "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfSecurity": {
                        "type": "string",
                        "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                      },
                      "tunnelIfTOS": {
                        "type": "integer",
                        "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfFlowLabel": {
                        "type": "integer",
                        "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelIfAddressType": {
                        "type": "string",
                        "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "tunnelIfLocalInetAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelIfRemoteInetAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelIfEncapsLimit": {
                        "type": "integer",
                        "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelIfEntry": [
                    {
                      "ifIndex": "example-string",
                      "tunnelIfLocalAddress": "192.168.1.1",
                      "tunnelIfRemoteAddress": "192.168.1.1",
                      "tunnelIfEncapsMethod": "example-string",
                      "tunnelIfHopLimit": -2147483648,
                      "tunnelIfSecurity": "example-string",
                      "tunnelIfTOS": -2147483648,
                      "tunnelIfFlowLabel": -2147483648,
                      "tunnelIfAddressType": "192.168.1.1",
                      "tunnelIfLocalInetAddress": "192.168.1.1",
                      "tunnelIfRemoteInetAddress": "192.168.1.1",
                      "tunnelIfEncapsLimit": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelIfEntry={ifIndex}": {
      "get": {
        "summary": "Get tunnelIfEntry entry",
        "description": "Retrieve specific tunnelIfEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "ifIndex": {
                      "type": "string",
                      "description": "ifIndex",
                      "x-yang-type": "leafref"
                    },
                    "tunnelIfLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelIfHopLimit": {
                      "type": "integer",
                      "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfSecurity": {
                      "type": "string",
                      "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                    },
                    "tunnelIfTOS": {
                      "type": "integer",
                      "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfFlowLabel": {
                      "type": "integer",
                      "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfAddressType": {
                      "type": "string",
                      "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelIfLocalInetAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfRemoteInetAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfEncapsLimit": {
                      "type": "integer",
                      "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelIfEntry": {
                    "ifIndex": "example-string",
                    "tunnelIfLocalAddress": "192.168.1.1",
                    "tunnelIfRemoteAddress": "192.168.1.1",
                    "tunnelIfEncapsMethod": "example-string",
                    "tunnelIfHopLimit": -2147483648,
                    "tunnelIfSecurity": "example-string",
                    "tunnelIfTOS": -2147483648,
                    "tunnelIfFlowLabel": -2147483648,
                    "tunnelIfAddressType": "192.168.1.1",
                    "tunnelIfLocalInetAddress": "192.168.1.1",
                    "tunnelIfRemoteInetAddress": "192.168.1.1",
                    "tunnelIfEncapsLimit": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelConfigEntry": {
      "get": {
        "summary": "Get tunnelConfigEntry list",
        "description": "Retrieve list of tunnelConfigEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "tunnelConfigLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelConfigRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                        "format": "inet:ipv4-address"
                      },
                      "tunnelConfigEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelConfigID": {
                        "type": "integer",
                        "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelConfigIfIndex": {
                        "type": "string",
                        "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "tunnelConfigStatus": {
                        "type": "string",
                        "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelConfigEntry": [
                    {
                      "tunnelConfigLocalAddress": "192.168.1.1",
                      "tunnelConfigRemoteAddress": "192.168.1.1",
                      "tunnelConfigEncapsMethod": "example-string",
                      "tunnelConfigID": -2147483648,
                      "tunnelConfigIfIndex": "example-string",
                      "tunnelConfigStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelConfigEntry={tunnelConfigLocalAddress tunnelConfigRemoteAddress tunnelConfigEncapsMethod tunnelConfigID}": {
      "get": {
        "summary": "Get tunnelConfigEntry entry",
        "description": "Retrieve specific tunnelConfigEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "tunnelConfigLocalAddress tunnelConfigRemoteAddress tunnelConfigEncapsMethod tunnelConfigID",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tunnelConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelConfigEntry": {
                    "tunnelConfigLocalAddress": "192.168.1.1",
                    "tunnelConfigRemoteAddress": "192.168.1.1",
                    "tunnelConfigEncapsMethod": "example-string",
                    "tunnelConfigID": -2147483648,
                    "tunnelConfigIfIndex": "example-string",
                    "tunnelConfigStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelInetConfigEntry": {
      "get": {
        "summary": "Get tunnelInetConfigEntry list",
        "description": "Retrieve list of tunnelInetConfigEntry entries from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "tunnelInetConfigEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "tunnelInetConfigAddressType": {
                        "type": "string",
                        "description": "The address type over which the tunnel encapsulates\n            packets.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "tunnelInetConfigLocalAddress": {
                        "type": "string",
                        "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelInetConfigRemoteAddress": {
                        "type": "string",
                        "description": "The address of the remote endpoint of the tunnel.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "tunnelInetConfigEncapsMethod": {
                        "type": "string",
                        "description": "The encapsulation method used by the tunnel.",
                        "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                      },
                      "tunnelInetConfigID": {
                        "type": "integer",
                        "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "tunnelInetConfigIfIndex": {
                        "type": "string",
                        "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "tunnelInetConfigStatus": {
                        "type": "string",
                        "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "tunnelInetConfigStorageType": {
                        "type": "string",
                        "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelInetConfigEntry": [
                    {
                      "tunnelInetConfigAddressType": "192.168.1.1",
                      "tunnelInetConfigLocalAddress": "192.168.1.1",
                      "tunnelInetConfigRemoteAddress": "192.168.1.1",
                      "tunnelInetConfigEncapsMethod": "example-string",
                      "tunnelInetConfigID": -2147483648,
                      "tunnelInetConfigIfIndex": "example-string",
                      "tunnelInetConfigStatus": "up(1)",
                      "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/TUNNEL-MIB:tunnelInetConfigEntry={tunnelInetConfigAddressType tunnelInetConfigLocalAddress tunnelInetConfigRemoteAddress tunnelInetConfigEncapsMethod tunnelInetConfigID}": {
      "get": {
        "summary": "Get tunnelInetConfigEntry entry",
        "description": "Retrieve specific tunnelInetConfigEntry entry by key from MIB",
        "tags": [
          "TUNNEL-MIB"
        ],
        "parameters": [
          {
            "name": "tunnelInetConfigAddressType tunnelInetConfigLocalAddress tunnelInetConfigRemoteAddress tunnelInetConfigEncapsMethod tunnelInetConfigID",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tunnelInetConfigAddressType": {
                      "type": "string",
                      "description": "The address type over which the tunnel encapsulates\n            packets.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelInetConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelInetConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelInetConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelInetConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "tunnelInetConfigStorageType": {
                      "type": "string",
                      "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "TUNNEL-MIB:tunnelInetConfigEntry": {
                    "tunnelInetConfigAddressType": "192.168.1.1",
                    "tunnelInetConfigLocalAddress": "192.168.1.1",
                    "tunnelInetConfigRemoteAddress": "192.168.1.1",
                    "tunnelInetConfigEncapsMethod": "example-string",
                    "tunnelInetConfigID": -2147483648,
                    "tunnelInetConfigIfIndex": "example-string",
                    "tunnelInetConfigStatus": "up(1)",
                    "tunnelInetConfigStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "TUNNEL-MIB_TUNNEL-MIB": {
        "type": "object",
        "description": "The (conceptual) table containing information on\n        configured tunnels.",
        "properties": {
          "tunnelIfEntry": {
            "type": "array",
            "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
            "items": {
              "type": "object",
              "properties": {
                "ifIndex": {
                  "type": "string",
                  "description": "ifIndex",
                  "x-yang-type": "leafref"
                },
                "tunnelIfLocalAddress": {
                  "type": "string",
                  "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                  "format": "inet:ipv4-address"
                },
                "tunnelIfRemoteAddress": {
                  "type": "string",
                  "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                  "format": "inet:ipv4-address"
                },
                "tunnelIfEncapsMethod": {
                  "type": "string",
                  "description": "The encapsulation method used by the tunnel.",
                  "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                },
                "tunnelIfHopLimit": {
                  "type": "integer",
                  "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "tunnelIfSecurity": {
                  "type": "string",
                  "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                },
                "tunnelIfTOS": {
                  "type": "integer",
                  "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "tunnelIfFlowLabel": {
                  "type": "integer",
                  "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "tunnelIfAddressType": {
                  "type": "string",
                  "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                  "x-yang-type": "inet-address:InetAddressType"
                },
                "tunnelIfLocalInetAddress": {
                  "type": "string",
                  "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "tunnelIfRemoteInetAddress": {
                  "type": "string",
                  "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "tunnelIfEncapsLimit": {
                  "type": "integer",
                  "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                }
              }
            }
          },
          "tunnelConfigEntry": {
            "type": "array",
            "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
            "items": {
              "type": "object",
              "properties": {
                "tunnelConfigLocalAddress": {
                  "type": "string",
                  "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                  "format": "inet:ipv4-address"
                },
                "tunnelConfigRemoteAddress": {
                  "type": "string",
                  "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                  "format": "inet:ipv4-address"
                },
                "tunnelConfigEncapsMethod": {
                  "type": "string",
                  "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                  "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                },
                "tunnelConfigID": {
                  "type": "integer",
                  "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "tunnelConfigIfIndex": {
                  "type": "string",
                  "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                  "x-yang-type": "if-mib:InterfaceIndexOrZero"
                },
                "tunnelConfigStatus": {
                  "type": "string",
                  "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                }
              }
            }
          },
          "tunnelInetConfigEntry": {
            "type": "array",
            "description": "tunnelInetConfigEntry",
            "items": {
              "type": "object",
              "properties": {
                "tunnelInetConfigAddressType": {
                  "type": "string",
                  "description": "The address type over which the tunnel encapsulates\n            packets.",
                  "x-yang-type": "inet-address:InetAddressType"
                },
                "tunnelInetConfigLocalAddress": {
                  "type": "string",
                  "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "tunnelInetConfigRemoteAddress": {
                  "type": "string",
                  "description": "The address of the remote endpoint of the tunnel.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "tunnelInetConfigEncapsMethod": {
                  "type": "string",
                  "description": "The encapsulation method used by the tunnel.",
                  "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                },
                "tunnelInetConfigID": {
                  "type": "integer",
                  "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "tunnelInetConfigIfIndex": {
                  "type": "string",
                  "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                  "x-yang-type": "if-mib:InterfaceIndexOrZero"
                },
                "tunnelInetConfigStatus": {
                  "type": "string",
                  "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                },
                "tunnelInetConfigStorageType": {
                  "type": "string",
                  "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                  "x-yang-type": "snmpv2-tc:StorageType"
                }
              }
            }
          },
          "tunnelIfTable": {
            "type": "object",
            "description": "The (conceptual) table containing information on\n        configured tunnels.",
            "properties": {
              "tunnelIfEntry": {
                "type": "array",
                "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
                "items": {
                  "type": "object",
                  "properties": {
                    "ifIndex": {
                      "type": "string",
                      "description": "ifIndex",
                      "x-yang-type": "leafref"
                    },
                    "tunnelIfLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelIfEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelIfHopLimit": {
                      "type": "integer",
                      "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfSecurity": {
                      "type": "string",
                      "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
                    },
                    "tunnelIfTOS": {
                      "type": "integer",
                      "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfFlowLabel": {
                      "type": "integer",
                      "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelIfAddressType": {
                      "type": "string",
                      "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelIfLocalInetAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfRemoteInetAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelIfEncapsLimit": {
                      "type": "integer",
                      "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    }
                  }
                }
              }
            }
          },
          "tunnelConfigTable": {
            "type": "object",
            "description": "tunnelConfigTable",
            "properties": {
              "tunnelConfigEntry": {
                "type": "array",
                "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
                "items": {
                  "type": "object",
                  "properties": {
                    "tunnelConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
                      "format": "inet:ipv4-address"
                    },
                    "tunnelConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                }
              }
            }
          },
          "tunnelInetConfigTable": {
            "type": "object",
            "description": "The (conceptual) table containing information on\n        configured tunnels.  This table can be used to map a\n        set of tunnel endpoints to the associated ifIndex\n        value.  It can also be used for row creation.  Note\n        that every row in the tunnelIfTable with a fixed\n        destination address should have a corresponding row in\n        the tunnelInetConfigTable, regardless of whether it\n        was created via SNMP.",
            "properties": {
              "tunnelInetConfigEntry": {
                "type": "array",
                "description": "tunnelInetConfigEntry",
                "items": {
                  "type": "object",
                  "properties": {
                    "tunnelInetConfigAddressType": {
                      "type": "string",
                      "description": "The address type over which the tunnel encapsulates\n            packets.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "tunnelInetConfigLocalAddress": {
                      "type": "string",
                      "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigRemoteAddress": {
                      "type": "string",
                      "description": "The address of the remote endpoint of the tunnel.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "tunnelInetConfigEncapsMethod": {
                      "type": "string",
                      "description": "The encapsulation method used by the tunnel.",
                      "x-yang-type": "ianaiftype-mib:IANAtunnelType"
                    },
                    "tunnelInetConfigID": {
                      "type": "integer",
                      "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "tunnelInetConfigIfIndex": {
                      "type": "string",
                      "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "tunnelInetConfigStatus": {
                      "type": "string",
                      "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "tunnelInetConfigStorageType": {
                      "type": "string",
                      "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "TUNNEL-MIB_tunnelIfEntry": {
        "type": "array",
        "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.",
        "items": {
          "type": "object",
          "properties": {
            "ifIndex": {
              "type": "string",
              "description": "ifIndex",
              "x-yang-type": "leafref"
            },
            "tunnelIfLocalAddress": {
              "type": "string",
              "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header), or 0.0.0.0 if unknown or if the tunnel is\n            over IPv6.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfLocalInetAddress.",
              "format": "inet:ipv4-address"
            },
            "tunnelIfRemoteAddress": {
              "type": "string",
              "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header), or 0.0.0.0 if unknown, or an IPv6 address, or\n            \n            the tunnel is not a point-to-point link (e.g., if it\n            is a 6to4 tunnel).\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelIfRemoteInetAddress.",
              "format": "inet:ipv4-address"
            },
            "tunnelIfEncapsMethod": {
              "type": "string",
              "description": "The encapsulation method used by the tunnel.",
              "x-yang-type": "ianaiftype-mib:IANAtunnelType"
            },
            "tunnelIfHopLimit": {
              "type": "integer",
              "description": "The IPv4 TTL or IPv6 Hop Limit to use in the outer IP\n            header.  A value of 0 indicates that the value is\n            copied from the payload's header.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tunnelIfSecurity": {
              "type": "string",
              "description": "The method used by the tunnel to secure the outer IP\n            header.  The value ipsec indicates that IPsec is used\n            between the tunnel endpoints for authentication or\n            encryption or both.  More specific security-related\n            information may be available in a MIB module for the\n            security protocol in use."
            },
            "tunnelIfTOS": {
              "type": "integer",
              "description": "The method used to set the high 6 bits (the\n            \n            differentiated services codepoint) of the IPv4 TOS or\n            IPv6 Traffic Class in the outer IP header.  A value of\n            -1 indicates that the bits are copied from the\n            payload's header.  A value of -2 indicates that a\n            traffic conditioner is invoked and more information\n            may be available in a traffic conditioner MIB module.\n            A value between 0 and 63 inclusive indicates that the\n            bit field is set to the indicated value.\n            \n            Note: instead of the name tunnelIfTOS, a better name\n            would have been tunnelIfDSCPMethod, but the existing\n            name appeared in RFC 2667 and existing objects cannot\n            be renamed.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tunnelIfFlowLabel": {
              "type": "integer",
              "description": "The method used to set the IPv6 Flow Label value.\n            This object need not be present in rows where\n            tunnelIfAddressType indicates the tunnel is not over\n            IPv6.  A value of -1 indicates that a traffic\n            conditioner is invoked and more information may be\n            available in a traffic conditioner MIB.  Any other\n            value indicates that the Flow Label field is set to\n            the indicated value.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tunnelIfAddressType": {
              "type": "string",
              "description": "The type of address in the corresponding\n            tunnelIfLocalInetAddress and tunnelIfRemoteInetAddress\n            objects.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "tunnelIfLocalInetAddress": {
              "type": "string",
              "description": "The address of the local endpoint of the tunnel\n            (i.e., the source address used in the outer IP\n            header).  If the address is unknown, the value is\n            \n            0.0.0.0 for IPv4 or :: for IPv6.  The type of this\n            object is given by tunnelIfAddressType.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "tunnelIfRemoteInetAddress": {
              "type": "string",
              "description": "The address of the remote endpoint of the tunnel\n            (i.e., the destination address used in the outer IP\n            header).  If the address is unknown or the tunnel is\n            not a point-to-point link (e.g., if it is a 6to4\n            tunnel), the value is 0.0.0.0 for tunnels over IPv4 or\n            :: for tunnels over IPv6.  The type of this object is\n            given by tunnelIfAddressType.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "tunnelIfEncapsLimit": {
              "type": "integer",
              "description": "The maximum number of additional encapsulations\n            permitted for packets undergoing encapsulation at this\n            node.  A value of -1 indicates that no limit is\n            present (except as a result of the packet size).",
              "minimum": -2147483648,
              "maximum": 2147483647
            }
          }
        }
      },
      "TUNNEL-MIB_tunnelConfigEntry": {
        "type": "array",
        "description": "An entry (conceptual row) containing the information\n          on a particular configured tunnel.\n          \n          Since this entry does not support IPv6, it is\n          deprecated in favor of tunnelInetConfigEntry.",
        "items": {
          "type": "object",
          "properties": {
            "tunnelConfigLocalAddress": {
              "type": "string",
              "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 if the device is free to choose any of its\n            addresses at tunnel establishment time.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigLocalAddress.",
              "format": "inet:ipv4-address"
            },
            "tunnelConfigRemoteAddress": {
              "type": "string",
              "description": "The address of the remote endpoint of the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigRemoteAddress.",
              "format": "inet:ipv4-address"
            },
            "tunnelConfigEncapsMethod": {
              "type": "string",
              "description": "The encapsulation method used by the tunnel.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigEncapsMethod.",
              "x-yang-type": "ianaiftype-mib:IANAtunnelType"
            },
            "tunnelConfigID": {
              "type": "integer",
              "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            conflict with an existing row, such as choosing a\n            random number.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigID.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tunnelConfigIfIndex": {
              "type": "string",
              "description": "If the value of tunnelConfigStatus for this row is\n            active, then this object contains the value of ifIndex\n            corresponding to the tunnel interface.  A value of 0\n            is not legal in the active state, and means that the\n            interface index has not yet been assigned.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigIfIndex.",
              "x-yang-type": "if-mib:InterfaceIndexOrZero"
            },
            "tunnelConfigStatus": {
              "type": "string",
              "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelConfigID of 1, and\n            set tunnelConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelConfigID and\n            set tunnelConfigStatus to createAndGo.  In the event\n            that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.\n            \n            Since this object does not support IPv6, it is\n            deprecated in favor of tunnelInetConfigStatus.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "TUNNEL-MIB_tunnelInetConfigEntry": {
        "type": "array",
        "description": "tunnelInetConfigEntry",
        "items": {
          "type": "object",
          "properties": {
            "tunnelInetConfigAddressType": {
              "type": "string",
              "description": "The address type over which the tunnel encapsulates\n            packets.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "tunnelInetConfigLocalAddress": {
              "type": "string",
              "description": "The address of the local endpoint of the tunnel, or\n            0.0.0.0 (for IPv4) or :: (for IPv6) if the device is\n            free to choose any of its addresses at tunnel\n            establishment time.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "tunnelInetConfigRemoteAddress": {
              "type": "string",
              "description": "The address of the remote endpoint of the tunnel.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "tunnelInetConfigEncapsMethod": {
              "type": "string",
              "description": "The encapsulation method used by the tunnel.",
              "x-yang-type": "ianaiftype-mib:IANAtunnelType"
            },
            "tunnelInetConfigID": {
              "type": "integer",
              "description": "An identifier used to distinguish between multiple\n            tunnels of the same encapsulation method, with the\n            same endpoints.  If the encapsulation protocol only\n            allows one tunnel per set of endpoint addresses (such\n            as for GRE or IP-in-IP), the value of this object is\n            1.  For encapsulation methods (such as L2F) which\n            allow multiple parallel tunnels, the manager is\n            responsible for choosing any ID which does not\n            \n            conflict with an existing row, such as choosing a\n            random number.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tunnelInetConfigIfIndex": {
              "type": "string",
              "description": "If the value of tunnelInetConfigStatus for this row\n            is active, then this object contains the value of\n            ifIndex corresponding to the tunnel interface.  A\n            value of 0 is not legal in the active state, and means\n            that the interface index has not yet been assigned.",
              "x-yang-type": "if-mib:InterfaceIndexOrZero"
            },
            "tunnelInetConfigStatus": {
              "type": "string",
              "description": "The status of this row, by which new entries may be\n            created, or old entries deleted from this table.  The\n            agent need not support setting this object to\n            createAndWait or notInService since there are no other\n            writable objects in this table, and writable objects\n            in rows of corresponding tables such as the\n            tunnelIfTable may be modified while this row is\n            active.\n            \n            To create a row in this table for an encapsulation\n            method which does not support multiple parallel\n            tunnels with the same endpoints, the management\n            station should simply use a tunnelInetConfigID of 1,\n            and set tunnelInetConfigStatus to createAndGo.  For\n            encapsulation methods such as L2F which allow multiple\n            parallel tunnels, the management station may select a\n            pseudo-random number to use as the tunnelInetConfigID\n            and set tunnelInetConfigStatus to createAndGo.  In the\n            event that this ID is already in use and an\n            inconsistentValue is returned in response to the set\n            operation, the management station should simply select\n            a new pseudo-random number and retry the operation.\n            \n            Creating a row in this table will cause an interface\n            index to be assigned by the agent in an\n            implementation-dependent manner, and corresponding\n            rows will be instantiated in the ifTable and the\n            \n            tunnelIfTable.  The status of this row will become\n            active as soon as the agent assigns the interface\n            index, regardless of whether the interface is\n            operationally up.\n            \n            Deleting a row in this table will likewise delete the\n            corresponding row in the ifTable and in the\n            tunnelIfTable.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "tunnelInetConfigStorageType": {
              "type": "string",
              "description": "The storage type of this row.  If the row is\n            permanent(4), no objects in the row need be writable.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "TUNNEL-MIB",
      "description": "MIB operations for TUNNEL-MIB"
    }
  ]
}