{
  "openapi": "3.0.0",
  "info": {
    "title": "CISCO-BULK-FILE-MIB MIB API",
    "version": "1.0.0",
    "description": "The MIB module for creating and deleting bulk files of\n    SNMP data for file transfer.\n\n‚ö†Ô∏è **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n\n\n**üìä YANG Tree:** [View CISCO-BULK-FILE-MIB structure](https://jeremycohoe.github.io/cisco-ios-xe-openapi-swagger/yang-trees/CISCO-BULK-FILE-MIB.html)",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/CISCO-BULK-FILE-MIB:cbfDefine": {
      "get": {
        "summary": "Get cbfDefine data",
        "description": "Retrieve cbfDefine operational data from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "The maximum number of file definitions this system\n          can hold in cbfDefineFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
                  "properties": {
                    "cbfDefineMaxFiles": {
                      "type": "integer",
                      "description": "The maximum number of file definitions this system\n          can hold in cbfDefineFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineFiles": {
                      "type": "integer",
                      "description": "The current number of file definitions in cbfDefineFileTable.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineHighFiles": {
                      "type": "integer",
                      "description": "The maximum value of cbfDefineFiles since system \n          initialization.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineFilesRefused": {
                      "type": "integer",
                      "description": "The number of attempts to create a file definition that\n          failed due to exceeding cbfDefineMaxFiles.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineMaxObjects": {
                      "type": "integer",
                      "description": "The maximum total number of object selections to go with\n          file definitions this system, that is, the total number\n          of objects this system can hold in cbfDefineObjectTable.  A\n          value of 0 indicates no configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjects": {
                      "type": "integer",
                      "description": "The current number of object selections in \n          cbfDefineObjectTable.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineHighObjects": {
                      "type": "integer",
                      "description": "The maximum value of cbfDefineObjects since system \n          initialization.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectsRefused": {
                      "type": "integer",
                      "description": "The number of attempts to create an object selection that\n          failed due to exceeding cbfDefineMaxObjects.",
                      "minimum": 0,
                      "maximum": 4294967295
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefine": {
                    "cbfDefineMaxFiles": 0,
                    "cbfDefineFiles": 0,
                    "cbfDefineHighFiles": 0,
                    "cbfDefineFilesRefused": 0,
                    "cbfDefineMaxObjects": 0,
                    "cbfDefineObjects": 0,
                    "cbfDefineHighObjects": 0,
                    "cbfDefineObjectsRefused": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatus": {
      "get": {
        "summary": "Get cbfStatus data",
        "description": "Retrieve cbfStatus operational data from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "cbfStatus",
                  "properties": {
                    "cbfStatusMaxFiles": {
                      "type": "integer",
                      "description": "The maximum number of file statuses this system\n          can hold in cbfStatusFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number deletes the oldest finished entries until\n          the new limit is satisfied.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusFiles": {
                      "type": "integer",
                      "description": "The current number of file statuses in cbfStatusFileTable.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusHighFiles": {
                      "type": "integer",
                      "description": "The maximum value of cbfStatusFiles since system \n          initialization.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusFilesBumped": {
                      "type": "integer",
                      "description": "The number times the oldest entry was deleted due to exceeding\n          cbfStatusMaxFiles.",
                      "minimum": 0,
                      "maximum": 4294967295
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatus": {
                    "cbfStatusMaxFiles": 0,
                    "cbfStatusFiles": 0,
                    "cbfStatusHighFiles": 0,
                    "cbfStatusFilesBumped": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineFileTable": {
      "get": {
        "summary": "Get cbfDefineFileTable data",
        "description": "Retrieve cbfDefineFileTable operational data from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "A table of bulk file definition and creation controls.",
                  "properties": {
                    "cbfDefineFileEntry": {
                      "type": "array",
                      "description": "cbfDefineFileEntry",
                      "items": {
                        "type": "object",
                        "properties": {
                          "cbfDefineFileIndex": {
                            "type": "integer",
                            "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "cbfDefineFileName": {
                            "type": "string",
                            "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                            "x-yang-type": "snmpv2-tc:DisplayString"
                          },
                          "cbfDefineFileStorage": {
                            "type": "string",
                            "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                          },
                          "cbfDefineFileFormat": {
                            "type": "string",
                            "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                          },
                          "cbfDefineFileNow": {
                            "type": "string",
                            "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                          },
                          "cbfDefineFileEntryStatus": {
                            "type": "string",
                            "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          },
                          "cbfDefineFileNotifyOnCompletion": {
                            "type": "boolean",
                            "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineFileTable": {
                    "cbfDefineFileEntry": [
                      {
                        "cbfDefineFileIndex": 1,
                        "cbfDefineFileName": "interface-1",
                        "cbfDefineFileStorage": "example-string",
                        "cbfDefineFileFormat": "example-string",
                        "cbfDefineFileNow": "example-string",
                        "cbfDefineFileEntryStatus": "up(1)",
                        "cbfDefineFileNotifyOnCompletion": true
                      },
                      {
                        "cbfDefineFileIndex": 2,
                        "cbfDefineFileName": "interface-1",
                        "cbfDefineFileStorage": "example-string",
                        "cbfDefineFileFormat": "example-string",
                        "cbfDefineFileNow": "example-string",
                        "cbfDefineFileEntryStatus": "up(1)",
                        "cbfDefineFileNotifyOnCompletion": true
                      },
                      {
                        "cbfDefineFileIndex": 3,
                        "cbfDefineFileName": "interface-1",
                        "cbfDefineFileStorage": "example-string",
                        "cbfDefineFileFormat": "example-string",
                        "cbfDefineFileNow": "example-string",
                        "cbfDefineFileEntryStatus": "up(1)",
                        "cbfDefineFileNotifyOnCompletion": true
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineFileTable/cbfDefineFileEntry": {
      "get": {
        "summary": "Get cbfDefineFileEntry list",
        "description": "Retrieve list of cbfDefineFileEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "cbfDefineFileEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineFileName": {
                        "type": "string",
                        "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                        "x-yang-type": "snmpv2-tc:DisplayString"
                      },
                      "cbfDefineFileStorage": {
                        "type": "string",
                        "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                      },
                      "cbfDefineFileFormat": {
                        "type": "string",
                        "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                      },
                      "cbfDefineFileNow": {
                        "type": "string",
                        "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                      },
                      "cbfDefineFileEntryStatus": {
                        "type": "string",
                        "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "cbfDefineFileNotifyOnCompletion": {
                        "type": "boolean",
                        "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineFileEntry": [
                    {
                      "cbfDefineFileIndex": 1,
                      "cbfDefineFileName": "interface-1",
                      "cbfDefineFileStorage": "example-string",
                      "cbfDefineFileFormat": "example-string",
                      "cbfDefineFileNow": "example-string",
                      "cbfDefineFileEntryStatus": "up(1)",
                      "cbfDefineFileNotifyOnCompletion": true
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineFileTable/cbfDefineFileEntry={cbfDefineFileIndex}": {
      "get": {
        "summary": "Get cbfDefineFileEntry entry",
        "description": "Retrieve specific cbfDefineFileEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineFileName": {
                      "type": "string",
                      "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                      "x-yang-type": "snmpv2-tc:DisplayString"
                    },
                    "cbfDefineFileStorage": {
                      "type": "string",
                      "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                    },
                    "cbfDefineFileFormat": {
                      "type": "string",
                      "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                    },
                    "cbfDefineFileNow": {
                      "type": "string",
                      "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                    },
                    "cbfDefineFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineFileNotifyOnCompletion": {
                      "type": "boolean",
                      "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineFileEntry": {
                    "cbfDefineFileIndex": 1,
                    "cbfDefineFileName": "interface-1",
                    "cbfDefineFileStorage": "example-string",
                    "cbfDefineFileFormat": "example-string",
                    "cbfDefineFileNow": "example-string",
                    "cbfDefineFileEntryStatus": "up(1)",
                    "cbfDefineFileNotifyOnCompletion": true
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineObjectTable": {
      "get": {
        "summary": "Get cbfDefineObjectTable data",
        "description": "Retrieve cbfDefineObjectTable operational data from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "A table of objects to go in bulk files.",
                  "properties": {
                    "cbfDefineObjectEntry": {
                      "type": "array",
                      "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "cbfDefineFileIndex": {
                            "type": "string",
                            "description": "cbfDefineFileIndex",
                            "x-yang-type": "leafref"
                          },
                          "cbfDefineObjectIndex": {
                            "type": "integer",
                            "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "cbfDefineObjectClass": {
                            "type": "string",
                            "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                          },
                          "cbfDefineObjectID": {
                            "type": "string",
                            "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                            "x-yang-type": "yang:object-identifier-128"
                          },
                          "cbfDefineObjectEntryStatus": {
                            "type": "string",
                            "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          },
                          "cbfDefineObjectTableInstance": {
                            "type": "string",
                            "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                            "x-yang-type": "yang:object-identifier-128"
                          },
                          "cbfDefineObjectNumEntries": {
                            "type": "integer",
                            "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "cbfDefineObjectLastPolledInst": {
                            "type": "string",
                            "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                            "x-yang-type": "yang:object-identifier-128"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineObjectTable": {
                    "cbfDefineObjectEntry": [
                      {
                        "cbfDefineFileIndex": "1",
                        "cbfDefineObjectIndex": 1,
                        "cbfDefineObjectClass": "example-string",
                        "cbfDefineObjectID": "example-string",
                        "cbfDefineObjectEntryStatus": "up(1)",
                        "cbfDefineObjectTableInstance": "example-string",
                        "cbfDefineObjectNumEntries": 0,
                        "cbfDefineObjectLastPolledInst": "example-string"
                      },
                      {
                        "cbfDefineFileIndex": "2",
                        "cbfDefineObjectIndex": 2,
                        "cbfDefineObjectClass": "example-string",
                        "cbfDefineObjectID": "example-string",
                        "cbfDefineObjectEntryStatus": "up(1)",
                        "cbfDefineObjectTableInstance": "example-string",
                        "cbfDefineObjectNumEntries": 0,
                        "cbfDefineObjectLastPolledInst": "example-string"
                      },
                      {
                        "cbfDefineFileIndex": "3",
                        "cbfDefineObjectIndex": 3,
                        "cbfDefineObjectClass": "example-string",
                        "cbfDefineObjectID": "example-string",
                        "cbfDefineObjectEntryStatus": "up(1)",
                        "cbfDefineObjectTableInstance": "example-string",
                        "cbfDefineObjectNumEntries": 0,
                        "cbfDefineObjectLastPolledInst": "example-string"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineObjectTable/cbfDefineObjectEntry": {
      "get": {
        "summary": "Get cbfDefineObjectEntry list",
        "description": "Retrieve list of cbfDefineObjectEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "string",
                        "description": "cbfDefineFileIndex",
                        "x-yang-type": "leafref"
                      },
                      "cbfDefineObjectIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineObjectClass": {
                        "type": "string",
                        "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                      },
                      "cbfDefineObjectID": {
                        "type": "string",
                        "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "cbfDefineObjectEntryStatus": {
                        "type": "string",
                        "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "cbfDefineObjectTableInstance": {
                        "type": "string",
                        "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "cbfDefineObjectNumEntries": {
                        "type": "integer",
                        "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineObjectLastPolledInst": {
                        "type": "string",
                        "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                        "x-yang-type": "yang:object-identifier-128"
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineObjectEntry": [
                    {
                      "cbfDefineFileIndex": "example-string",
                      "cbfDefineObjectIndex": 1,
                      "cbfDefineObjectClass": "example-string",
                      "cbfDefineObjectID": "example-string",
                      "cbfDefineObjectEntryStatus": "up(1)",
                      "cbfDefineObjectTableInstance": "example-string",
                      "cbfDefineObjectNumEntries": 0,
                      "cbfDefineObjectLastPolledInst": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineObjectTable/cbfDefineObjectEntry={cbfDefineFileIndex cbfDefineObjectIndex}": {
      "get": {
        "summary": "Get cbfDefineObjectEntry entry",
        "description": "Retrieve specific cbfDefineObjectEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex cbfDefineObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfDefineObjectIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectClass": {
                      "type": "string",
                      "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                    },
                    "cbfDefineObjectID": {
                      "type": "string",
                      "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineObjectTableInstance": {
                      "type": "string",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectNumEntries": {
                      "type": "integer",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectLastPolledInst": {
                      "type": "string",
                      "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                      "x-yang-type": "yang:object-identifier-128"
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineObjectEntry": {
                    "cbfDefineFileIndex": "example-string",
                    "cbfDefineObjectIndex": 1,
                    "cbfDefineObjectClass": "example-string",
                    "cbfDefineObjectID": "example-string",
                    "cbfDefineObjectEntryStatus": "up(1)",
                    "cbfDefineObjectTableInstance": "example-string",
                    "cbfDefineObjectNumEntries": 0,
                    "cbfDefineObjectLastPolledInst": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatusFileTable": {
      "get": {
        "summary": "Get cbfStatusFileTable data",
        "description": "Retrieve cbfStatusFileTable operational data from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "A table of bulk file status.",
                  "properties": {
                    "cbfStatusFileEntry": {
                      "type": "array",
                      "description": "cbfStatusFileEntry",
                      "items": {
                        "type": "object",
                        "properties": {
                          "cbfDefineFileIndex": {
                            "type": "string",
                            "description": "cbfDefineFileIndex",
                            "x-yang-type": "leafref"
                          },
                          "cbfStatusFileIndex": {
                            "type": "integer",
                            "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "cbfStatusFileState": {
                            "type": "string",
                            "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                          },
                          "cbfStatusFileCompletionTime": {
                            "type": "string",
                            "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                            "x-yang-type": "yang:timestamp"
                          },
                          "cbfStatusFileEntryStatus": {
                            "type": "string",
                            "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatusFileTable": {
                    "cbfStatusFileEntry": [
                      {
                        "cbfDefineFileIndex": "1",
                        "cbfStatusFileIndex": 1,
                        "cbfStatusFileState": "up(1)",
                        "cbfStatusFileCompletionTime": "up(1)",
                        "cbfStatusFileEntryStatus": "up(1)"
                      },
                      {
                        "cbfDefineFileIndex": "2",
                        "cbfStatusFileIndex": 2,
                        "cbfStatusFileState": "up(1)",
                        "cbfStatusFileCompletionTime": "up(1)",
                        "cbfStatusFileEntryStatus": "up(1)"
                      },
                      {
                        "cbfDefineFileIndex": "3",
                        "cbfStatusFileIndex": 3,
                        "cbfStatusFileState": "up(1)",
                        "cbfStatusFileCompletionTime": "up(1)",
                        "cbfStatusFileEntryStatus": "up(1)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatusFileTable/cbfStatusFileEntry": {
      "get": {
        "summary": "Get cbfStatusFileEntry list",
        "description": "Retrieve list of cbfStatusFileEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "cbfStatusFileEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "string",
                        "description": "cbfDefineFileIndex",
                        "x-yang-type": "leafref"
                      },
                      "cbfStatusFileIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfStatusFileState": {
                        "type": "string",
                        "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                      },
                      "cbfStatusFileCompletionTime": {
                        "type": "string",
                        "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "cbfStatusFileEntryStatus": {
                        "type": "string",
                        "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatusFileEntry": [
                    {
                      "cbfDefineFileIndex": "example-string",
                      "cbfStatusFileIndex": 1,
                      "cbfStatusFileState": "up(1)",
                      "cbfStatusFileCompletionTime": "up(1)",
                      "cbfStatusFileEntryStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatusFileTable/cbfStatusFileEntry={cbfDefineFileIndex cbfStatusFileIndex}": {
      "get": {
        "summary": "Get cbfStatusFileEntry entry",
        "description": "Retrieve specific cbfStatusFileEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex cbfStatusFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfStatusFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusFileState": {
                      "type": "string",
                      "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                    },
                    "cbfStatusFileCompletionTime": {
                      "type": "string",
                      "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "cbfStatusFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatusFileEntry": {
                    "cbfDefineFileIndex": "example-string",
                    "cbfStatusFileIndex": 1,
                    "cbfStatusFileState": "up(1)",
                    "cbfStatusFileCompletionTime": "up(1)",
                    "cbfStatusFileEntryStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineFileEntry": {
      "get": {
        "summary": "Get cbfDefineFileEntry list",
        "description": "Retrieve list of cbfDefineFileEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "cbfDefineFileEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineFileName": {
                        "type": "string",
                        "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                        "x-yang-type": "snmpv2-tc:DisplayString"
                      },
                      "cbfDefineFileStorage": {
                        "type": "string",
                        "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                      },
                      "cbfDefineFileFormat": {
                        "type": "string",
                        "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                      },
                      "cbfDefineFileNow": {
                        "type": "string",
                        "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                      },
                      "cbfDefineFileEntryStatus": {
                        "type": "string",
                        "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "cbfDefineFileNotifyOnCompletion": {
                        "type": "boolean",
                        "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineFileEntry": [
                    {
                      "cbfDefineFileIndex": 1,
                      "cbfDefineFileName": "interface-1",
                      "cbfDefineFileStorage": "example-string",
                      "cbfDefineFileFormat": "example-string",
                      "cbfDefineFileNow": "example-string",
                      "cbfDefineFileEntryStatus": "up(1)",
                      "cbfDefineFileNotifyOnCompletion": true
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineFileEntry={cbfDefineFileIndex}": {
      "get": {
        "summary": "Get cbfDefineFileEntry entry",
        "description": "Retrieve specific cbfDefineFileEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineFileName": {
                      "type": "string",
                      "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                      "x-yang-type": "snmpv2-tc:DisplayString"
                    },
                    "cbfDefineFileStorage": {
                      "type": "string",
                      "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                    },
                    "cbfDefineFileFormat": {
                      "type": "string",
                      "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                    },
                    "cbfDefineFileNow": {
                      "type": "string",
                      "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                    },
                    "cbfDefineFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineFileNotifyOnCompletion": {
                      "type": "boolean",
                      "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineFileEntry": {
                    "cbfDefineFileIndex": 1,
                    "cbfDefineFileName": "interface-1",
                    "cbfDefineFileStorage": "example-string",
                    "cbfDefineFileFormat": "example-string",
                    "cbfDefineFileNow": "example-string",
                    "cbfDefineFileEntryStatus": "up(1)",
                    "cbfDefineFileNotifyOnCompletion": true
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineObjectEntry": {
      "get": {
        "summary": "Get cbfDefineObjectEntry list",
        "description": "Retrieve list of cbfDefineObjectEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "string",
                        "description": "cbfDefineFileIndex",
                        "x-yang-type": "leafref"
                      },
                      "cbfDefineObjectIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineObjectClass": {
                        "type": "string",
                        "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                      },
                      "cbfDefineObjectID": {
                        "type": "string",
                        "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "cbfDefineObjectEntryStatus": {
                        "type": "string",
                        "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "cbfDefineObjectTableInstance": {
                        "type": "string",
                        "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "cbfDefineObjectNumEntries": {
                        "type": "integer",
                        "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfDefineObjectLastPolledInst": {
                        "type": "string",
                        "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                        "x-yang-type": "yang:object-identifier-128"
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineObjectEntry": [
                    {
                      "cbfDefineFileIndex": "example-string",
                      "cbfDefineObjectIndex": 1,
                      "cbfDefineObjectClass": "example-string",
                      "cbfDefineObjectID": "example-string",
                      "cbfDefineObjectEntryStatus": "up(1)",
                      "cbfDefineObjectTableInstance": "example-string",
                      "cbfDefineObjectNumEntries": 0,
                      "cbfDefineObjectLastPolledInst": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfDefineObjectEntry={cbfDefineFileIndex cbfDefineObjectIndex}": {
      "get": {
        "summary": "Get cbfDefineObjectEntry entry",
        "description": "Retrieve specific cbfDefineObjectEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex cbfDefineObjectIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfDefineObjectIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectClass": {
                      "type": "string",
                      "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                    },
                    "cbfDefineObjectID": {
                      "type": "string",
                      "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineObjectTableInstance": {
                      "type": "string",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectNumEntries": {
                      "type": "integer",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectLastPolledInst": {
                      "type": "string",
                      "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                      "x-yang-type": "yang:object-identifier-128"
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfDefineObjectEntry": {
                    "cbfDefineFileIndex": "example-string",
                    "cbfDefineObjectIndex": 1,
                    "cbfDefineObjectClass": "example-string",
                    "cbfDefineObjectID": "example-string",
                    "cbfDefineObjectEntryStatus": "up(1)",
                    "cbfDefineObjectTableInstance": "example-string",
                    "cbfDefineObjectNumEntries": 0,
                    "cbfDefineObjectLastPolledInst": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatusFileEntry": {
      "get": {
        "summary": "Get cbfStatusFileEntry list",
        "description": "Retrieve list of cbfStatusFileEntry entries from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "cbfStatusFileEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "cbfDefineFileIndex": {
                        "type": "string",
                        "description": "cbfDefineFileIndex",
                        "x-yang-type": "leafref"
                      },
                      "cbfStatusFileIndex": {
                        "type": "integer",
                        "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "cbfStatusFileState": {
                        "type": "string",
                        "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                      },
                      "cbfStatusFileCompletionTime": {
                        "type": "string",
                        "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "cbfStatusFileEntryStatus": {
                        "type": "string",
                        "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatusFileEntry": [
                    {
                      "cbfDefineFileIndex": "example-string",
                      "cbfStatusFileIndex": 1,
                      "cbfStatusFileState": "up(1)",
                      "cbfStatusFileCompletionTime": "up(1)",
                      "cbfStatusFileEntryStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-BULK-FILE-MIB:cbfStatusFileEntry={cbfDefineFileIndex cbfStatusFileIndex}": {
      "get": {
        "summary": "Get cbfStatusFileEntry entry",
        "description": "Retrieve specific cbfStatusFileEntry entry by key from MIB",
        "tags": [
          "CISCO-BULK-FILE-MIB"
        ],
        "parameters": [
          {
            "name": "cbfDefineFileIndex cbfStatusFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfStatusFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusFileState": {
                      "type": "string",
                      "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                    },
                    "cbfStatusFileCompletionTime": {
                      "type": "string",
                      "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "cbfStatusFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "CISCO-BULK-FILE-MIB:cbfStatusFileEntry": {
                    "cbfDefineFileIndex": "example-string",
                    "cbfStatusFileIndex": 1,
                    "cbfStatusFileState": "up(1)",
                    "cbfStatusFileCompletionTime": "up(1)",
                    "cbfStatusFileEntryStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "CISCO-BULK-FILE-MIB_CISCO-BULK-FILE-MIB": {
        "type": "object",
        "description": "CISCO-BULK-FILE-MIB",
        "properties": {
          "cbfDefineFileEntry": {
            "type": "array",
            "description": "cbfDefineFileEntry",
            "items": {
              "type": "object",
              "properties": {
                "cbfDefineFileIndex": {
                  "type": "integer",
                  "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "cbfDefineFileName": {
                  "type": "string",
                  "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                  "x-yang-type": "snmpv2-tc:DisplayString"
                },
                "cbfDefineFileStorage": {
                  "type": "string",
                  "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                },
                "cbfDefineFileFormat": {
                  "type": "string",
                  "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                },
                "cbfDefineFileNow": {
                  "type": "string",
                  "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                },
                "cbfDefineFileEntryStatus": {
                  "type": "string",
                  "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                },
                "cbfDefineFileNotifyOnCompletion": {
                  "type": "boolean",
                  "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                }
              }
            }
          },
          "cbfDefineObjectEntry": {
            "type": "array",
            "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
            "items": {
              "type": "object",
              "properties": {
                "cbfDefineFileIndex": {
                  "type": "string",
                  "description": "cbfDefineFileIndex",
                  "x-yang-type": "leafref"
                },
                "cbfDefineObjectIndex": {
                  "type": "integer",
                  "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "cbfDefineObjectClass": {
                  "type": "string",
                  "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                },
                "cbfDefineObjectID": {
                  "type": "string",
                  "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                  "x-yang-type": "yang:object-identifier-128"
                },
                "cbfDefineObjectEntryStatus": {
                  "type": "string",
                  "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                },
                "cbfDefineObjectTableInstance": {
                  "type": "string",
                  "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                  "x-yang-type": "yang:object-identifier-128"
                },
                "cbfDefineObjectNumEntries": {
                  "type": "integer",
                  "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "cbfDefineObjectLastPolledInst": {
                  "type": "string",
                  "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                  "x-yang-type": "yang:object-identifier-128"
                }
              }
            }
          },
          "cbfStatusFileEntry": {
            "type": "array",
            "description": "cbfStatusFileEntry",
            "items": {
              "type": "object",
              "properties": {
                "cbfDefineFileIndex": {
                  "type": "string",
                  "description": "cbfDefineFileIndex",
                  "x-yang-type": "leafref"
                },
                "cbfStatusFileIndex": {
                  "type": "integer",
                  "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "cbfStatusFileState": {
                  "type": "string",
                  "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                },
                "cbfStatusFileCompletionTime": {
                  "type": "string",
                  "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                  "x-yang-type": "yang:timestamp"
                },
                "cbfStatusFileEntryStatus": {
                  "type": "string",
                  "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                }
              }
            }
          },
          "cbfDefine": {
            "type": "object",
            "description": "The maximum number of file definitions this system\n          can hold in cbfDefineFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
            "properties": {
              "cbfDefineMaxFiles": {
                "type": "integer",
                "description": "The maximum number of file definitions this system\n          can hold in cbfDefineFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineFiles": {
                "type": "integer",
                "description": "The current number of file definitions in cbfDefineFileTable.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineHighFiles": {
                "type": "integer",
                "description": "The maximum value of cbfDefineFiles since system \n          initialization.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineFilesRefused": {
                "type": "integer",
                "description": "The number of attempts to create a file definition that\n          failed due to exceeding cbfDefineMaxFiles.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineMaxObjects": {
                "type": "integer",
                "description": "The maximum total number of object selections to go with\n          file definitions this system, that is, the total number\n          of objects this system can hold in cbfDefineObjectTable.  A\n          value of 0 indicates no configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number does not disturb existing entries.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineObjects": {
                "type": "integer",
                "description": "The current number of object selections in \n          cbfDefineObjectTable.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineHighObjects": {
                "type": "integer",
                "description": "The maximum value of cbfDefineObjects since system \n          initialization.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfDefineObjectsRefused": {
                "type": "integer",
                "description": "The number of attempts to create an object selection that\n          failed due to exceeding cbfDefineMaxObjects.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "cbfStatus": {
            "type": "object",
            "description": "cbfStatus",
            "properties": {
              "cbfStatusMaxFiles": {
                "type": "integer",
                "description": "The maximum number of file statuses this system\n          can hold in cbfStatusFileTable.  A value of 0 indicates no\n          configured limit.\n          \n          This object may be read-only on some systems.\n          \n          Changing this number deletes the oldest finished entries until\n          the new limit is satisfied.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfStatusFiles": {
                "type": "integer",
                "description": "The current number of file statuses in cbfStatusFileTable.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfStatusHighFiles": {
                "type": "integer",
                "description": "The maximum value of cbfStatusFiles since system \n          initialization.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "cbfStatusFilesBumped": {
                "type": "integer",
                "description": "The number times the oldest entry was deleted due to exceeding\n          cbfStatusMaxFiles.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "cbfDefineFileTable": {
            "type": "object",
            "description": "A table of bulk file definition and creation controls.",
            "properties": {
              "cbfDefineFileEntry": {
                "type": "array",
                "description": "cbfDefineFileEntry",
                "items": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineFileName": {
                      "type": "string",
                      "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
                      "x-yang-type": "snmpv2-tc:DisplayString"
                    },
                    "cbfDefineFileStorage": {
                      "type": "string",
                      "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
                    },
                    "cbfDefineFileFormat": {
                      "type": "string",
                      "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
                    },
                    "cbfDefineFileNow": {
                      "type": "string",
                      "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
                    },
                    "cbfDefineFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineFileNotifyOnCompletion": {
                      "type": "boolean",
                      "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
                    }
                  }
                }
              }
            }
          },
          "cbfDefineObjectTable": {
            "type": "object",
            "description": "A table of objects to go in bulk files.",
            "properties": {
              "cbfDefineObjectEntry": {
                "type": "array",
                "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
                "items": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfDefineObjectIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectClass": {
                      "type": "string",
                      "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
                    },
                    "cbfDefineObjectID": {
                      "type": "string",
                      "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectEntryStatus": {
                      "type": "string",
                      "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "cbfDefineObjectTableInstance": {
                      "type": "string",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "cbfDefineObjectNumEntries": {
                      "type": "integer",
                      "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfDefineObjectLastPolledInst": {
                      "type": "string",
                      "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
                      "x-yang-type": "yang:object-identifier-128"
                    }
                  }
                }
              }
            }
          },
          "cbfStatusFileTable": {
            "type": "object",
            "description": "A table of bulk file status.",
            "properties": {
              "cbfStatusFileEntry": {
                "type": "array",
                "description": "cbfStatusFileEntry",
                "items": {
                  "type": "object",
                  "properties": {
                    "cbfDefineFileIndex": {
                      "type": "string",
                      "description": "cbfDefineFileIndex",
                      "x-yang-type": "leafref"
                    },
                    "cbfStatusFileIndex": {
                      "type": "integer",
                      "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "cbfStatusFileState": {
                      "type": "string",
                      "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
                    },
                    "cbfStatusFileCompletionTime": {
                      "type": "string",
                      "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "cbfStatusFileEntryStatus": {
                      "type": "string",
                      "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "CISCO-BULK-FILE-MIB_object-1": {
        "type": "object",
        "description": "object-1",
        "properties": {
          "cbfDefineFileIndex": {
            "type": "string",
            "description": "cbfDefineFileIndex",
            "x-yang-type": "leafref"
          },
          "cbfStatusFileIndex": {
            "type": "string",
            "description": "cbfStatusFileIndex",
            "x-yang-type": "leafref"
          },
          "cbfStatusFileState": {
            "type": "string",
            "description": "cbfStatusFileState",
            "x-yang-type": "leafref"
          }
        }
      },
      "CISCO-BULK-FILE-MIB_object-2": {
        "type": "object",
        "description": "object-2",
        "properties": {
          "cbfDefineFileIndex": {
            "type": "string",
            "description": "cbfDefineFileIndex",
            "x-yang-type": "leafref"
          },
          "cbfStatusFileIndex": {
            "type": "string",
            "description": "cbfStatusFileIndex",
            "x-yang-type": "leafref"
          },
          "cbfStatusFileCompletionTime": {
            "type": "string",
            "description": "cbfStatusFileCompletionTime",
            "x-yang-type": "leafref"
          }
        }
      },
      "CISCO-BULK-FILE-MIB_cbfDefineFileEntry": {
        "type": "array",
        "description": "cbfDefineFileEntry",
        "items": {
          "type": "object",
          "properties": {
            "cbfDefineFileIndex": {
              "type": "integer",
              "description": "An arbitrary integer to uniquely identify this entry.  To\n            create an entry a management application should pick a\n            random number.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "cbfDefineFileName": {
              "type": "string",
              "description": "The file name which is to be created.\n            \n            Explicit device or path choices in the value of this object\n            override cbfDefineFileStorage.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "cbfDefineFileStorage": {
              "type": "string",
              "description": "The type of file storage to use:\n            \n            ephemeral        data exists in small amounts until read\n            volatile        data exists in volatile memory\n            permanent        data survives reboot\n            \n            An ephemeral file is suitable to be read only one time.\n            \n            Note that this value is taken as advisory and may be overridden\n            by explicit device or path choices in cbfDefineFile.\n            \n            A given system may support any or all of these."
            },
            "cbfDefineFileFormat": {
              "type": "string",
              "description": "The format of the data in the file:\n            \n            StandardBER        standard SNMP ASN.1 BER\n            bulkBinary        a binary format specified with this MIB\n            bulkASCII        a human-readable form of bulkBinary\n            variantBERWithCksum ASN.1 BER encoding with checksum\n            variantBinWithCksum a binary format with checksum\n            \n                A given system may support any or all of these."
            },
            "cbfDefineFileNow": {
              "type": "string",
              "description": "The control to cause file creation.  The only values that can\n            be set are 'create' and 'forcedCreate'. These can be set only \n            when the value is 'ready'.  Setting it to 'create' begins a \n            file creation and creates a corresponding entry in \n            cbfStatusFileTable. The system may choose to use an already \n            existing copy of the file instead of creating a new one. This\n            may happen if there has been no configuration change on the \n            system and a request to recreate the file is received. \n            Setting this object to 'forcedCreate' forces the system to \n            create a new copy of the file.\n            \n            The value is 'notActve' as long as cbfDefineFileEntryStatus or\n            any corresponding cbfDefineObjectEntryStatus is not active.\n            \n            When cbfDefineFileEntryStatus becomes active and all\n            corresponding cbfDefineObjectEntryStatuses are active this \n            object automatically goes to 'ready'."
            },
            "cbfDefineFileEntryStatus": {
              "type": "string",
              "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineFileEntry.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "cbfDefineFileNotifyOnCompletion": {
              "type": "boolean",
              "description": "This controls the cbfDefineFileCompletion notification.\n            \n            If true, cbfDefineFileCompletion notification\n            will be generated. It is the responsibility of the \n            management entity to ensure that the SNMP administrative \n            model is configured in such a way as to allow the \n            notification to be delivered."
            }
          }
        }
      },
      "CISCO-BULK-FILE-MIB_cbfDefineObjectEntry": {
        "type": "array",
        "description": "Information about one object for a particular file.\n          \n          An application uses cbfDefineObjectEntryStatus to create entries\n          in this table in correspondence with entries in\n          cbfDefineFileTable, which must be created first.\n          \n          Entries in this table may not be changed, created or deleted\n          while the corresponding value of cbfDefineFileNow is 'running'.",
        "items": {
          "type": "object",
          "properties": {
            "cbfDefineFileIndex": {
              "type": "string",
              "description": "cbfDefineFileIndex",
              "x-yang-type": "leafref"
            },
            "cbfDefineObjectIndex": {
              "type": "integer",
              "description": "An arbitrary integer to uniquely identify this entry.\n            \n            The numeric order of the entries controls the order of\n            the objects in the file.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "cbfDefineObjectClass": {
              "type": "string",
              "description": "The meaning of each object class is given below:\n            \n            object          a single MIB object is retrieved.\n            \n            lexicalTable    an entire table or partial table\n                            is retrieved in lexical order of rows.\n            \n            leastCpuTable   an entire table is retrieved with\n                            lowest CPU utilization.\n                            Lexical ordering of rows may not be \n                            maintained and is dependent upon \n                            individual MIB implementation."
            },
            "cbfDefineObjectID": {
              "type": "string",
              "description": "The object identifier of a MIB object to be included in\n            the file.\n            \n            If cbfDefineObjectClass is 'object' this must be a full OID,\n            including all instance information.\n            \n            If cbfDefineObjectClass is 'lexicalTable' or 'leastCpuTable'\n            this must be the OID of the table-defining SEQUENCE OF\n            registration point.",
              "x-yang-type": "yang:object-identifier-128"
            },
            "cbfDefineObjectEntryStatus": {
              "type": "string",
              "description": "The control that allows creation, modification, and deletion\n            of entries.  For detailed rules see the DESCRIPTION for\n            cbfDefineObjectEntry.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "cbfDefineObjectTableInstance": {
              "type": "string",
              "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the starting instance in the cbfDefineObjectID\n            table. The file created will have entries starting from\n            the lexicographically next instance of the OID represented\n            by this object. \n            \n            For Eg: \n            -------\n            \n                   Let us  assume we are polling ifTable and we\n                   have information till the second row(ifIndex.2). Now\n                   we may be interested in 10 rows lexically following\n                   the second row.\n                   \n                   So, we set cbfDefineObjectTableInstance as ifIndex.2 \n                   and cbfDefineObjectNumEntries as 10. \n            \n                   We will get information for the next 10 rows or\n                   if there are less than 10 populated rows, we will\n                   receive information till the end of the table is \n                   reached.\n            \n            The default value for this object is zeroDotZero.\n            \n            If this object has the value of zeroDotZero and \n            cbfDefineObjectNumEntries has value 0, then the whole\n            table(represented by cbfDefineObjectID) is retrieved.\n            \n            If this object has the value of zeroDotZero,  \n            cbfDefineObjectNumEntries has value n (>0) and there are \n            m(>0) entries in the table(represented by cbfDefineObjectID)\n            then the first n entries in the table are retrieved if n < m. \n            If n >= m, then the whole table is retrieved.\n            \n            When the value of cbfDefineObjectNumEntries is 0, \n            it means all the entries in the table(represented \n            by cbfDefineObjectID) which lexicographically follow \n            cbfDefineObjectTableInstance are retrieved.\n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.",
              "x-yang-type": "yang:object-identifier-128"
            },
            "cbfDefineObjectNumEntries": {
              "type": "integer",
              "description": "If cbfDefineObjectClass is 'lexicalTable', then this object\n            represents the maximum number of entries which will be \n            populated in the file starting from the lexicographically\n            next instance of the OID represented by \n            cbfDefineObjectTableInstance. \n            \n            This object is irrelevent if cbfDefineObjectClass is not\n            'lexicalTable'.\n            \n            Refer to the description of cbfDefineObjectTableInstance for\n            examples and different scenarios relating to this object.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "cbfDefineObjectLastPolledInst": {
              "type": "string",
              "description": "This object represents the last polled instance in the\n            table.\n            \n            The value represented by this object will be relevent only\n            if the corresponding cbfStatusFileState is emptied(3) for \n            ephemeral files or ready(2) for volatile or permanent files.\n            \n            A value of zeroDotZero indicates an absence of last polled \n            object.\n            \n            An NMS can use the value of this object and populate the\n            cbfDefineObjectTableInstance to retrieve a contiguous set\n            of rows in a table.",
              "x-yang-type": "yang:object-identifier-128"
            }
          }
        }
      },
      "CISCO-BULK-FILE-MIB_cbfStatusFileEntry": {
        "type": "array",
        "description": "cbfStatusFileEntry",
        "items": {
          "type": "object",
          "properties": {
            "cbfDefineFileIndex": {
              "type": "string",
              "description": "cbfDefineFileIndex",
              "x-yang-type": "leafref"
            },
            "cbfStatusFileIndex": {
              "type": "integer",
              "description": "An arbitrary integer to uniquely identify this file.\n            \n            The numeric order of the entries implies the creation\n            order of the files.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "cbfStatusFileState": {
              "type": "string",
              "description": "The file state:\n            \n            running    data is being written to the file\n            ready      the file is ready to be read\n            emptied    an ephemeral file was successfully consumed\n            noSpace    no data due to insufficient file space\n            badName    no data due to a name or path problem\n            writeErr   no data due to fatal file write error\n            noMem      no data due to insufficient dynamic memory\n            buffErr    implementation buffer too small\n            aborted    short terminated by operator command\n            \n            Only the 'ready' state implies that the file is available\n            for transfer.\n            \n            The disposition of files after an error is implementation\n            and file-syste specific."
            },
            "cbfStatusFileCompletionTime": {
              "type": "string",
              "description": "The value of sysUpTime when the creation attempt completed.\n            A value of 0 indicates not complete.  For ephemeral files this\n            is the time when cbfStatusFileState goes to 'emptied'.  For\n            others this is the time when the state leaves 'running'.",
              "x-yang-type": "yang:timestamp"
            },
            "cbfStatusFileEntryStatus": {
              "type": "string",
              "description": "The control that allows deletion of entries. For detailed rules\n            see the DESCRIPTION for cbfStatusFileEntry.\n            \n            This object may not be set to any value other than 'destroy'.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "CISCO-BULK-FILE-MIB",
      "description": "MIB operations for CISCO-BULK-FILE-MIB"
    }
  ]
}