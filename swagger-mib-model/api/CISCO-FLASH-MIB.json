{
  "openapi": "3.0.0",
  "info": {
    "title": "CISCO-FLASH-MIB MIB API",
    "version": "1.0.0",
    "description": "This MIB provides for the management of Cisco\n    Flash Devices.\n\n\u26a0\ufe0f **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/CISCO-FLASH-MIB:ciscoFlashDevice": {
      "get": {
        "summary": "Get ciscoFlashDevice data",
        "description": "Retrieve ciscoFlashDevice operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDevice"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCfg": {
      "get": {
        "summary": "Get ciscoFlashCfg data",
        "description": "Retrieve ciscoFlashCfg operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCfg"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashDeviceTable": {
      "get": {
        "summary": "Get ciscoFlashDeviceTable data",
        "description": "Retrieve ciscoFlashDeviceTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDeviceTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashDeviceTable/ciscoFlashDeviceEntry": {
      "get": {
        "summary": "Get ciscoFlashDeviceEntry list",
        "description": "Retrieve list of ciscoFlashDeviceEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDeviceEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashDeviceTable/ciscoFlashDeviceEntry={ciscoFlashDeviceIndex}": {
      "get": {
        "summary": "Get ciscoFlashDeviceEntry entry",
        "description": "Retrieve specific ciscoFlashDeviceEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDeviceEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashChipTable": {
      "get": {
        "summary": "Get ciscoFlashChipTable data",
        "description": "Retrieve ciscoFlashChipTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashChipTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashChipTable/ciscoFlashChipEntry": {
      "get": {
        "summary": "Get ciscoFlashChipEntry list",
        "description": "Retrieve list of ciscoFlashChipEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashChipEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashChipTable/ciscoFlashChipEntry={ciscoFlashDeviceIndex ciscoFlashChipIndex}": {
      "get": {
        "summary": "Get ciscoFlashChipEntry entry",
        "description": "Retrieve specific ciscoFlashChipEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashChipIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashChipEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitionTable": {
      "get": {
        "summary": "Get ciscoFlashPartitionTable data",
        "description": "Retrieve ciscoFlashPartitionTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitionTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitionTable/ciscoFlashPartitionEntry": {
      "get": {
        "summary": "Get ciscoFlashPartitionEntry list",
        "description": "Retrieve list of ciscoFlashPartitionEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitionEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitionTable/ciscoFlashPartitionEntry={ciscoFlashDeviceIndex ciscoFlashPartitionIndex}": {
      "get": {
        "summary": "Get ciscoFlashPartitionEntry entry",
        "description": "Retrieve specific ciscoFlashPartitionEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashPartitionIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitionEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileTable": {
      "get": {
        "summary": "Get ciscoFlashFileTable data",
        "description": "Retrieve ciscoFlashFileTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileTable/ciscoFlashFileEntry": {
      "get": {
        "summary": "Get ciscoFlashFileEntry list",
        "description": "Retrieve list of ciscoFlashFileEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileTable/ciscoFlashFileEntry={ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex}": {
      "get": {
        "summary": "Get ciscoFlashFileEntry entry",
        "description": "Retrieve specific ciscoFlashFileEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileByTypeTable": {
      "get": {
        "summary": "Get ciscoFlashFileByTypeTable data",
        "description": "Retrieve ciscoFlashFileByTypeTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileByTypeTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileByTypeTable/ciscoFlashFileByTypeEntry": {
      "get": {
        "summary": "Get ciscoFlashFileByTypeEntry list",
        "description": "Retrieve list of ciscoFlashFileByTypeEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileByTypeEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileByTypeTable/ciscoFlashFileByTypeEntry={ciscoFlashFileType ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex}": {
      "get": {
        "summary": "Get ciscoFlashFileByTypeEntry entry",
        "description": "Retrieve specific ciscoFlashFileByTypeEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashFileType ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileByTypeEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable": {
      "get": {
        "summary": "Get ciscoFlashCopyTable data",
        "description": "Retrieve ciscoFlashCopyTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCopyTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashPartitioningTable": {
      "get": {
        "summary": "Get ciscoFlashPartitioningTable data",
        "description": "Retrieve ciscoFlashPartitioningTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashPartitioningTable/ciscoFlashPartitioningEntry": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry list",
        "description": "Retrieve list of ciscoFlashPartitioningEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashPartitioningTable/ciscoFlashPartitioningEntry={ciscoFlashPartitioningSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry entry",
        "description": "Retrieve specific ciscoFlashPartitioningEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashPartitioningSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashMiscOpTable": {
      "get": {
        "summary": "Get ciscoFlashMiscOpTable data",
        "description": "Retrieve ciscoFlashMiscOpTable operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashMiscOpTable/ciscoFlashMiscOpEntry": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry list",
        "description": "Retrieve list of ciscoFlashMiscOpEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashMiscOpTable/ciscoFlashMiscOpEntry={ciscoFlashMiscOpSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry entry",
        "description": "Retrieve specific ciscoFlashMiscOpEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashMiscOpSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashCopyEntry": {
      "get": {
        "summary": "Get ciscoFlashCopyEntry list",
        "description": "Retrieve list of ciscoFlashCopyEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCopyEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashCopyEntry={ciscoFlashCopySerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashCopyEntry entry",
        "description": "Retrieve specific ciscoFlashCopyEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashCopySerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCopyEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashPartitioningEntry": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry list",
        "description": "Retrieve list of ciscoFlashPartitioningEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashPartitioningEntry={ciscoFlashPartitioningSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry entry",
        "description": "Retrieve specific ciscoFlashPartitioningEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashPartitioningSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashMiscOpEntry": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry list",
        "description": "Retrieve list of ciscoFlashMiscOpEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyTable/ciscoFlashMiscOpEntry={ciscoFlashMiscOpSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry entry",
        "description": "Retrieve specific ciscoFlashMiscOpEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashMiscOpSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:object-1": {
      "get": {
        "summary": "Get object-1 data",
        "description": "Retrieve object-1 operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_object-1"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:object-2": {
      "get": {
        "summary": "Get object-2 data",
        "description": "Retrieve object-2 operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_object-2"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:object-3": {
      "get": {
        "summary": "Get object-3 data",
        "description": "Retrieve object-3 operational data from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_object-3"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashDeviceEntry": {
      "get": {
        "summary": "Get ciscoFlashDeviceEntry list",
        "description": "Retrieve list of ciscoFlashDeviceEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDeviceEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashDeviceEntry={ciscoFlashDeviceIndex}": {
      "get": {
        "summary": "Get ciscoFlashDeviceEntry entry",
        "description": "Retrieve specific ciscoFlashDeviceEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashDeviceEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashChipEntry": {
      "get": {
        "summary": "Get ciscoFlashChipEntry list",
        "description": "Retrieve list of ciscoFlashChipEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashChipEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashChipEntry={ciscoFlashDeviceIndex ciscoFlashChipIndex}": {
      "get": {
        "summary": "Get ciscoFlashChipEntry entry",
        "description": "Retrieve specific ciscoFlashChipEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashChipIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashChipEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitionEntry": {
      "get": {
        "summary": "Get ciscoFlashPartitionEntry list",
        "description": "Retrieve list of ciscoFlashPartitionEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitionEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitionEntry={ciscoFlashDeviceIndex ciscoFlashPartitionIndex}": {
      "get": {
        "summary": "Get ciscoFlashPartitionEntry entry",
        "description": "Retrieve specific ciscoFlashPartitionEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashPartitionIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitionEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileEntry": {
      "get": {
        "summary": "Get ciscoFlashFileEntry list",
        "description": "Retrieve list of ciscoFlashFileEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileEntry={ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex}": {
      "get": {
        "summary": "Get ciscoFlashFileEntry entry",
        "description": "Retrieve specific ciscoFlashFileEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileByTypeEntry": {
      "get": {
        "summary": "Get ciscoFlashFileByTypeEntry list",
        "description": "Retrieve list of ciscoFlashFileByTypeEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileByTypeEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashFileByTypeEntry={ciscoFlashFileType ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex}": {
      "get": {
        "summary": "Get ciscoFlashFileByTypeEntry entry",
        "description": "Retrieve specific ciscoFlashFileByTypeEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashFileType ciscoFlashDeviceIndex ciscoFlashPartitionIndex ciscoFlashFileIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashFileByTypeEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyEntry": {
      "get": {
        "summary": "Get ciscoFlashCopyEntry list",
        "description": "Retrieve list of ciscoFlashCopyEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCopyEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashCopyEntry={ciscoFlashCopySerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashCopyEntry entry",
        "description": "Retrieve specific ciscoFlashCopyEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashCopySerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashCopyEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitioningEntry": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry list",
        "description": "Retrieve list of ciscoFlashPartitioningEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashPartitioningEntry={ciscoFlashPartitioningSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashPartitioningEntry entry",
        "description": "Retrieve specific ciscoFlashPartitioningEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashPartitioningSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashPartitioningEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashMiscOpEntry": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry list",
        "description": "Retrieve list of ciscoFlashMiscOpEntry entries from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/CISCO-FLASH-MIB:ciscoFlashMiscOpEntry={ciscoFlashMiscOpSerialNumber}": {
      "get": {
        "summary": "Get ciscoFlashMiscOpEntry entry",
        "description": "Retrieve specific ciscoFlashMiscOpEntry entry by key from MIB",
        "tags": [
          "CISCO-FLASH-MIB"
        ],
        "parameters": [
          {
            "name": "ciscoFlashMiscOpSerialNumber",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/CISCO-FLASH-MIB_ciscoFlashMiscOpEntry"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "CISCO-FLASH-MIB_CISCO-FLASH-MIB": {
        "type": "object",
        "description": "Number of Flash devices supported by the system.\n          If the system does not support any Flash devices, this\n          MIB will not be loaded on that system. The value of this\n          object will therefore be atleast 1.",
        "properties": {
          "ciscoFlashDevicesSupported": {
            "type": "integer",
            "description": "Number of Flash devices supported by the system.\n          If the system does not support any Flash devices, this\n          MIB will not be loaded on that system. The value of this\n          object will therefore be atleast 1.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashCfgDevInsNotifEnable": {
            "type": "boolean",
            "description": "Specifies whether or not a notification should be\n          generated on the insertion of a Flash device.\n          \n          If the value of this object is 'true' then the\n          ciscoFlashDeviceInsertedNotif notification\n          will be generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashDeviceInsertedNotif notification\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notification to be delivered."
          },
          "ciscoFlashCfgDevRemNotifEnable": {
            "type": "boolean",
            "description": "Specifies whether or not a notification should be\n          generated on the removal of a Flash device.\n          \n          If the value of this object is 'true' then the\n          ciscoFlashDeviceRemovedNotif notification\n          will be generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashDeviceRemovedNotif notification\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notification to be delivered."
          },
          "ciscoFlashPartitionLowSpaceNotifEnable": {
            "type": "boolean",
            "description": "This object specifies whether or not a notification should be\n          generated when the free space falls below the threshold value on\n          a flash partition and on recovery from low space.\n          \n          If the value of this object is 'true' then\n          ciscoFlashPartitionLowSpaceNotif and\n          ciscoFlashPartitionLowSpaceRecoveryNotif notifications will be\n          generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashPartitionLowSpaceNotif  and\n          ciscoFlashPartitionLowSpaceRecoveryNotif notifications\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notifications to be delivered."
          },
          "ciscoFlashDeviceIndex": {
            "type": "string",
            "description": "ciscoFlashDeviceIndex",
            "x-yang-type": "leafref"
          },
          "ciscoFlashDeviceSize": {
            "type": "integer",
            "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            If the total size of the flash device is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashDeviceSizeExtended must be used to report the\n            flash device's size.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashDeviceMinPartitionSize": {
            "type": "string",
            "description": "ciscoFlashDeviceMinPartitionSize",
            "x-yang-type": "leafref"
          },
          "ciscoFlashDeviceMaxPartitions": {
            "type": "integer",
            "description": "Max number of partitions supported by the system for\n            this Flash device. Default will be 1, which actually\n            means that partitioning is not supported. Note that\n            this value will be defined by system limitations, not\n            by the flash device itself (for eg., the system may\n            impose a limit of 2 partitions even though the device\n            may be large enough to be partitioned into 4 based on\n            the smallest partition unit supported).\n            On systems that execute code out of Flash, partitioning\n            is a way of creating multiple file systems in the Flash\n            device so that writing into or erasing of one file system\n            can be done while executing code residing in another file\n            system.\n            For systems executing code out of DRAM, partitioning\n            gives a way of sub-dividing a large Flash device for\n            easier management of files.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashDevicePartitions": {
            "type": "integer",
            "description": "Flash device partitions actually present. Number of\n            partitions cannot exceed the minimum of\n            ciscoFlashDeviceMaxPartitions\n            and\n            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).\n            Will be equal to at least 1, the case where the partition\n            spans the entire device (actually no partitioning).\n            A partition will contain one or more minimum partition\n            units (where a minimum partition unit is defined by\n            ciscoFlashDeviceMinPartitionSize).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashDeviceChipCount": {
            "type": "integer",
            "description": "Total number of chips within the Flash device.\n            The purpose of this object is to provide information\n            upfront to a management station on how much chip info\n            to expect and possibly help double check the chip index\n            against an upper limit when randomly retrieving chip\n            info for a partition.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ciscoFlashDeviceName": {
            "type": "string",
            "description": "ciscoFlashDeviceName",
            "x-yang-type": "leafref"
          },
          "ciscoFlashDeviceDescr": {
            "type": "string",
            "description": "Description of a Flash device. The description is meant\n            to explain what the Flash device and its purpose is.\n            Current values are:\n              System flash - for the primary Flash used to store full\n                             system images.\n              Boot flash   - for the secondary Flash used to store\n                             bootstrap images.\n            The ciscoFlashDeviceDescr, ciscoFlashDeviceController\n            (if applicable), and ciscoFlashPhyEntIndex objects are\n            expected to collectively give all information about a\n            Flash device.\n            The device description will always be available for a\n            removable device, even when the device has been removed.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashDeviceController": {
            "type": "string",
            "description": "Flash device controller. The h/w card that actually\n            controls Flash read/write/erase. Relevant for the AGS+\n            systems where Flash may be controlled by the MC+, STR or\n            the ENVM cards, cards that may not actually contain the\n            Flash chips.\n            For systems that have removable PCMCIA flash cards that\n            are controlled by a PCMCIA controller chip, this object\n            may contain a description of that controller chip.\n            Where irrelevant (Flash is a direct memory mapped device\n            accessed directly by the main processor), this object will\n            have an empty (NULL) string.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashDeviceCard": {
            "type": "string",
            "description": "This object will point to an instance of a card entry\n            in the cardTable. The card entry will give details about\n            the card on which the Flash device is actually located.\n            For most systems, this is usually the main processor board.\n            On the AGS+ systems, Flash is located on a separate multibus\n            card such as the MC.\n            This object will therefore be used to essentially index\n            into cardTable to retrieve details about the card such as\n            cardDescr, cardSlotNumber, etc.",
            "x-yang-type": "snmpv2-tc:InstancePointer"
          },
          "ciscoFlashDeviceProgrammingJumper": {
            "type": "string",
            "description": "This object gives the state of a jumper (if present and can be\n            determined) that controls the programming voltage called Vpp\n            to the Flash device. Vpp is required for programming (erasing\n            and writing) Flash. For certain older technology chips it is\n            also required for identifying the chips (which in turn is\n            required to identify which programming algorithms to use;\n            different chips require different algorithms and commands).\n            The purpose of the jumper, on systems where it is available,\n            is to write protect a Flash device.\n            On most of the newer remote access routers, this jumper is\n            unavailable since users are not expected to visit remote sites\n            just to install and remove the jumpers when upgrading software\n            in the Flash device. The unknown(3) value will be returned for\n            such systems and can be interpreted to mean that a programming\n            jumper is not present or not required on those systems.\n            On systems where the programming jumper state can be read back\n            via a hardware register, the installed(1) or notInstalled(2)\n            value will be returned.\n            This object is expected to be used in conjunction with the\n            ciscoFlashPartitionStatus object whenever that object has\n            the readOnly(1) value. In such a case, this object will\n            indicate whether the programming jumper is a possible reason\n            for the readOnly state."
          },
          "ciscoFlashDeviceInitTime": {
            "type": "string",
            "description": "System time at which device was initialized.\n            For fixed devices, this will be the system time at\n            boot up.\n            For removable devices, it will be the time at which\n            the device was inserted, which may be boot up time,\n            or a later time (if device was inserted later).\n            If a device (fixed or removable) was repartitioned,\n            it will be the time of repartitioning.\n            The purpose of this object is to help a management\n            station determine if a removable device has been\n            changed. The application should retrieve this\n            object prior to any operation and compare with\n            the previously retrieved value.\n            Note that this time will not be real time but a\n            running time maintained by the system. This running\n            time starts from zero when the system boots up.\n            For a removable device that has been removed, this\n            value will be zero.",
            "x-yang-type": "yang:timestamp"
          },
          "ciscoFlashDeviceRemovable": {
            "type": "boolean",
            "description": "Whether Flash device is removable. Generally, only PCMCIA\n            Flash cards will be treated as removable. Socketed Flash\n            chips and Flash SIMM modules will not be treated as removable.\n            Simply put, only those Flash devices that can be inserted\n            or removed without opening the hardware casing will be\n            considered removable.\n            Further, removable Flash devices are expected to have\n            the necessary hardware support -\n              1. on-line removal and insertion\n              2. interrupt generation on removal or insertion."
          },
          "ciscoFlashPhyEntIndex": {
            "type": "string",
            "description": "This object indicates the physical entity index of a\n            physical entity in entPhysicalTable which the flash\n            device actually located.",
            "x-yang-type": "entity-mib:PhysicalIndexOrZero"
          },
          "ciscoFlashDeviceNameExtended": {
            "type": "string",
            "description": "ciscoFlashDeviceNameExtended",
            "x-yang-type": "leafref"
          },
          "ciscoFlashDeviceSizeExtended": {
            "type": "integer",
            "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            This object is a 64-bit version of ciscoFlashDeviceSize.",
            "minimum": 0
          },
          "ciscoFlashDeviceMinPartitionSizeExtended": {
            "type": "integer",
            "description": "This object provides the minimum partition size supported for\n            this device. This object is a 64-bit version of \n            ciscoFlashDeviceMinPatitionSize.",
            "minimum": 0
          },
          "ciscoFlashChipIndex": {
            "type": "integer",
            "description": "Chip sequence number within selected flash device.\n            Used to index within chip info table.\n            Value starts from 1 and should not be greater than\n            ciscoFlashDeviceChipCount for that device.\n            When retrieving chip information for chips within a\n            partition, the sequence number should lie between\n            ciscoFlashPartitionStartChip & ciscoFlashPartitionEndChip\n            (both inclusive).",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ciscoFlashChipCode": {
            "type": "string",
            "description": "Manufacturer and device code for a chip.\n            Lower byte will contain the device code.\n            Upper byte will contain the manufacturer code.\n            If a chip code is unknown because it could not\n            be queried out of the chip, the value of this\n            object will be 00:00.\n            Since programming algorithms differ from chip type to\n            chip type, this chip code should be used to determine\n            which algorithms to use (and thereby whether the chip\n            is supported in the first place).",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashChipDescr": {
            "type": "string",
            "description": "Flash chip name corresponding to the chip code.\n            The name will contain the manufacturer and the\n            chip type. It will be of the form :\n              Intel 27F008SA.\n            In the case where a chip code is unknown, this\n            object will be an empty (NULL) string.\n            In the case where the chip code is known but the\n            chip is not supported by the system, this object\n            will be an empty (NULL) string.\n            A management station is therefore expected to use the\n            chip code and the chip description in conjunction\n            to provide additional information whenever the\n            ciscoFlashPartitionStatus object has the readOnly(1)\n            value.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashChipWriteRetries": {
            "type": "integer",
            "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of write retries that were done in the chip.\n            If no writes have been done to Flash, the count\n            will be zero. Typically, a maximum of 25 retries are\n            done on a single location before flagging a write\n            error.\n            A management station is expected to get this object\n            for each chip in a partition after a write failure\n            in that partition. To keep a track of retries for\n            a given write operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any write operation.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashChipEraseRetries": {
            "type": "integer",
            "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of erase retries that were done in the chip.\n            Typically, a maximum of 2000 retries are done in a\n            single erase zone (which may be a full chip or a\n            portion, depending on the chip technology) before\n            flagging an erase error.\n            A management station is expected to get this object\n            for each chip in a partition after an erase failure\n            in that partition. To keep a track of retries for\n            a given erase operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any erase operation.\n            Note that erase may be done through an independent\n            command, or through a copy-to-flash command.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashChipMaxWriteRetries": {
            "type": "integer",
            "description": "The maximum number of write retries done at any\n            single location before declaring a write failure.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashChipMaxEraseRetries": {
            "type": "integer",
            "description": "The maximum number of erase retries done within\n            an erase sector before declaring an erase failure.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashPartitionIndex": {
            "type": "string",
            "description": "ciscoFlashPartitionIndex",
            "x-yang-type": "leafref"
          },
          "ciscoFlashPartitionStartChip": {
            "type": "integer",
            "description": "Chip sequence number of first chip in partition.\n            Used as an index into the chip table.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ciscoFlashPartitionEndChip": {
            "type": "integer",
            "description": "Chip sequence number of last chip in partition.\n            Used as an index into the chip table.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ciscoFlashPartitionSize": {
            "type": "integer",
            "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            If the size of the flash partition is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionSizeExtended must be used to report the\n            flash partition's size.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashPartitionFreeSpace": {
            "type": "integer",
            "description": "Free space within a Flash partition.\n            Note that the actual size of a file in Flash includes\n            a small overhead that represents the file system's\n            file header.\n            Certain file systems may also have a partition or\n            device header overhead to be considered when\n            computing the free space.\n            Free space will be computed as total partition size\n            less size of all existing files (valid/invalid/deleted\n            files and including file header of each file),\n            less size of any partition header, less size of\n            header of next file to be copied in. In short, this\n            object will give the size of the largest file that\n            can be copied in. The management entity will not be\n            expected to know or use any overheads such as file\n            and partition header lengths, since such overheads\n            may vary from file system to file system.\n            Deleted files in Flash do not free up space.\n            A partition may have to be erased in order to reclaim\n            the space occupied by files.\n            \n            If the free space within a flash partition is greater than\n            the maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionFreeSpaceExtended\n            must be used to report the flash partition's free space.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashPartitionFileCount": {
            "type": "integer",
            "description": "Count of all files in a flash partition. Both\n            good and bad (deleted or invalid checksum) files\n            will be included in this count.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashPartitionChecksumAlgorithm": {
            "type": "string",
            "description": "Checksum algorithm identifier for checksum method\n            used by the file system. Normally, this would be\n            fixed for a particular file system. When a file\n            system writes a file to Flash, it checksums the\n            data written. The checksum then serves as a way\n            to validate the data read back whenever the file\n            is opened for reading.\n            Since there is no way, when using TFTP, to guarantee\n            that a network download has been error free (since\n            UDP checksums may not have been enabled), this\n            object together with the ciscoFlashFileChecksum\n            object provides a method for any management station\n            to regenerate the checksum of the original file\n            on the server and compare checksums to ensure that\n            the file download to Flash was error free.\n            simpleChecksum represents a simple 1s complement\n            addition of short word values. Other algorithm\n            values will be added as necessary."
          },
          "ciscoFlashPartitionStatus": {
            "type": "string",
            "description": "Flash partition status can be :\n            \n            * readOnly if device is not programmable either because\n            chips could not be recognized or an erroneous mismatch\n            of chips was detected. Chip recognition may fail either\n            because the chips are not supported by the system,\n            or because the Vpp voltage required to identify chips\n            has been disabled via the programming jumper.\n            The ciscoFlashDeviceProgrammingJumper, ciscoFlashChipCode,\n            and ciscoFlashChipDescr objects can be examined to get\n            more details on the cause of this status\n            * runFromFlash (RFF) if current image is running from\n            this partition.\n            The ciscoFlashPartitionUpgradeMethod object will then\n            indicate whether the Flash Load Helper can be used\n            to write a file to this partition or not.\n            \n            * readWrite if partition is programmable."
          },
          "ciscoFlashPartitionUpgradeMethod": {
            "type": "string",
            "description": "Flash partition upgrade method, ie., method by which\n            new files can be downloaded into the partition.\n            FLH stands for Flash Load Helper, a feature provided\n            on run-from-Flash systems for upgrading Flash. This\n            feature uses the bootstrap code in ROMs to help in\n            automatic download.\n            This object should be retrieved if the partition\n            status is runFromFlash(2).\n            If the partition status is readOnly(1), the upgrade\n            method would depend on the reason for the readOnly\n            status. For eg., it may simply be a matter of installing\n            the programming jumper, or it may require execution of a\n            later version of software that supports the Flash chips.\n            \n            unknown      -  the current system image does not know\n                            how Flash can be programmed. A possible\n                            method would be to reload the ROM image\n                            and perform the upgrade manually.\n            rxbootFLH    -  the Flash Load Helper is available to\n                            download files to Flash. A copy-to-flash\n                            command can be used and this system image\n                            will automatically reload the Rxboot image\n                            in ROM and direct it to carry out the\n                            download request.\n            direct       -  will be done directly by this image."
          },
          "ciscoFlashPartitionName": {
            "type": "string",
            "description": "ciscoFlashPartitionName",
            "x-yang-type": "leafref"
          },
          "ciscoFlashPartitionNeedErasure": {
            "type": "boolean",
            "description": "This object indicates whether a partition requires\n            erasure before any write operations can be done in it.\n            A management station should therefore retrieve this\n            object prior to attempting any write operation.\n            A partition requires erasure after it becomes full\n            free space left is less than or equal to the\n            (filesystem file header size).\n            A partition also requires erasure if the system does\n            not find the existence of any file system when it\n            boots up.\n            The partition may be erased explicitly through the\n            erase(5) command, or by using the copyToFlashWithErase(1)\n            command.\n            If a copyToFlashWithoutErase(2) command is issued\n            when this object has the TRUE value, the command\n            will fail."
          },
          "ciscoFlashPartitionFileNameLength": {
            "type": "integer",
            "description": "Maximum file name length supported by the file\n            system.\n            Max file name length will depend on the file\n            system implemented. Today, all file systems\n            support a max length of at least 48 bytes.\n            A management entity must use this object when\n            prompting a user for, or deriving the Flash file\n            name length.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ciscoFlashPartitionSizeExtended": {
            "type": "integer",
            "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            This object is a 64-bit version of ciscoFlashPartitionSize",
            "minimum": 0
          },
          "ciscoFlashPartitionFreeSpaceExtended": {
            "type": "string",
            "description": "ciscoFlashPartitionFreeSpaceExtended",
            "x-yang-type": "leafref"
          },
          "ciscoFlashPartitionLowSpaceNotifThreshold": {
            "type": "string",
            "description": "ciscoFlashPartitionLowSpaceNotifThreshold",
            "x-yang-type": "leafref"
          },
          "ciscoFlashFileIndex": {
            "type": "string",
            "description": "ciscoFlashFileIndex",
            "x-yang-type": "leafref"
          },
          "ciscoFlashFileSize": {
            "type": "integer",
            "description": "Size of the file in bytes. Note that this size does\n            not include the size of the filesystem file header.\n            File size will always be non-zero.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashFileChecksum": {
            "type": "string",
            "description": "File checksum stored in the file header. This\n            checksum is computed and stored when the file is\n            written into Flash. It serves to validate the data\n            written into Flash.\n            Whereas the system will generate and store the checksum\n            internally in hexadecimal form, this object will\n            provide the checksum in a string form.\n            The checksum will be available for all valid and\n            invalid-checksum files.",
            "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
          },
          "ciscoFlashFileStatus": {
            "type": "string",
            "description": "Status of a file.\n            A file could be explicitly deleted if the file system\n            supports such a user command facility. Alternately,\n            an existing good file would be automatically deleted\n            if another good file with the same name were copied in.\n            Note that deleted files continue to occupy prime\n            Flash real estate.\n            \n            A file is marked as having an invalid checksum if any\n            checksum mismatch was detected while writing or reading\n            the file. Incomplete files (files truncated either\n            because of lack of free space, or a network download\n            failure) are also written with a bad checksum and\n            marked as invalid."
          },
          "ciscoFlashFileName": {
            "type": "string",
            "description": "Flash file name as specified by the user copying in\n            the file. The name should not include the colon (:)\n            character as it is a special separator character used\n            to delineate the device name, partition name, and the\n            file name.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashFileType": {
            "type": "string",
            "description": "ciscoFlashFileType",
            "x-yang-type": "leafref"
          },
          "ciscoFlashFileDate": {
            "type": "string",
            "description": "The time at which this file was created.",
            "x-yang-type": "snmpv2-tc:DateAndTime"
          },
          "ciscoFlashFileByTypeSize": {
            "type": "integer",
            "description": "This object represents exactly the\n            same info as ciscoFlashFileSize\n            object in ciscoFlashFileTable.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashFileByTypeChecksum": {
            "type": "string",
            "description": "This object represents exactly the\n            same info as ciscoFlashFileChecksum\n            object in ciscoFlashFileTable.",
            "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
          },
          "ciscoFlashFileByTypeStatus": {
            "type": "string",
            "description": "This object represents exactly the\n            same info as ciscoFlashFileStatus\n            object in ciscoFlashFileTable."
          },
          "ciscoFlashFileByTypeName": {
            "type": "string",
            "description": "This object represents exactly the\n            same info as ciscoFlashFileName\n            object in ciscoFlashFileTable.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashFileByTypeDate": {
            "type": "string",
            "description": "This object represents exactly the\n            same info as ciscoFlashFileDate\n            object in ciscoFlashFileTable.",
            "x-yang-type": "snmpv2-tc:DateAndTime"
          },
          "ciscoFlashCopySerialNumber": {
            "type": "string",
            "description": "ciscoFlashCopySerialNumber",
            "x-yang-type": "leafref"
          },
          "ciscoFlashCopyCommand": {
            "type": "string",
            "description": "The copy command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the invalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            copyToFlashWithErase    Copy a file to flash; erase\n                                    flash before copy.\n                                    Use the TFTP or rcp protocol.\n            copyToFlashWithoutErase Copy a file to flash; do not\n                                    erase.\n                                    Note that this command will fail\n                                    if the PartitionNeedErasure\n                                    object specifies that the\n                                    partition being copied to needs\n                                    erasure.\n                                    Use the TFTP or rcp protocol.\n            copyFromFlash           Copy a file from flash using\n                                    the TFTP, rcp or lex protocol.\n                                    Note that the lex protocol\n                                    can only be used to copy to a\n                                    lex device.\n            copyFromFlhLog          Copy contents of FLH log to\n                                    server using TFTP protocol.\n            \n            \n            Command table           Parameters\n            copyToFlashWithErase    CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyToFlashWithoutErase CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlash           CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlhLog          CopyProtocol\n                                    CopyServerAddress\n                                    CopyDestinationName\n                                    CopyNotifyOnCompletion (opt)"
          },
          "ciscoFlashCopyProtocol": {
            "type": "string",
            "description": "The protocol to be used for any copy. Optional.\n            Will default to tftp if not specified.\n            \n            Since feature support depends on a software release,\n            version number within the release, platform, and\n            maybe the image type (subset type), a management\n            station would be expected to somehow determine\n            the protocol support for a command."
          },
          "ciscoFlashCopyServerAddress": {
            "type": "string",
            "description": "The server address to be used for any copy. Optional.\n            Will default to 'FFFFFFFF'H  (or 255.255.255.255).\n            \n            Since this object can just hold only IPv4 Transport\n            type, it is deprecated and replaced by\n            ciscoFlashCopyServerAddrRev1.",
            "format": "inet:ipv4-address"
          },
          "ciscoFlashCopySourceName": {
            "type": "string",
            "description": "Source file name, either in Flash or on a server,\n            depending on the type of copy command. Mandatory.\n            \n            For a copy from Flash:\n            File name must be of the form\n                    [device>:][:]\n            where  is a value obtained from FlashDeviceName,\n                     is obtained from FlashPartitionName\n                and  is the name of a file in Flash.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For a copy to Flash, the file name will be as per\n            the file naming conventions and path to the file on\n            the server.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashCopyDestinationName": {
            "type": "string",
            "description": "Destination file name.\n            \n            For a copy to Flash:\n            File name must be of the form\n                    {device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is any character string that does not have\n            embedded colon characters.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            If <file> is not specified, it will default to <file>\n            specified in ciscoFlashCopySourceName.\n            \n            For a copy from Flash via tftp or rcp, the file name will be\n            as per the file naming conventions and destination sub-directory\n            on the server. If not specified, <file> from the source\n            file name will be used.\n            For a copy from Flash via lex, this string will consist\n            of numeric characters specifying the interface on the\n            lex box that will receive the source flash image.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashPartitioningSerialNumber": {
            "type": "string",
            "description": "ciscoFlashPartitioningSerialNumber",
            "x-yang-type": "leafref"
          },
          "ciscoFlashPartitioningCommand": {
            "type": "string",
            "description": "The partitioning command to be executed. Mandatory.\n            If the command is unsupported, the\n            partitioningInvalidOperation\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            partition               Partition a Flash device.\n                                    All the prerequisites for\n                                    partitioning must be met for\n                                    this command to succeed.\n            \n            Command table           Parameters\n            1) partition            PartitioningDestinationName\n                                    PartitioningPartitionCount\n                                    PartitioningPartitionSizes (opt)\n                                    PartitioningNotifyOnCompletion (opt)"
          },
          "ciscoFlashPartitioningDestinationName": {
            "type": "string",
            "description": "Destination device name. This name will be the value\n            obtained from FlashDeviceName.\n            If the name is not specified, the default Flash device\n            will be assumed.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashPartitioningPartitionCount": {
            "type": "integer",
            "description": "This object is used to specify the number of\n            partitions to be created. Its value cannot exceed\n            the value of ciscoFlashDeviceMaxPartitions.\n            \n            To undo partitioning (revert to a single partition),\n            this object must have the value 1.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ciscoFlashPartitioningPartitionSizes": {
            "type": "string",
            "description": "This object is used to explicitly specify the size\n            of each partition to be created.\n            The size of each partition will be in units of\n            ciscoFlashDeviceMinPartitionSize.\n            The value of this object will be in the form:\n                    <part1>:<part2>...:<partn>\n            \n            If partition sizes are not specified, the system\n            will calculate default sizes based on the partition\n            count, the minimum partition size, and the device\n            size. Partition size need not be specified when\n            undoing partitioning (partition count is 1).\n            If partition sizes are specified, the number of\n            sizes specified must exactly match the partition\n            count. If not, the partitioning command will be\n            rejected with the invalidPartitionSizes error .",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashPartitioningStatus": {
            "type": "string",
            "description": "ciscoFlashPartitioningStatus",
            "x-yang-type": "leafref"
          },
          "ciscoFlashPartitioningNotifyOnCompletion": {
            "type": "boolean",
            "description": "Specifies whether or not a notification should be\n            generated on the completion of the partitioning operation.\n            If specified, ciscoFlashPartitioningCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
          },
          "ciscoFlashPartitioningTime": {
            "type": "string",
            "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
            "x-yang-type": "yang:timeticks"
          },
          "ciscoFlashPartitioningEntryStatus": {
            "type": "string",
            "description": "The status of this table entry.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "ciscoFlashMiscOpSerialNumber": {
            "type": "string",
            "description": "ciscoFlashMiscOpSerialNumber",
            "x-yang-type": "leafref"
          },
          "ciscoFlashMiscOpCommand": {
            "type": "string",
            "description": "The command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the miscOpInvalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command         Remarks\n            erase           Erase flash.\n            verify          Verify flash file checksum.\n            delete          Delete a file.\n            undelete        Revive a deleted file .\n                            Note that there are limits on\n                            the number of times a file can\n                            be deleted and undeleted. When\n                            this limit is exceeded, the\n                            system will return the appropriate\n                            error.\n            squeeze         Recover space occupied by\n                            deleted files. This command\n                            preserves the good files, erases\n                            out the file system, then restores\n                            the preserved good files.\n            format          Format a flash device.\n            \n            Command table   Parameters\n            erase           MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            verify          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            delete          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            undelete        MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            squeeze         MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            format          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)"
          },
          "ciscoFlashMiscOpDestinationName": {
            "type": "string",
            "description": "Destination file, or partition name.\n            File name must be of the form\n                    [device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is the name of a file in Flash.\n            While leading and/or trailing whitespaces are acceptable,\n            no whitespaces are allowed within the path itself.\n            \n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For an operation on a partition, eg., the erase\n            command, this object would specify the partition name\n            in the form:\n                    [device>:][<partition>:]",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "ciscoFlashMiscOpStatus": {
            "type": "string",
            "description": "ciscoFlashMiscOpStatus",
            "x-yang-type": "leafref"
          },
          "ciscoFlashMiscOpNotifyOnCompletion": {
            "type": "boolean",
            "description": "Specifies whether or not a notification should be\n            generated on the completion of an operation.\n            If specified, ciscoFlashMiscOpCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
          },
          "ciscoFlashMiscOpTime": {
            "type": "string",
            "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
            "x-yang-type": "yang:timeticks"
          },
          "ciscoFlashMiscOpEntryStatus": {
            "type": "string",
            "description": "The status of this table entry.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "ciscoFlashCopyStatus": {
            "type": "string",
            "description": "ciscoFlashCopyStatus",
            "x-yang-type": "leafref"
          },
          "ciscoFlashDevice": {
            "type": "object",
            "description": "Number of Flash devices supported by the system.\n          If the system does not support any Flash devices, this\n          MIB will not be loaded on that system. The value of this\n          object will therefore be atleast 1.",
            "properties": {
              "ciscoFlashDevicesSupported": {
                "type": "integer",
                "description": "Number of Flash devices supported by the system.\n          If the system does not support any Flash devices, this\n          MIB will not be loaded on that system. The value of this\n          object will therefore be atleast 1.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "ciscoFlashCfg": {
            "type": "object",
            "description": "ciscoFlashCfg",
            "properties": {
              "ciscoFlashCfgDevInsNotifEnable": {
                "type": "boolean",
                "description": "Specifies whether or not a notification should be\n          generated on the insertion of a Flash device.\n          \n          If the value of this object is 'true' then the\n          ciscoFlashDeviceInsertedNotif notification\n          will be generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashDeviceInsertedNotif notification\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notification to be delivered."
              },
              "ciscoFlashCfgDevRemNotifEnable": {
                "type": "boolean",
                "description": "Specifies whether or not a notification should be\n          generated on the removal of a Flash device.\n          \n          If the value of this object is 'true' then the\n          ciscoFlashDeviceRemovedNotif notification\n          will be generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashDeviceRemovedNotif notification\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notification to be delivered."
              },
              "ciscoFlashPartitionLowSpaceNotifEnable": {
                "type": "boolean",
                "description": "This object specifies whether or not a notification should be\n          generated when the free space falls below the threshold value on\n          a flash partition and on recovery from low space.\n          \n          If the value of this object is 'true' then\n          ciscoFlashPartitionLowSpaceNotif and\n          ciscoFlashPartitionLowSpaceRecoveryNotif notifications will be\n          generated.\n          \n          If the value of this object is 'false' then the\n          ciscoFlashPartitionLowSpaceNotif  and\n          ciscoFlashPartitionLowSpaceRecoveryNotif notifications\n          will not be generated.\n          \n          It is the responsibility of the management entity to\n          ensure that the SNMP administrative model is\n          configured in such a way as to allow the\n          notifications to be delivered."
              }
            }
          },
          "ciscoFlashDeviceTable": {
            "type": "object",
            "description": "ciscoFlashDeviceTable",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "integer",
                "description": "Flash device sequence number to index within the\n            table of initialized flash devices.\n            The lowest value should be 1. The highest should be\n            less than or equal to the value of the\n            ciscoFlashDevicesSupported object.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashDeviceSize": {
                "type": "integer",
                "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            If the total size of the flash device is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashDeviceSizeExtended must be used to report the\n            flash device's size.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashDeviceMinPartitionSize": {
                "type": "integer",
                "description": "This object will give the minimum partition size\n            supported for this device. For systems that execute code\n            directly out of Flash, the minimum partition size needs\n            to be the bank size. (Bank size is equal to the size of a\n            chip multiplied by the width of the device. In most cases,\n            the device width is 4 bytes, and so the bank size would be\n            four times the size of a chip). This has to be so because\n            all programming commands affect the operation of an\n            entire chip (in our case, an entire bank because all\n            operations are done on the entire width of the device)\n            even though the actual command may be localized to a small\n            portion of each chip. So when executing code out of Flash,\n            one needs to be able to write and erase some portion of\n            Flash without affecting the code execution.\n            For systems that execute code out of DRAM or ROM, it is\n            possible to partition Flash with a finer granularity (for\n            eg., at erase sector boundaries) if the system code supports\n            such granularity.\n            \n            This object will let a management entity know the\n            minimum partition size as defined by the system.\n            If the system does not support partitioning, the value\n            will be equal to the device size in ciscoFlashDeviceSize.\n            The maximum number of partitions that could be configured\n            will be equal to the minimum of\n            ciscoFlashDeviceMaxPartitions\n            and\n            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).\n            \n            If the total size of the flash device is greater than the\n            maximum value reportable by this object then this object should\n            report its maximum value(4,294,967,295) and\n            ciscoFlashDeviceMinPartitionSizeExtended must be used to report\n            the flash device's minimum partition size.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashDeviceMaxPartitions": {
                "type": "integer",
                "description": "Max number of partitions supported by the system for\n            this Flash device. Default will be 1, which actually\n            means that partitioning is not supported. Note that\n            this value will be defined by system limitations, not\n            by the flash device itself (for eg., the system may\n            impose a limit of 2 partitions even though the device\n            may be large enough to be partitioned into 4 based on\n            the smallest partition unit supported).\n            On systems that execute code out of Flash, partitioning\n            is a way of creating multiple file systems in the Flash\n            device so that writing into or erasing of one file system\n            can be done while executing code residing in another file\n            system.\n            For systems executing code out of DRAM, partitioning\n            gives a way of sub-dividing a large Flash device for\n            easier management of files.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashDevicePartitions": {
                "type": "integer",
                "description": "Flash device partitions actually present. Number of\n            partitions cannot exceed the minimum of\n            ciscoFlashDeviceMaxPartitions\n            and\n            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).\n            Will be equal to at least 1, the case where the partition\n            spans the entire device (actually no partitioning).\n            A partition will contain one or more minimum partition\n            units (where a minimum partition unit is defined by\n            ciscoFlashDeviceMinPartitionSize).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashDeviceChipCount": {
                "type": "integer",
                "description": "Total number of chips within the Flash device.\n            The purpose of this object is to provide information\n            upfront to a management station on how much chip info\n            to expect and possibly help double check the chip index\n            against an upper limit when randomly retrieving chip\n            info for a partition.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashDeviceName": {
                "type": "string",
                "description": "Flash device name. This name is used to refer to the\n            device within the system. Flash operations get directed\n            to a device based on this name.\n            The system has a concept of a default device.\n            This would be the primary or most used device in case of\n            multiple devices. The system directs an operation to the\n            default device whenever a device name is not specified.\n            The device name is therefore mandatory except when the\n            operation is being done on the default device, or,\n            the system supports only a single Flash device.\n            The device name will always be available for a\n            removable device, even when the device has been removed.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashDeviceDescr": {
                "type": "string",
                "description": "Description of a Flash device. The description is meant\n            to explain what the Flash device and its purpose is.\n            Current values are:\n              System flash - for the primary Flash used to store full\n                             system images.\n              Boot flash   - for the secondary Flash used to store\n                             bootstrap images.\n            The ciscoFlashDeviceDescr, ciscoFlashDeviceController\n            (if applicable), and ciscoFlashPhyEntIndex objects are\n            expected to collectively give all information about a\n            Flash device.\n            The device description will always be available for a\n            removable device, even when the device has been removed.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashDeviceController": {
                "type": "string",
                "description": "Flash device controller. The h/w card that actually\n            controls Flash read/write/erase. Relevant for the AGS+\n            systems where Flash may be controlled by the MC+, STR or\n            the ENVM cards, cards that may not actually contain the\n            Flash chips.\n            For systems that have removable PCMCIA flash cards that\n            are controlled by a PCMCIA controller chip, this object\n            may contain a description of that controller chip.\n            Where irrelevant (Flash is a direct memory mapped device\n            accessed directly by the main processor), this object will\n            have an empty (NULL) string.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashDeviceCard": {
                "type": "string",
                "description": "This object will point to an instance of a card entry\n            in the cardTable. The card entry will give details about\n            the card on which the Flash device is actually located.\n            For most systems, this is usually the main processor board.\n            On the AGS+ systems, Flash is located on a separate multibus\n            card such as the MC.\n            This object will therefore be used to essentially index\n            into cardTable to retrieve details about the card such as\n            cardDescr, cardSlotNumber, etc.",
                "x-yang-type": "snmpv2-tc:InstancePointer"
              },
              "ciscoFlashDeviceProgrammingJumper": {
                "type": "string",
                "description": "This object gives the state of a jumper (if present and can be\n            determined) that controls the programming voltage called Vpp\n            to the Flash device. Vpp is required for programming (erasing\n            and writing) Flash. For certain older technology chips it is\n            also required for identifying the chips (which in turn is\n            required to identify which programming algorithms to use;\n            different chips require different algorithms and commands).\n            The purpose of the jumper, on systems where it is available,\n            is to write protect a Flash device.\n            On most of the newer remote access routers, this jumper is\n            unavailable since users are not expected to visit remote sites\n            just to install and remove the jumpers when upgrading software\n            in the Flash device. The unknown(3) value will be returned for\n            such systems and can be interpreted to mean that a programming\n            jumper is not present or not required on those systems.\n            On systems where the programming jumper state can be read back\n            via a hardware register, the installed(1) or notInstalled(2)\n            value will be returned.\n            This object is expected to be used in conjunction with the\n            ciscoFlashPartitionStatus object whenever that object has\n            the readOnly(1) value. In such a case, this object will\n            indicate whether the programming jumper is a possible reason\n            for the readOnly state."
              },
              "ciscoFlashDeviceInitTime": {
                "type": "string",
                "description": "System time at which device was initialized.\n            For fixed devices, this will be the system time at\n            boot up.\n            For removable devices, it will be the time at which\n            the device was inserted, which may be boot up time,\n            or a later time (if device was inserted later).\n            If a device (fixed or removable) was repartitioned,\n            it will be the time of repartitioning.\n            The purpose of this object is to help a management\n            station determine if a removable device has been\n            changed. The application should retrieve this\n            object prior to any operation and compare with\n            the previously retrieved value.\n            Note that this time will not be real time but a\n            running time maintained by the system. This running\n            time starts from zero when the system boots up.\n            For a removable device that has been removed, this\n            value will be zero.",
                "x-yang-type": "yang:timestamp"
              },
              "ciscoFlashDeviceRemovable": {
                "type": "boolean",
                "description": "Whether Flash device is removable. Generally, only PCMCIA\n            Flash cards will be treated as removable. Socketed Flash\n            chips and Flash SIMM modules will not be treated as removable.\n            Simply put, only those Flash devices that can be inserted\n            or removed without opening the hardware casing will be\n            considered removable.\n            Further, removable Flash devices are expected to have\n            the necessary hardware support -\n              1. on-line removal and insertion\n              2. interrupt generation on removal or insertion."
              },
              "ciscoFlashPhyEntIndex": {
                "type": "string",
                "description": "This object indicates the physical entity index of a\n            physical entity in entPhysicalTable which the flash\n            device actually located.",
                "x-yang-type": "entity-mib:PhysicalIndexOrZero"
              },
              "ciscoFlashDeviceNameExtended": {
                "type": "string",
                "description": "Extended Flash device name whose size can be upto\n            255 characters. This name is used to refer to the\n            device within the system. Flash operations get directed\n            to a device based on this name.\n            The system has a concept of a default device.\n            This would be the primary or most used device in case\n            of multiple devices. The system directs an operation\n            to the default device whenever a device name is not\n            specified. The device name is therefore mandatory\n            except when the operation is being done on the\n            default device, or, the system supports only a single\n            Flash device. The device name will always be available\n            for a removable device, even when the device has been\n            removed.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashDeviceSizeExtended": {
                "type": "integer",
                "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            This object is a 64-bit version of ciscoFlashDeviceSize.",
                "minimum": 0
              },
              "ciscoFlashDeviceMinPartitionSizeExtended": {
                "type": "integer",
                "description": "This object provides the minimum partition size supported for\n            this device. This object is a 64-bit version of \n            ciscoFlashDeviceMinPatitionSize.",
                "minimum": 0
              }
            }
          },
          "ciscoFlashChipTable": {
            "type": "object",
            "description": "Table of Flash device chip properties for each\n        initialized Flash device.\n        This table is meant primarily for aiding error\n        diagnosis.",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashChipIndex": {
                "type": "integer",
                "description": "Chip sequence number within selected flash device.\n            Used to index within chip info table.\n            Value starts from 1 and should not be greater than\n            ciscoFlashDeviceChipCount for that device.\n            When retrieving chip information for chips within a\n            partition, the sequence number should lie between\n            ciscoFlashPartitionStartChip & ciscoFlashPartitionEndChip\n            (both inclusive).",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashChipCode": {
                "type": "string",
                "description": "Manufacturer and device code for a chip.\n            Lower byte will contain the device code.\n            Upper byte will contain the manufacturer code.\n            If a chip code is unknown because it could not\n            be queried out of the chip, the value of this\n            object will be 00:00.\n            Since programming algorithms differ from chip type to\n            chip type, this chip code should be used to determine\n            which algorithms to use (and thereby whether the chip\n            is supported in the first place).",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashChipDescr": {
                "type": "string",
                "description": "Flash chip name corresponding to the chip code.\n            The name will contain the manufacturer and the\n            chip type. It will be of the form :\n              Intel 27F008SA.\n            In the case where a chip code is unknown, this\n            object will be an empty (NULL) string.\n            In the case where the chip code is known but the\n            chip is not supported by the system, this object\n            will be an empty (NULL) string.\n            A management station is therefore expected to use the\n            chip code and the chip description in conjunction\n            to provide additional information whenever the\n            ciscoFlashPartitionStatus object has the readOnly(1)\n            value.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashChipWriteRetries": {
                "type": "integer",
                "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of write retries that were done in the chip.\n            If no writes have been done to Flash, the count\n            will be zero. Typically, a maximum of 25 retries are\n            done on a single location before flagging a write\n            error.\n            A management station is expected to get this object\n            for each chip in a partition after a write failure\n            in that partition. To keep a track of retries for\n            a given write operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any write operation.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashChipEraseRetries": {
                "type": "integer",
                "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of erase retries that were done in the chip.\n            Typically, a maximum of 2000 retries are done in a\n            single erase zone (which may be a full chip or a\n            portion, depending on the chip technology) before\n            flagging an erase error.\n            A management station is expected to get this object\n            for each chip in a partition after an erase failure\n            in that partition. To keep a track of retries for\n            a given erase operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any erase operation.\n            Note that erase may be done through an independent\n            command, or through a copy-to-flash command.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashChipMaxWriteRetries": {
                "type": "integer",
                "description": "The maximum number of write retries done at any\n            single location before declaring a write failure.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashChipMaxEraseRetries": {
                "type": "integer",
                "description": "The maximum number of erase retries done within\n            an erase sector before declaring an erase failure.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "ciscoFlashPartitionTable": {
            "type": "object",
            "description": "Table of flash device partition properties for each\n        initialized flash partition. Whenever there is no\n        explicit partitioning done, a single partition spanning\n        the entire device will be assumed to exist. There will\n        therefore always be atleast one partition on a device.",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "integer",
                "description": "Flash partition sequence number used to index within\n            table of initialized flash partitions.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashPartitionStartChip": {
                "type": "integer",
                "description": "Chip sequence number of first chip in partition.\n            Used as an index into the chip table.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashPartitionEndChip": {
                "type": "integer",
                "description": "Chip sequence number of last chip in partition.\n            Used as an index into the chip table.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashPartitionSize": {
                "type": "integer",
                "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            If the size of the flash partition is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionSizeExtended must be used to report the\n            flash partition's size.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashPartitionFreeSpace": {
                "type": "integer",
                "description": "Free space within a Flash partition.\n            Note that the actual size of a file in Flash includes\n            a small overhead that represents the file system's\n            file header.\n            Certain file systems may also have a partition or\n            device header overhead to be considered when\n            computing the free space.\n            Free space will be computed as total partition size\n            less size of all existing files (valid/invalid/deleted\n            files and including file header of each file),\n            less size of any partition header, less size of\n            header of next file to be copied in. In short, this\n            object will give the size of the largest file that\n            can be copied in. The management entity will not be\n            expected to know or use any overheads such as file\n            and partition header lengths, since such overheads\n            may vary from file system to file system.\n            Deleted files in Flash do not free up space.\n            A partition may have to be erased in order to reclaim\n            the space occupied by files.\n            \n            If the free space within a flash partition is greater than\n            the maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionFreeSpaceExtended\n            must be used to report the flash partition's free space.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashPartitionFileCount": {
                "type": "integer",
                "description": "Count of all files in a flash partition. Both\n            good and bad (deleted or invalid checksum) files\n            will be included in this count.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashPartitionChecksumAlgorithm": {
                "type": "string",
                "description": "Checksum algorithm identifier for checksum method\n            used by the file system. Normally, this would be\n            fixed for a particular file system. When a file\n            system writes a file to Flash, it checksums the\n            data written. The checksum then serves as a way\n            to validate the data read back whenever the file\n            is opened for reading.\n            Since there is no way, when using TFTP, to guarantee\n            that a network download has been error free (since\n            UDP checksums may not have been enabled), this\n            object together with the ciscoFlashFileChecksum\n            object provides a method for any management station\n            to regenerate the checksum of the original file\n            on the server and compare checksums to ensure that\n            the file download to Flash was error free.\n            simpleChecksum represents a simple 1s complement\n            addition of short word values. Other algorithm\n            values will be added as necessary."
              },
              "ciscoFlashPartitionStatus": {
                "type": "string",
                "description": "Flash partition status can be :\n            \n            * readOnly if device is not programmable either because\n            chips could not be recognized or an erroneous mismatch\n            of chips was detected. Chip recognition may fail either\n            because the chips are not supported by the system,\n            or because the Vpp voltage required to identify chips\n            has been disabled via the programming jumper.\n            The ciscoFlashDeviceProgrammingJumper, ciscoFlashChipCode,\n            and ciscoFlashChipDescr objects can be examined to get\n            more details on the cause of this status\n            * runFromFlash (RFF) if current image is running from\n            this partition.\n            The ciscoFlashPartitionUpgradeMethod object will then\n            indicate whether the Flash Load Helper can be used\n            to write a file to this partition or not.\n            \n            * readWrite if partition is programmable."
              },
              "ciscoFlashPartitionUpgradeMethod": {
                "type": "string",
                "description": "Flash partition upgrade method, ie., method by which\n            new files can be downloaded into the partition.\n            FLH stands for Flash Load Helper, a feature provided\n            on run-from-Flash systems for upgrading Flash. This\n            feature uses the bootstrap code in ROMs to help in\n            automatic download.\n            This object should be retrieved if the partition\n            status is runFromFlash(2).\n            If the partition status is readOnly(1), the upgrade\n            method would depend on the reason for the readOnly\n            status. For eg., it may simply be a matter of installing\n            the programming jumper, or it may require execution of a\n            later version of software that supports the Flash chips.\n            \n            unknown      -  the current system image does not know\n                            how Flash can be programmed. A possible\n                            method would be to reload the ROM image\n                            and perform the upgrade manually.\n            rxbootFLH    -  the Flash Load Helper is available to\n                            download files to Flash. A copy-to-flash\n                            command can be used and this system image\n                            will automatically reload the Rxboot image\n                            in ROM and direct it to carry out the\n                            download request.\n            direct       -  will be done directly by this image."
              },
              "ciscoFlashPartitionName": {
                "type": "string",
                "description": "Flash partition name used to refer to a partition\n            by the system. This can be any alpha-numeric character\n            string of the form AAAAAAAAnn, where A represents an\n            optional alpha character and n a numeric character.\n            Any numeric characters must always form the trailing\n            part of the string. The system will strip off the alpha\n            characters and use the numeric portion to map to a\n            partition index.\n            Flash operations get directed to a device partition\n            based on this name.\n            The system has a concept of a default partition. This\n            would be the first partition in the device. The system\n            directs an operation to the default partition whenever\n            a partition name is not specified.\n            The partition name is therefore mandatory except when\n            the operation is being done on the default partition, or\n            the device has just one partition (is not partitioned).",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashPartitionNeedErasure": {
                "type": "boolean",
                "description": "This object indicates whether a partition requires\n            erasure before any write operations can be done in it.\n            A management station should therefore retrieve this\n            object prior to attempting any write operation.\n            A partition requires erasure after it becomes full\n            free space left is less than or equal to the\n            (filesystem file header size).\n            A partition also requires erasure if the system does\n            not find the existence of any file system when it\n            boots up.\n            The partition may be erased explicitly through the\n            erase(5) command, or by using the copyToFlashWithErase(1)\n            command.\n            If a copyToFlashWithoutErase(2) command is issued\n            when this object has the TRUE value, the command\n            will fail."
              },
              "ciscoFlashPartitionFileNameLength": {
                "type": "integer",
                "description": "Maximum file name length supported by the file\n            system.\n            Max file name length will depend on the file\n            system implemented. Today, all file systems\n            support a max length of at least 48 bytes.\n            A management entity must use this object when\n            prompting a user for, or deriving the Flash file\n            name length.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashPartitionSizeExtended": {
                "type": "integer",
                "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            This object is a 64-bit version of ciscoFlashPartitionSize",
                "minimum": 0
              },
              "ciscoFlashPartitionFreeSpaceExtended": {
                "type": "integer",
                "description": "Free space within a Flash partition.\n            Note that the actual size of a file in Flash includes\n            a small overhead that represents the file system's\n            file header.\n            Certain file systems may also have a partition or\n            device header overhead to be considered when\n            computing the free space.\n            Free space will be computed as total partition size\n            less size of all existing files (valid/invalid/deleted\n            files and including file header of each file),\n            less size of any partition header, less size of\n            header of next file to be copied in. In short, this\n            object will give the size of the largest file that\n            can be copied in. The management entity will not be\n            expected to know or use any overheads such as file\n            and partition header lengths, since such overheads\n            may vary from file system to file system.\n            Deleted files in Flash do not free up space.\n            A partition may have to be erased in order to reclaim\n            the space occupied by files.\n            \n            This object is a 64-bit version of ciscoFlashPartitionFreeSpace",
                "minimum": 0
              },
              "ciscoFlashPartitionLowSpaceNotifThreshold": {
                "type": "string",
                "description": "This object specifies the minimum threshold value in percentage\n            of free space for each partition. If the free space available\n            goes below this threshold value and if\n            ciscoFlashPartionLowSpaceNotifEnable is set to true,\n            ciscoFlashPartitionLowSpaceNotif will be generated. When the\n            available free space comes back to the threshold value\n            ciscoFlashPartionLowSpaceRecoveryNotif will be generated.",
                "x-yang-type": "cisco-qos:Percent"
              }
            }
          },
          "ciscoFlashFileTable": {
            "type": "object",
            "description": "Table of information for files in a Flash partition.",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "string",
                "description": "ciscoFlashPartitionIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashFileIndex": {
                "type": "integer",
                "description": "Flash file sequence number used to index within\n            a Flash partition directory table.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashFileSize": {
                "type": "integer",
                "description": "Size of the file in bytes. Note that this size does\n            not include the size of the filesystem file header.\n            File size will always be non-zero.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashFileChecksum": {
                "type": "string",
                "description": "File checksum stored in the file header. This\n            checksum is computed and stored when the file is\n            written into Flash. It serves to validate the data\n            written into Flash.\n            Whereas the system will generate and store the checksum\n            internally in hexadecimal form, this object will\n            provide the checksum in a string form.\n            The checksum will be available for all valid and\n            invalid-checksum files.",
                "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
              },
              "ciscoFlashFileStatus": {
                "type": "string",
                "description": "Status of a file.\n            A file could be explicitly deleted if the file system\n            supports such a user command facility. Alternately,\n            an existing good file would be automatically deleted\n            if another good file with the same name were copied in.\n            Note that deleted files continue to occupy prime\n            Flash real estate.\n            \n            A file is marked as having an invalid checksum if any\n            checksum mismatch was detected while writing or reading\n            the file. Incomplete files (files truncated either\n            because of lack of free space, or a network download\n            failure) are also written with a bad checksum and\n            marked as invalid."
              },
              "ciscoFlashFileName": {
                "type": "string",
                "description": "Flash file name as specified by the user copying in\n            the file. The name should not include the colon (:)\n            character as it is a special separator character used\n            to delineate the device name, partition name, and the\n            file name.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashFileType": {
                "type": "string",
                "description": "Type of the file.",
                "x-yang-type": "CISCO-FLASH-MIB:FlashFileType"
              },
              "ciscoFlashFileDate": {
                "type": "string",
                "description": "The time at which this file was created.",
                "x-yang-type": "snmpv2-tc:DateAndTime"
              }
            }
          },
          "ciscoFlashFileByTypeTable": {
            "type": "object",
            "description": "Table of information for files on the manageable\n        flash devices sorted by File Types.",
            "properties": {
              "ciscoFlashFileType": {
                "type": "string",
                "description": "ciscoFlashFileType",
                "x-yang-type": "leafref"
              },
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "string",
                "description": "ciscoFlashPartitionIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashFileIndex": {
                "type": "string",
                "description": "ciscoFlashFileIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashFileByTypeSize": {
                "type": "integer",
                "description": "This object represents exactly the\n            same info as ciscoFlashFileSize\n            object in ciscoFlashFileTable.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashFileByTypeChecksum": {
                "type": "string",
                "description": "This object represents exactly the\n            same info as ciscoFlashFileChecksum\n            object in ciscoFlashFileTable.",
                "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
              },
              "ciscoFlashFileByTypeStatus": {
                "type": "string",
                "description": "This object represents exactly the\n            same info as ciscoFlashFileStatus\n            object in ciscoFlashFileTable."
              },
              "ciscoFlashFileByTypeName": {
                "type": "string",
                "description": "This object represents exactly the\n            same info as ciscoFlashFileName\n            object in ciscoFlashFileTable.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashFileByTypeDate": {
                "type": "string",
                "description": "This object represents exactly the\n            same info as ciscoFlashFileDate\n            object in ciscoFlashFileTable.",
                "x-yang-type": "snmpv2-tc:DateAndTime"
              }
            }
          },
          "ciscoFlashCopyTable": {
            "type": "object",
            "description": "A table of Flash copy operation entries. Each\n        entry represents a Flash copy operation (to or\n        from Flash) that has been initiated.",
            "properties": {
              "ciscoFlashCopySerialNumber": {
                "type": "integer",
                "description": "Object which specifies a unique entry in the\n            table. A management station wishing to initiate a\n            copy operation should use a pseudo-random value for\n            this object when creating or modifying an instance of\n            a ciscoFlashCopyEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashCopyCommand": {
                "type": "string",
                "description": "The copy command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the invalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            copyToFlashWithErase    Copy a file to flash; erase\n                                    flash before copy.\n                                    Use the TFTP or rcp protocol.\n            copyToFlashWithoutErase Copy a file to flash; do not\n                                    erase.\n                                    Note that this command will fail\n                                    if the PartitionNeedErasure\n                                    object specifies that the\n                                    partition being copied to needs\n                                    erasure.\n                                    Use the TFTP or rcp protocol.\n            copyFromFlash           Copy a file from flash using\n                                    the TFTP, rcp or lex protocol.\n                                    Note that the lex protocol\n                                    can only be used to copy to a\n                                    lex device.\n            copyFromFlhLog          Copy contents of FLH log to\n                                    server using TFTP protocol.\n            \n            \n            Command table           Parameters\n            copyToFlashWithErase    CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyToFlashWithoutErase CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlash           CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlhLog          CopyProtocol\n                                    CopyServerAddress\n                                    CopyDestinationName\n                                    CopyNotifyOnCompletion (opt)"
              },
              "ciscoFlashCopyProtocol": {
                "type": "string",
                "description": "The protocol to be used for any copy. Optional.\n            Will default to tftp if not specified.\n            \n            Since feature support depends on a software release,\n            version number within the release, platform, and\n            maybe the image type (subset type), a management\n            station would be expected to somehow determine\n            the protocol support for a command."
              },
              "ciscoFlashCopyServerAddress": {
                "type": "string",
                "description": "The server address to be used for any copy. Optional.\n            Will default to 'FFFFFFFF'H  (or 255.255.255.255).\n            \n            Since this object can just hold only IPv4 Transport\n            type, it is deprecated and replaced by\n            ciscoFlashCopyServerAddrRev1.",
                "format": "inet:ipv4-address"
              },
              "ciscoFlashCopySourceName": {
                "type": "string",
                "description": "Source file name, either in Flash or on a server,\n            depending on the type of copy command. Mandatory.\n            \n            For a copy from Flash:\n            File name must be of the form\n                    [device>:][:]\n            where  is a value obtained from FlashDeviceName,\n                     is obtained from FlashPartitionName\n                and  is the name of a file in Flash.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For a copy to Flash, the file name will be as per\n            the file naming conventions and path to the file on\n            the server.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashCopyDestinationName": {
                "type": "string",
                "description": "Destination file name.\n            \n            For a copy to Flash:\n            File name must be of the form\n                    {device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is any character string that does not have\n            embedded colon characters.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            If <file> is not specified, it will default to <file>\n            specified in ciscoFlashCopySourceName.\n            \n            For a copy from Flash via tftp or rcp, the file name will be\n            as per the file naming conventions and destination sub-directory\n            on the server. If not specified, <file> from the source\n            file name will be used.\n            For a copy from Flash via lex, this string will consist\n            of numeric characters specifying the interface on the\n            lex box that will receive the source flash image.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashPartitioningSerialNumber": {
                "type": "integer",
                "description": "Object which specifies a unique entry in the partitioning\n            operations table. A management station wishing to initiate\n            a partitioning operation should use a pseudo-random value\n            for this object when creating or modifying an instance of\n            a ciscoFlashPartitioningEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashPartitioningCommand": {
                "type": "string",
                "description": "The partitioning command to be executed. Mandatory.\n            If the command is unsupported, the\n            partitioningInvalidOperation\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            partition               Partition a Flash device.\n                                    All the prerequisites for\n                                    partitioning must be met for\n                                    this command to succeed.\n            \n            Command table           Parameters\n            1) partition            PartitioningDestinationName\n                                    PartitioningPartitionCount\n                                    PartitioningPartitionSizes (opt)\n                                    PartitioningNotifyOnCompletion (opt)"
              },
              "ciscoFlashPartitioningDestinationName": {
                "type": "string",
                "description": "Destination device name. This name will be the value\n            obtained from FlashDeviceName.\n            If the name is not specified, the default Flash device\n            will be assumed.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashPartitioningPartitionCount": {
                "type": "integer",
                "description": "This object is used to specify the number of\n            partitions to be created. Its value cannot exceed\n            the value of ciscoFlashDeviceMaxPartitions.\n            \n            To undo partitioning (revert to a single partition),\n            this object must have the value 1.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ciscoFlashPartitioningPartitionSizes": {
                "type": "string",
                "description": "This object is used to explicitly specify the size\n            of each partition to be created.\n            The size of each partition will be in units of\n            ciscoFlashDeviceMinPartitionSize.\n            The value of this object will be in the form:\n                    <part1>:<part2>...:<partn>\n            \n            If partition sizes are not specified, the system\n            will calculate default sizes based on the partition\n            count, the minimum partition size, and the device\n            size. Partition size need not be specified when\n            undoing partitioning (partition count is 1).\n            If partition sizes are specified, the number of\n            sizes specified must exactly match the partition\n            count. If not, the partitioning command will be\n            rejected with the invalidPartitionSizes error .",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashPartitioningStatus": {
                "type": "string",
                "description": "The status of the specified partitioning operation.\n            partitioningInProgress :\n                    specified operation is active\n            \n            partitioningOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            partitioningInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            partitioningInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            partitioningInvalidPartitionCount :\n                    invalid partition count specified for the\n                    partitioning command\n            \n            partitioningInvalidPartitionSizes :\n                    invalid partition size, or invalid count of\n                    partition sizes\n            \n            partitioningDeviceBusy :\n                    specified device is in use and locked by\n                    another process\n            \n            partitioningDeviceOpenError :\n                    invalid device name\n            \n            partitioningDeviceError :\n                    device read, write or erase error\n            \n            partitioningNoMemory :\n                    system running low on memory\n            \n            partitioningUnknownFailure :\n                    failure unknown"
              },
              "ciscoFlashPartitioningNotifyOnCompletion": {
                "type": "boolean",
                "description": "Specifies whether or not a notification should be\n            generated on the completion of the partitioning operation.\n            If specified, ciscoFlashPartitioningCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
              },
              "ciscoFlashPartitioningTime": {
                "type": "string",
                "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
                "x-yang-type": "yang:timeticks"
              },
              "ciscoFlashPartitioningEntryStatus": {
                "type": "string",
                "description": "The status of this table entry.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              },
              "ciscoFlashMiscOpSerialNumber": {
                "type": "integer",
                "description": "Object which specifies a unique entry in the\n            table. A management station wishing to initiate a\n            flash operation should use a pseudo-random value for\n            this object when creating or modifying an instance of\n            a ciscoFlashMiscOpEntry.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ciscoFlashMiscOpCommand": {
                "type": "string",
                "description": "The command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the miscOpInvalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command         Remarks\n            erase           Erase flash.\n            verify          Verify flash file checksum.\n            delete          Delete a file.\n            undelete        Revive a deleted file .\n                            Note that there are limits on\n                            the number of times a file can\n                            be deleted and undeleted. When\n                            this limit is exceeded, the\n                            system will return the appropriate\n                            error.\n            squeeze         Recover space occupied by\n                            deleted files. This command\n                            preserves the good files, erases\n                            out the file system, then restores\n                            the preserved good files.\n            format          Format a flash device.\n            \n            Command table   Parameters\n            erase           MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            verify          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            delete          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            undelete        MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            squeeze         MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            format          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)"
              },
              "ciscoFlashMiscOpDestinationName": {
                "type": "string",
                "description": "Destination file, or partition name.\n            File name must be of the form\n                    [device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is the name of a file in Flash.\n            While leading and/or trailing whitespaces are acceptable,\n            no whitespaces are allowed within the path itself.\n            \n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For an operation on a partition, eg., the erase\n            command, this object would specify the partition name\n            in the form:\n                    [device>:][<partition>:]",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "ciscoFlashMiscOpStatus": {
                "type": "string",
                "description": "The status of the specified operation.\n            miscOpInProgress :\n                    specified operation is active\n            \n            miscOpOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            miscOpInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            miscOpInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            miscOpDeviceBusy :\n                    specified device is in use and locked by another\n                    process\n            \n            miscOpDeviceOpenError :\n                    invalid device name\n            \n            miscOpDeviceError :\n                    device read, write or erase error\n            \n            miscOpDeviceNotProgrammable :\n                    device is read-only but a write or erase\n                    operation was specified\n            \n            miscOpFileOpenError :\n                    invalid file name; file not found in partition\n            \n            miscOpFileDeleteFailure :\n                    file could not be deleted; delete count exceeded\n            \n            miscOpFileUndeleteFailure :\n                    file could not be undeleted; undelete count\n                    exceeded\n            \n            miscOpFileChecksumError :\n                    file has a bad checksum\n            \n            miscOpNoMemory :\n                    system running low on memory\n            \n            miscOpUnknownFailure :\n                    failure unknown\n            \n            miscOpSqueezeFailure :\n                    the squeeze operation failed\n            \n            miscOpNoSuchFile :\n                    a valid but nonexistent file name was specified\n            \n            miscOpFormatFailure :\n                    the format operation failed"
              },
              "ciscoFlashMiscOpNotifyOnCompletion": {
                "type": "boolean",
                "description": "Specifies whether or not a notification should be\n            generated on the completion of an operation.\n            If specified, ciscoFlashMiscOpCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
              },
              "ciscoFlashMiscOpTime": {
                "type": "string",
                "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
                "x-yang-type": "yang:timeticks"
              },
              "ciscoFlashMiscOpEntryStatus": {
                "type": "string",
                "description": "The status of this table entry.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              },
              "ciscoFlashPartitioningTable": {
                "type": "object",
                "description": "A table of Flash partitioning operation entries. Each\n        entry represents a Flash partitioning operation that\n        has been initiated.",
                "properties": {
                  "ciscoFlashPartitioningSerialNumber": {
                    "type": "integer",
                    "description": "Object which specifies a unique entry in the partitioning\n            operations table. A management station wishing to initiate\n            a partitioning operation should use a pseudo-random value\n            for this object when creating or modifying an instance of\n            a ciscoFlashPartitioningEntry.",
                    "minimum": -2147483648,
                    "maximum": 2147483647
                  },
                  "ciscoFlashPartitioningCommand": {
                    "type": "string",
                    "description": "The partitioning command to be executed. Mandatory.\n            If the command is unsupported, the\n            partitioningInvalidOperation\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            partition               Partition a Flash device.\n                                    All the prerequisites for\n                                    partitioning must be met for\n                                    this command to succeed.\n            \n            Command table           Parameters\n            1) partition            PartitioningDestinationName\n                                    PartitioningPartitionCount\n                                    PartitioningPartitionSizes (opt)\n                                    PartitioningNotifyOnCompletion (opt)"
                  },
                  "ciscoFlashPartitioningDestinationName": {
                    "type": "string",
                    "description": "Destination device name. This name will be the value\n            obtained from FlashDeviceName.\n            If the name is not specified, the default Flash device\n            will be assumed.",
                    "x-yang-type": "snmpv2-tc:DisplayString"
                  },
                  "ciscoFlashPartitioningPartitionCount": {
                    "type": "integer",
                    "description": "This object is used to specify the number of\n            partitions to be created. Its value cannot exceed\n            the value of ciscoFlashDeviceMaxPartitions.\n            \n            To undo partitioning (revert to a single partition),\n            this object must have the value 1.",
                    "minimum": 0,
                    "maximum": 4294967295
                  },
                  "ciscoFlashPartitioningPartitionSizes": {
                    "type": "string",
                    "description": "This object is used to explicitly specify the size\n            of each partition to be created.\n            The size of each partition will be in units of\n            ciscoFlashDeviceMinPartitionSize.\n            The value of this object will be in the form:\n                    <part1>:<part2>...:<partn>\n            \n            If partition sizes are not specified, the system\n            will calculate default sizes based on the partition\n            count, the minimum partition size, and the device\n            size. Partition size need not be specified when\n            undoing partitioning (partition count is 1).\n            If partition sizes are specified, the number of\n            sizes specified must exactly match the partition\n            count. If not, the partitioning command will be\n            rejected with the invalidPartitionSizes error .",
                    "x-yang-type": "snmpv2-tc:DisplayString"
                  },
                  "ciscoFlashPartitioningStatus": {
                    "type": "string",
                    "description": "The status of the specified partitioning operation.\n            partitioningInProgress :\n                    specified operation is active\n            \n            partitioningOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            partitioningInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            partitioningInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            partitioningInvalidPartitionCount :\n                    invalid partition count specified for the\n                    partitioning command\n            \n            partitioningInvalidPartitionSizes :\n                    invalid partition size, or invalid count of\n                    partition sizes\n            \n            partitioningDeviceBusy :\n                    specified device is in use and locked by\n                    another process\n            \n            partitioningDeviceOpenError :\n                    invalid device name\n            \n            partitioningDeviceError :\n                    device read, write or erase error\n            \n            partitioningNoMemory :\n                    system running low on memory\n            \n            partitioningUnknownFailure :\n                    failure unknown"
                  },
                  "ciscoFlashPartitioningNotifyOnCompletion": {
                    "type": "boolean",
                    "description": "Specifies whether or not a notification should be\n            generated on the completion of the partitioning operation.\n            If specified, ciscoFlashPartitioningCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
                  },
                  "ciscoFlashPartitioningTime": {
                    "type": "string",
                    "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
                    "x-yang-type": "yang:timeticks"
                  },
                  "ciscoFlashPartitioningEntryStatus": {
                    "type": "string",
                    "description": "The status of this table entry.",
                    "x-yang-type": "snmpv2-tc:RowStatus"
                  }
                }
              },
              "ciscoFlashMiscOpTable": {
                "type": "object",
                "description": "A table of misc Flash operation entries. Each\n        entry represents a Flash operation that\n        has been initiated.",
                "properties": {
                  "ciscoFlashMiscOpSerialNumber": {
                    "type": "integer",
                    "description": "Object which specifies a unique entry in the\n            table. A management station wishing to initiate a\n            flash operation should use a pseudo-random value for\n            this object when creating or modifying an instance of\n            a ciscoFlashMiscOpEntry.",
                    "minimum": -2147483648,
                    "maximum": 2147483647
                  },
                  "ciscoFlashMiscOpCommand": {
                    "type": "string",
                    "description": "The command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the miscOpInvalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command         Remarks\n            erase           Erase flash.\n            verify          Verify flash file checksum.\n            delete          Delete a file.\n            undelete        Revive a deleted file .\n                            Note that there are limits on\n                            the number of times a file can\n                            be deleted and undeleted. When\n                            this limit is exceeded, the\n                            system will return the appropriate\n                            error.\n            squeeze         Recover space occupied by\n                            deleted files. This command\n                            preserves the good files, erases\n                            out the file system, then restores\n                            the preserved good files.\n            format          Format a flash device.\n            \n            Command table   Parameters\n            erase           MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            verify          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            delete          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            undelete        MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            squeeze         MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            format          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)"
                  },
                  "ciscoFlashMiscOpDestinationName": {
                    "type": "string",
                    "description": "Destination file, or partition name.\n            File name must be of the form\n                    [device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is the name of a file in Flash.\n            While leading and/or trailing whitespaces are acceptable,\n            no whitespaces are allowed within the path itself.\n            \n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For an operation on a partition, eg., the erase\n            command, this object would specify the partition name\n            in the form:\n                    [device>:][<partition>:]",
                    "x-yang-type": "snmpv2-tc:DisplayString"
                  },
                  "ciscoFlashMiscOpStatus": {
                    "type": "string",
                    "description": "The status of the specified operation.\n            miscOpInProgress :\n                    specified operation is active\n            \n            miscOpOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            miscOpInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            miscOpInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            miscOpDeviceBusy :\n                    specified device is in use and locked by another\n                    process\n            \n            miscOpDeviceOpenError :\n                    invalid device name\n            \n            miscOpDeviceError :\n                    device read, write or erase error\n            \n            miscOpDeviceNotProgrammable :\n                    device is read-only but a write or erase\n                    operation was specified\n            \n            miscOpFileOpenError :\n                    invalid file name; file not found in partition\n            \n            miscOpFileDeleteFailure :\n                    file could not be deleted; delete count exceeded\n            \n            miscOpFileUndeleteFailure :\n                    file could not be undeleted; undelete count\n                    exceeded\n            \n            miscOpFileChecksumError :\n                    file has a bad checksum\n            \n            miscOpNoMemory :\n                    system running low on memory\n            \n            miscOpUnknownFailure :\n                    failure unknown\n            \n            miscOpSqueezeFailure :\n                    the squeeze operation failed\n            \n            miscOpNoSuchFile :\n                    a valid but nonexistent file name was specified\n            \n            miscOpFormatFailure :\n                    the format operation failed"
                  },
                  "ciscoFlashMiscOpNotifyOnCompletion": {
                    "type": "boolean",
                    "description": "Specifies whether or not a notification should be\n            generated on the completion of an operation.\n            If specified, ciscoFlashMiscOpCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
                  },
                  "ciscoFlashMiscOpTime": {
                    "type": "string",
                    "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
                    "x-yang-type": "yang:timeticks"
                  },
                  "ciscoFlashMiscOpEntryStatus": {
                    "type": "string",
                    "description": "The status of this table entry.",
                    "x-yang-type": "snmpv2-tc:RowStatus"
                  }
                }
              }
            }
          },
          "object-1": {
            "type": "object",
            "description": "object-1",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "string",
                "description": "ciscoFlashPartitionIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionName": {
                "type": "string",
                "description": "ciscoFlashPartitionName",
                "x-yang-type": "leafref"
              }
            }
          },
          "object-2": {
            "type": "object",
            "description": "object-2",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "string",
                "description": "ciscoFlashPartitionIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionFreeSpaceExtended": {
                "type": "string",
                "description": "ciscoFlashPartitionFreeSpaceExtended",
                "x-yang-type": "leafref"
              }
            }
          },
          "object-3": {
            "type": "object",
            "description": "object-3",
            "properties": {
              "ciscoFlashDeviceIndex": {
                "type": "string",
                "description": "ciscoFlashDeviceIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionIndex": {
                "type": "string",
                "description": "ciscoFlashPartitionIndex",
                "x-yang-type": "leafref"
              },
              "ciscoFlashPartitionLowSpaceNotifThreshold": {
                "type": "string",
                "description": "ciscoFlashPartitionLowSpaceNotifThreshold",
                "x-yang-type": "leafref"
              }
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashDeviceEntry": {
        "type": "array",
        "description": "ciscoFlashDeviceEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashDeviceIndex": {
              "type": "integer",
              "description": "Flash device sequence number to index within the\n            table of initialized flash devices.\n            The lowest value should be 1. The highest should be\n            less than or equal to the value of the\n            ciscoFlashDevicesSupported object.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashDeviceSize": {
              "type": "integer",
              "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            If the total size of the flash device is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashDeviceSizeExtended must be used to report the\n            flash device's size.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashDeviceMinPartitionSize": {
              "type": "integer",
              "description": "This object will give the minimum partition size\n            supported for this device. For systems that execute code\n            directly out of Flash, the minimum partition size needs\n            to be the bank size. (Bank size is equal to the size of a\n            chip multiplied by the width of the device. In most cases,\n            the device width is 4 bytes, and so the bank size would be\n            four times the size of a chip). This has to be so because\n            all programming commands affect the operation of an\n            entire chip (in our case, an entire bank because all\n            operations are done on the entire width of the device)\n            even though the actual command may be localized to a small\n            portion of each chip. So when executing code out of Flash,\n            one needs to be able to write and erase some portion of\n            Flash without affecting the code execution.\n            For systems that execute code out of DRAM or ROM, it is\n            possible to partition Flash with a finer granularity (for\n            eg., at erase sector boundaries) if the system code supports\n            such granularity.\n            \n            This object will let a management entity know the\n            minimum partition size as defined by the system.\n            If the system does not support partitioning, the value\n            will be equal to the device size in ciscoFlashDeviceSize.\n            The maximum number of partitions that could be configured\n            will be equal to the minimum of\n            ciscoFlashDeviceMaxPartitions\n            and\n            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).\n            \n            If the total size of the flash device is greater than the\n            maximum value reportable by this object then this object should\n            report its maximum value(4,294,967,295) and\n            ciscoFlashDeviceMinPartitionSizeExtended must be used to report\n            the flash device's minimum partition size.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashDeviceMaxPartitions": {
              "type": "integer",
              "description": "Max number of partitions supported by the system for\n            this Flash device. Default will be 1, which actually\n            means that partitioning is not supported. Note that\n            this value will be defined by system limitations, not\n            by the flash device itself (for eg., the system may\n            impose a limit of 2 partitions even though the device\n            may be large enough to be partitioned into 4 based on\n            the smallest partition unit supported).\n            On systems that execute code out of Flash, partitioning\n            is a way of creating multiple file systems in the Flash\n            device so that writing into or erasing of one file system\n            can be done while executing code residing in another file\n            system.\n            For systems executing code out of DRAM, partitioning\n            gives a way of sub-dividing a large Flash device for\n            easier management of files.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashDevicePartitions": {
              "type": "integer",
              "description": "Flash device partitions actually present. Number of\n            partitions cannot exceed the minimum of\n            ciscoFlashDeviceMaxPartitions\n            and\n            (ciscoFlashDeviceSize / ciscoFlashDeviceMinPartitionSize).\n            Will be equal to at least 1, the case where the partition\n            spans the entire device (actually no partitioning).\n            A partition will contain one or more minimum partition\n            units (where a minimum partition unit is defined by\n            ciscoFlashDeviceMinPartitionSize).",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashDeviceChipCount": {
              "type": "integer",
              "description": "Total number of chips within the Flash device.\n            The purpose of this object is to provide information\n            upfront to a management station on how much chip info\n            to expect and possibly help double check the chip index\n            against an upper limit when randomly retrieving chip\n            info for a partition.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashDeviceName": {
              "type": "string",
              "description": "Flash device name. This name is used to refer to the\n            device within the system. Flash operations get directed\n            to a device based on this name.\n            The system has a concept of a default device.\n            This would be the primary or most used device in case of\n            multiple devices. The system directs an operation to the\n            default device whenever a device name is not specified.\n            The device name is therefore mandatory except when the\n            operation is being done on the default device, or,\n            the system supports only a single Flash device.\n            The device name will always be available for a\n            removable device, even when the device has been removed.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashDeviceDescr": {
              "type": "string",
              "description": "Description of a Flash device. The description is meant\n            to explain what the Flash device and its purpose is.\n            Current values are:\n              System flash - for the primary Flash used to store full\n                             system images.\n              Boot flash   - for the secondary Flash used to store\n                             bootstrap images.\n            The ciscoFlashDeviceDescr, ciscoFlashDeviceController\n            (if applicable), and ciscoFlashPhyEntIndex objects are\n            expected to collectively give all information about a\n            Flash device.\n            The device description will always be available for a\n            removable device, even when the device has been removed.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashDeviceController": {
              "type": "string",
              "description": "Flash device controller. The h/w card that actually\n            controls Flash read/write/erase. Relevant for the AGS+\n            systems where Flash may be controlled by the MC+, STR or\n            the ENVM cards, cards that may not actually contain the\n            Flash chips.\n            For systems that have removable PCMCIA flash cards that\n            are controlled by a PCMCIA controller chip, this object\n            may contain a description of that controller chip.\n            Where irrelevant (Flash is a direct memory mapped device\n            accessed directly by the main processor), this object will\n            have an empty (NULL) string.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashDeviceCard": {
              "type": "string",
              "description": "This object will point to an instance of a card entry\n            in the cardTable. The card entry will give details about\n            the card on which the Flash device is actually located.\n            For most systems, this is usually the main processor board.\n            On the AGS+ systems, Flash is located on a separate multibus\n            card such as the MC.\n            This object will therefore be used to essentially index\n            into cardTable to retrieve details about the card such as\n            cardDescr, cardSlotNumber, etc.",
              "x-yang-type": "snmpv2-tc:InstancePointer"
            },
            "ciscoFlashDeviceProgrammingJumper": {
              "type": "string",
              "description": "This object gives the state of a jumper (if present and can be\n            determined) that controls the programming voltage called Vpp\n            to the Flash device. Vpp is required for programming (erasing\n            and writing) Flash. For certain older technology chips it is\n            also required for identifying the chips (which in turn is\n            required to identify which programming algorithms to use;\n            different chips require different algorithms and commands).\n            The purpose of the jumper, on systems where it is available,\n            is to write protect a Flash device.\n            On most of the newer remote access routers, this jumper is\n            unavailable since users are not expected to visit remote sites\n            just to install and remove the jumpers when upgrading software\n            in the Flash device. The unknown(3) value will be returned for\n            such systems and can be interpreted to mean that a programming\n            jumper is not present or not required on those systems.\n            On systems where the programming jumper state can be read back\n            via a hardware register, the installed(1) or notInstalled(2)\n            value will be returned.\n            This object is expected to be used in conjunction with the\n            ciscoFlashPartitionStatus object whenever that object has\n            the readOnly(1) value. In such a case, this object will\n            indicate whether the programming jumper is a possible reason\n            for the readOnly state."
            },
            "ciscoFlashDeviceInitTime": {
              "type": "string",
              "description": "System time at which device was initialized.\n            For fixed devices, this will be the system time at\n            boot up.\n            For removable devices, it will be the time at which\n            the device was inserted, which may be boot up time,\n            or a later time (if device was inserted later).\n            If a device (fixed or removable) was repartitioned,\n            it will be the time of repartitioning.\n            The purpose of this object is to help a management\n            station determine if a removable device has been\n            changed. The application should retrieve this\n            object prior to any operation and compare with\n            the previously retrieved value.\n            Note that this time will not be real time but a\n            running time maintained by the system. This running\n            time starts from zero when the system boots up.\n            For a removable device that has been removed, this\n            value will be zero.",
              "x-yang-type": "yang:timestamp"
            },
            "ciscoFlashDeviceRemovable": {
              "type": "boolean",
              "description": "Whether Flash device is removable. Generally, only PCMCIA\n            Flash cards will be treated as removable. Socketed Flash\n            chips and Flash SIMM modules will not be treated as removable.\n            Simply put, only those Flash devices that can be inserted\n            or removed without opening the hardware casing will be\n            considered removable.\n            Further, removable Flash devices are expected to have\n            the necessary hardware support -\n              1. on-line removal and insertion\n              2. interrupt generation on removal or insertion."
            },
            "ciscoFlashPhyEntIndex": {
              "type": "string",
              "description": "This object indicates the physical entity index of a\n            physical entity in entPhysicalTable which the flash\n            device actually located.",
              "x-yang-type": "entity-mib:PhysicalIndexOrZero"
            },
            "ciscoFlashDeviceNameExtended": {
              "type": "string",
              "description": "Extended Flash device name whose size can be upto\n            255 characters. This name is used to refer to the\n            device within the system. Flash operations get directed\n            to a device based on this name.\n            The system has a concept of a default device.\n            This would be the primary or most used device in case\n            of multiple devices. The system directs an operation\n            to the default device whenever a device name is not\n            specified. The device name is therefore mandatory\n            except when the operation is being done on the\n            default device, or, the system supports only a single\n            Flash device. The device name will always be available\n            for a removable device, even when the device has been\n            removed.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashDeviceSizeExtended": {
              "type": "integer",
              "description": "Total size of the Flash device.\n            For a removable device, the size will be zero if\n            the device has been removed.\n            \n            This object is a 64-bit version of ciscoFlashDeviceSize.",
              "minimum": 0
            },
            "ciscoFlashDeviceMinPartitionSizeExtended": {
              "type": "integer",
              "description": "This object provides the minimum partition size supported for\n            this device. This object is a 64-bit version of \n            ciscoFlashDeviceMinPatitionSize.",
              "minimum": 0
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashChipEntry": {
        "type": "array",
        "description": "An entry in the table of chip info for each\n          flash device initialized in the system.\n          An entry is indexed by two objects - the\n          device index and the chip index within that\n          device.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashDeviceIndex": {
              "type": "string",
              "description": "ciscoFlashDeviceIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashChipIndex": {
              "type": "integer",
              "description": "Chip sequence number within selected flash device.\n            Used to index within chip info table.\n            Value starts from 1 and should not be greater than\n            ciscoFlashDeviceChipCount for that device.\n            When retrieving chip information for chips within a\n            partition, the sequence number should lie between\n            ciscoFlashPartitionStartChip & ciscoFlashPartitionEndChip\n            (both inclusive).",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashChipCode": {
              "type": "string",
              "description": "Manufacturer and device code for a chip.\n            Lower byte will contain the device code.\n            Upper byte will contain the manufacturer code.\n            If a chip code is unknown because it could not\n            be queried out of the chip, the value of this\n            object will be 00:00.\n            Since programming algorithms differ from chip type to\n            chip type, this chip code should be used to determine\n            which algorithms to use (and thereby whether the chip\n            is supported in the first place).",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashChipDescr": {
              "type": "string",
              "description": "Flash chip name corresponding to the chip code.\n            The name will contain the manufacturer and the\n            chip type. It will be of the form :\n              Intel 27F008SA.\n            In the case where a chip code is unknown, this\n            object will be an empty (NULL) string.\n            In the case where the chip code is known but the\n            chip is not supported by the system, this object\n            will be an empty (NULL) string.\n            A management station is therefore expected to use the\n            chip code and the chip description in conjunction\n            to provide additional information whenever the\n            ciscoFlashPartitionStatus object has the readOnly(1)\n            value.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashChipWriteRetries": {
              "type": "integer",
              "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of write retries that were done in the chip.\n            If no writes have been done to Flash, the count\n            will be zero. Typically, a maximum of 25 retries are\n            done on a single location before flagging a write\n            error.\n            A management station is expected to get this object\n            for each chip in a partition after a write failure\n            in that partition. To keep a track of retries for\n            a given write operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any write operation.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashChipEraseRetries": {
              "type": "integer",
              "description": "This object will provide a cumulative count\n            (since last system boot up or initialization) of\n            the number of erase retries that were done in the chip.\n            Typically, a maximum of 2000 retries are done in a\n            single erase zone (which may be a full chip or a\n            portion, depending on the chip technology) before\n            flagging an erase error.\n            A management station is expected to get this object\n            for each chip in a partition after an erase failure\n            in that partition. To keep a track of retries for\n            a given erase operation, the management station would\n            have to retrieve the values for the concerned chips\n            before and after any erase operation.\n            Note that erase may be done through an independent\n            command, or through a copy-to-flash command.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashChipMaxWriteRetries": {
              "type": "integer",
              "description": "The maximum number of write retries done at any\n            single location before declaring a write failure.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashChipMaxEraseRetries": {
              "type": "integer",
              "description": "The maximum number of erase retries done within\n            an erase sector before declaring an erase failure.",
              "minimum": 0,
              "maximum": 4294967295
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashPartitionEntry": {
        "type": "array",
        "description": "An entry in the table of flash partition properties\n          for each initialized flash partition. Each entry\n          will be indexed by a device number and a partition\n          number within the device.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashDeviceIndex": {
              "type": "string",
              "description": "ciscoFlashDeviceIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashPartitionIndex": {
              "type": "integer",
              "description": "Flash partition sequence number used to index within\n            table of initialized flash partitions.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashPartitionStartChip": {
              "type": "integer",
              "description": "Chip sequence number of first chip in partition.\n            Used as an index into the chip table.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashPartitionEndChip": {
              "type": "integer",
              "description": "Chip sequence number of last chip in partition.\n            Used as an index into the chip table.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashPartitionSize": {
              "type": "integer",
              "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            If the size of the flash partition is greater than the\n            maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionSizeExtended must be used to report the\n            flash partition's size.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashPartitionFreeSpace": {
              "type": "integer",
              "description": "Free space within a Flash partition.\n            Note that the actual size of a file in Flash includes\n            a small overhead that represents the file system's\n            file header.\n            Certain file systems may also have a partition or\n            device header overhead to be considered when\n            computing the free space.\n            Free space will be computed as total partition size\n            less size of all existing files (valid/invalid/deleted\n            files and including file header of each file),\n            less size of any partition header, less size of\n            header of next file to be copied in. In short, this\n            object will give the size of the largest file that\n            can be copied in. The management entity will not be\n            expected to know or use any overheads such as file\n            and partition header lengths, since such overheads\n            may vary from file system to file system.\n            Deleted files in Flash do not free up space.\n            A partition may have to be erased in order to reclaim\n            the space occupied by files.\n            \n            If the free space within a flash partition is greater than\n            the maximum value reportable by this object then this object\n            should report its maximum value(4,294,967,295) and\n            ciscoFlashPartitionFreeSpaceExtended\n            must be used to report the flash partition's free space.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashPartitionFileCount": {
              "type": "integer",
              "description": "Count of all files in a flash partition. Both\n            good and bad (deleted or invalid checksum) files\n            will be included in this count.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashPartitionChecksumAlgorithm": {
              "type": "string",
              "description": "Checksum algorithm identifier for checksum method\n            used by the file system. Normally, this would be\n            fixed for a particular file system. When a file\n            system writes a file to Flash, it checksums the\n            data written. The checksum then serves as a way\n            to validate the data read back whenever the file\n            is opened for reading.\n            Since there is no way, when using TFTP, to guarantee\n            that a network download has been error free (since\n            UDP checksums may not have been enabled), this\n            object together with the ciscoFlashFileChecksum\n            object provides a method for any management station\n            to regenerate the checksum of the original file\n            on the server and compare checksums to ensure that\n            the file download to Flash was error free.\n            simpleChecksum represents a simple 1s complement\n            addition of short word values. Other algorithm\n            values will be added as necessary."
            },
            "ciscoFlashPartitionStatus": {
              "type": "string",
              "description": "Flash partition status can be :\n            \n            * readOnly if device is not programmable either because\n            chips could not be recognized or an erroneous mismatch\n            of chips was detected. Chip recognition may fail either\n            because the chips are not supported by the system,\n            or because the Vpp voltage required to identify chips\n            has been disabled via the programming jumper.\n            The ciscoFlashDeviceProgrammingJumper, ciscoFlashChipCode,\n            and ciscoFlashChipDescr objects can be examined to get\n            more details on the cause of this status\n            * runFromFlash (RFF) if current image is running from\n            this partition.\n            The ciscoFlashPartitionUpgradeMethod object will then\n            indicate whether the Flash Load Helper can be used\n            to write a file to this partition or not.\n            \n            * readWrite if partition is programmable."
            },
            "ciscoFlashPartitionUpgradeMethod": {
              "type": "string",
              "description": "Flash partition upgrade method, ie., method by which\n            new files can be downloaded into the partition.\n            FLH stands for Flash Load Helper, a feature provided\n            on run-from-Flash systems for upgrading Flash. This\n            feature uses the bootstrap code in ROMs to help in\n            automatic download.\n            This object should be retrieved if the partition\n            status is runFromFlash(2).\n            If the partition status is readOnly(1), the upgrade\n            method would depend on the reason for the readOnly\n            status. For eg., it may simply be a matter of installing\n            the programming jumper, or it may require execution of a\n            later version of software that supports the Flash chips.\n            \n            unknown      -  the current system image does not know\n                            how Flash can be programmed. A possible\n                            method would be to reload the ROM image\n                            and perform the upgrade manually.\n            rxbootFLH    -  the Flash Load Helper is available to\n                            download files to Flash. A copy-to-flash\n                            command can be used and this system image\n                            will automatically reload the Rxboot image\n                            in ROM and direct it to carry out the\n                            download request.\n            direct       -  will be done directly by this image."
            },
            "ciscoFlashPartitionName": {
              "type": "string",
              "description": "Flash partition name used to refer to a partition\n            by the system. This can be any alpha-numeric character\n            string of the form AAAAAAAAnn, where A represents an\n            optional alpha character and n a numeric character.\n            Any numeric characters must always form the trailing\n            part of the string. The system will strip off the alpha\n            characters and use the numeric portion to map to a\n            partition index.\n            Flash operations get directed to a device partition\n            based on this name.\n            The system has a concept of a default partition. This\n            would be the first partition in the device. The system\n            directs an operation to the default partition whenever\n            a partition name is not specified.\n            The partition name is therefore mandatory except when\n            the operation is being done on the default partition, or\n            the device has just one partition (is not partitioned).",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashPartitionNeedErasure": {
              "type": "boolean",
              "description": "This object indicates whether a partition requires\n            erasure before any write operations can be done in it.\n            A management station should therefore retrieve this\n            object prior to attempting any write operation.\n            A partition requires erasure after it becomes full\n            free space left is less than or equal to the\n            (filesystem file header size).\n            A partition also requires erasure if the system does\n            not find the existence of any file system when it\n            boots up.\n            The partition may be erased explicitly through the\n            erase(5) command, or by using the copyToFlashWithErase(1)\n            command.\n            If a copyToFlashWithoutErase(2) command is issued\n            when this object has the TRUE value, the command\n            will fail."
            },
            "ciscoFlashPartitionFileNameLength": {
              "type": "integer",
              "description": "Maximum file name length supported by the file\n            system.\n            Max file name length will depend on the file\n            system implemented. Today, all file systems\n            support a max length of at least 48 bytes.\n            A management entity must use this object when\n            prompting a user for, or deriving the Flash file\n            name length.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashPartitionSizeExtended": {
              "type": "integer",
              "description": "Flash partition size. It should be an integral\n            multiple of ciscoFlashDeviceMinPartitionSize.\n            If there is a single partition, this size will be equal\n            to ciscoFlashDeviceSize.\n            \n            This object is a 64-bit version of ciscoFlashPartitionSize",
              "minimum": 0
            },
            "ciscoFlashPartitionFreeSpaceExtended": {
              "type": "integer",
              "description": "Free space within a Flash partition.\n            Note that the actual size of a file in Flash includes\n            a small overhead that represents the file system's\n            file header.\n            Certain file systems may also have a partition or\n            device header overhead to be considered when\n            computing the free space.\n            Free space will be computed as total partition size\n            less size of all existing files (valid/invalid/deleted\n            files and including file header of each file),\n            less size of any partition header, less size of\n            header of next file to be copied in. In short, this\n            object will give the size of the largest file that\n            can be copied in. The management entity will not be\n            expected to know or use any overheads such as file\n            and partition header lengths, since such overheads\n            may vary from file system to file system.\n            Deleted files in Flash do not free up space.\n            A partition may have to be erased in order to reclaim\n            the space occupied by files.\n            \n            This object is a 64-bit version of ciscoFlashPartitionFreeSpace",
              "minimum": 0
            },
            "ciscoFlashPartitionLowSpaceNotifThreshold": {
              "type": "string",
              "description": "This object specifies the minimum threshold value in percentage\n            of free space for each partition. If the free space available\n            goes below this threshold value and if\n            ciscoFlashPartionLowSpaceNotifEnable is set to true,\n            ciscoFlashPartitionLowSpaceNotif will be generated. When the\n            available free space comes back to the threshold value\n            ciscoFlashPartionLowSpaceRecoveryNotif will be generated.",
              "x-yang-type": "cisco-qos:Percent"
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashFileEntry": {
        "type": "array",
        "description": "An entry in the table of Flash file properties\n          for each initialized Flash partition. Each entry\n          represents a file and gives details about the file.\n          An entry is indexed using the device number,\n          partition number within the device, and file\n          number within the partition.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashDeviceIndex": {
              "type": "string",
              "description": "ciscoFlashDeviceIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashPartitionIndex": {
              "type": "string",
              "description": "ciscoFlashPartitionIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashFileIndex": {
              "type": "integer",
              "description": "Flash file sequence number used to index within\n            a Flash partition directory table.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashFileSize": {
              "type": "integer",
              "description": "Size of the file in bytes. Note that this size does\n            not include the size of the filesystem file header.\n            File size will always be non-zero.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashFileChecksum": {
              "type": "string",
              "description": "File checksum stored in the file header. This\n            checksum is computed and stored when the file is\n            written into Flash. It serves to validate the data\n            written into Flash.\n            Whereas the system will generate and store the checksum\n            internally in hexadecimal form, this object will\n            provide the checksum in a string form.\n            The checksum will be available for all valid and\n            invalid-checksum files.",
              "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
            },
            "ciscoFlashFileStatus": {
              "type": "string",
              "description": "Status of a file.\n            A file could be explicitly deleted if the file system\n            supports such a user command facility. Alternately,\n            an existing good file would be automatically deleted\n            if another good file with the same name were copied in.\n            Note that deleted files continue to occupy prime\n            Flash real estate.\n            \n            A file is marked as having an invalid checksum if any\n            checksum mismatch was detected while writing or reading\n            the file. Incomplete files (files truncated either\n            because of lack of free space, or a network download\n            failure) are also written with a bad checksum and\n            marked as invalid."
            },
            "ciscoFlashFileName": {
              "type": "string",
              "description": "Flash file name as specified by the user copying in\n            the file. The name should not include the colon (:)\n            character as it is a special separator character used\n            to delineate the device name, partition name, and the\n            file name.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashFileType": {
              "type": "string",
              "description": "Type of the file.",
              "x-yang-type": "CISCO-FLASH-MIB:FlashFileType"
            },
            "ciscoFlashFileDate": {
              "type": "string",
              "description": "The time at which this file was created.",
              "x-yang-type": "snmpv2-tc:DateAndTime"
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashFileByTypeEntry": {
        "type": "array",
        "description": "ciscoFlashFileByTypeEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashFileType": {
              "type": "string",
              "description": "ciscoFlashFileType",
              "x-yang-type": "leafref"
            },
            "ciscoFlashDeviceIndex": {
              "type": "string",
              "description": "ciscoFlashDeviceIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashPartitionIndex": {
              "type": "string",
              "description": "ciscoFlashPartitionIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashFileIndex": {
              "type": "string",
              "description": "ciscoFlashFileIndex",
              "x-yang-type": "leafref"
            },
            "ciscoFlashFileByTypeSize": {
              "type": "integer",
              "description": "This object represents exactly the\n            same info as ciscoFlashFileSize\n            object in ciscoFlashFileTable.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashFileByTypeChecksum": {
              "type": "string",
              "description": "This object represents exactly the\n            same info as ciscoFlashFileChecksum\n            object in ciscoFlashFileTable.",
              "x-yang-type": "CISCO-FLASH-MIB:ChecksumString"
            },
            "ciscoFlashFileByTypeStatus": {
              "type": "string",
              "description": "This object represents exactly the\n            same info as ciscoFlashFileStatus\n            object in ciscoFlashFileTable."
            },
            "ciscoFlashFileByTypeName": {
              "type": "string",
              "description": "This object represents exactly the\n            same info as ciscoFlashFileName\n            object in ciscoFlashFileTable.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashFileByTypeDate": {
              "type": "string",
              "description": "This object represents exactly the\n            same info as ciscoFlashFileDate\n            object in ciscoFlashFileTable.",
              "x-yang-type": "snmpv2-tc:DateAndTime"
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashCopyEntry": {
        "type": "array",
        "description": "ciscoFlashCopyEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashCopySerialNumber": {
              "type": "integer",
              "description": "Object which specifies a unique entry in the\n            table. A management station wishing to initiate a\n            copy operation should use a pseudo-random value for\n            this object when creating or modifying an instance of\n            a ciscoFlashCopyEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashCopyCommand": {
              "type": "string",
              "description": "The copy command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the invalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            copyToFlashWithErase    Copy a file to flash; erase\n                                    flash before copy.\n                                    Use the TFTP or rcp protocol.\n            copyToFlashWithoutErase Copy a file to flash; do not\n                                    erase.\n                                    Note that this command will fail\n                                    if the PartitionNeedErasure\n                                    object specifies that the\n                                    partition being copied to needs\n                                    erasure.\n                                    Use the TFTP or rcp protocol.\n            copyFromFlash           Copy a file from flash using\n                                    the TFTP, rcp or lex protocol.\n                                    Note that the lex protocol\n                                    can only be used to copy to a\n                                    lex device.\n            copyFromFlhLog          Copy contents of FLH log to\n                                    server using TFTP protocol.\n            \n            \n            Command table           Parameters\n            copyToFlashWithErase    CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyToFlashWithoutErase CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlash           CopyProtocol\n                                    CopyServerAddress\n                                    CopySourceName\n                                    CopyDestinationName (opt)\n                                    CopyRemoteUserName (opt)\n                                    CopyNotifyOnCompletion (opt)\n            copyFromFlhLog          CopyProtocol\n                                    CopyServerAddress\n                                    CopyDestinationName\n                                    CopyNotifyOnCompletion (opt)"
            },
            "ciscoFlashCopyProtocol": {
              "type": "string",
              "description": "The protocol to be used for any copy. Optional.\n            Will default to tftp if not specified.\n            \n            Since feature support depends on a software release,\n            version number within the release, platform, and\n            maybe the image type (subset type), a management\n            station would be expected to somehow determine\n            the protocol support for a command."
            },
            "ciscoFlashCopyServerAddress": {
              "type": "string",
              "description": "The server address to be used for any copy. Optional.\n            Will default to 'FFFFFFFF'H  (or 255.255.255.255).\n            \n            Since this object can just hold only IPv4 Transport\n            type, it is deprecated and replaced by\n            ciscoFlashCopyServerAddrRev1.",
              "format": "inet:ipv4-address"
            },
            "ciscoFlashCopySourceName": {
              "type": "string",
              "description": "Source file name, either in Flash or on a server,\n            depending on the type of copy command. Mandatory.\n            \n            For a copy from Flash:\n            File name must be of the form\n                    [device>:][:]\n            where  is a value obtained from FlashDeviceName,\n                     is obtained from FlashPartitionName\n                and  is the name of a file in Flash.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For a copy to Flash, the file name will be as per\n            the file naming conventions and path to the file on\n            the server.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashCopyDestinationName": {
              "type": "string",
              "description": "Destination file name.\n            \n            For a copy to Flash:\n            File name must be of the form\n                    {device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is any character string that does not have\n            embedded colon characters.\n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            If <file> is not specified, it will default to <file>\n            specified in ciscoFlashCopySourceName.\n            \n            For a copy from Flash via tftp or rcp, the file name will be\n            as per the file naming conventions and destination sub-directory\n            on the server. If not specified, <file> from the source\n            file name will be used.\n            For a copy from Flash via lex, this string will consist\n            of numeric characters specifying the interface on the\n            lex box that will receive the source flash image.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashPartitioningEntry": {
        "type": "array",
        "description": "ciscoFlashPartitioningEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashPartitioningSerialNumber": {
              "type": "integer",
              "description": "Object which specifies a unique entry in the partitioning\n            operations table. A management station wishing to initiate\n            a partitioning operation should use a pseudo-random value\n            for this object when creating or modifying an instance of\n            a ciscoFlashPartitioningEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashPartitioningCommand": {
              "type": "string",
              "description": "The partitioning command to be executed. Mandatory.\n            If the command is unsupported, the\n            partitioningInvalidOperation\n            error will be reported in the operation status.\n            \n            Command                 Remarks\n            partition               Partition a Flash device.\n                                    All the prerequisites for\n                                    partitioning must be met for\n                                    this command to succeed.\n            \n            Command table           Parameters\n            1) partition            PartitioningDestinationName\n                                    PartitioningPartitionCount\n                                    PartitioningPartitionSizes (opt)\n                                    PartitioningNotifyOnCompletion (opt)"
            },
            "ciscoFlashPartitioningDestinationName": {
              "type": "string",
              "description": "Destination device name. This name will be the value\n            obtained from FlashDeviceName.\n            If the name is not specified, the default Flash device\n            will be assumed.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashPartitioningPartitionCount": {
              "type": "integer",
              "description": "This object is used to specify the number of\n            partitions to be created. Its value cannot exceed\n            the value of ciscoFlashDeviceMaxPartitions.\n            \n            To undo partitioning (revert to a single partition),\n            this object must have the value 1.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ciscoFlashPartitioningPartitionSizes": {
              "type": "string",
              "description": "This object is used to explicitly specify the size\n            of each partition to be created.\n            The size of each partition will be in units of\n            ciscoFlashDeviceMinPartitionSize.\n            The value of this object will be in the form:\n                    <part1>:<part2>...:<partn>\n            \n            If partition sizes are not specified, the system\n            will calculate default sizes based on the partition\n            count, the minimum partition size, and the device\n            size. Partition size need not be specified when\n            undoing partitioning (partition count is 1).\n            If partition sizes are specified, the number of\n            sizes specified must exactly match the partition\n            count. If not, the partitioning command will be\n            rejected with the invalidPartitionSizes error .",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashPartitioningStatus": {
              "type": "string",
              "description": "The status of the specified partitioning operation.\n            partitioningInProgress :\n                    specified operation is active\n            \n            partitioningOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            partitioningInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            partitioningInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            partitioningInvalidPartitionCount :\n                    invalid partition count specified for the\n                    partitioning command\n            \n            partitioningInvalidPartitionSizes :\n                    invalid partition size, or invalid count of\n                    partition sizes\n            \n            partitioningDeviceBusy :\n                    specified device is in use and locked by\n                    another process\n            \n            partitioningDeviceOpenError :\n                    invalid device name\n            \n            partitioningDeviceError :\n                    device read, write or erase error\n            \n            partitioningNoMemory :\n                    system running low on memory\n            \n            partitioningUnknownFailure :\n                    failure unknown"
            },
            "ciscoFlashPartitioningNotifyOnCompletion": {
              "type": "boolean",
              "description": "Specifies whether or not a notification should be\n            generated on the completion of the partitioning operation.\n            If specified, ciscoFlashPartitioningCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
            },
            "ciscoFlashPartitioningTime": {
              "type": "string",
              "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
              "x-yang-type": "yang:timeticks"
            },
            "ciscoFlashPartitioningEntryStatus": {
              "type": "string",
              "description": "The status of this table entry.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "CISCO-FLASH-MIB_ciscoFlashMiscOpEntry": {
        "type": "array",
        "description": "ciscoFlashMiscOpEntry",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ciscoFlashMiscOpSerialNumber": {
              "type": "integer",
              "description": "Object which specifies a unique entry in the\n            table. A management station wishing to initiate a\n            flash operation should use a pseudo-random value for\n            this object when creating or modifying an instance of\n            a ciscoFlashMiscOpEntry.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ciscoFlashMiscOpCommand": {
              "type": "string",
              "description": "The command to be executed. Mandatory.\n            Note that it is possible for a system to support\n            multiple file systems (different file systems on\n            different Flash devices, or different file systems\n            on different partitions within a device). Each such\n            file system may support only a subset of these commands.\n            If a command is unsupported, the miscOpInvalidOperation(3)\n            error will be reported in the operation status.\n            \n            Command         Remarks\n            erase           Erase flash.\n            verify          Verify flash file checksum.\n            delete          Delete a file.\n            undelete        Revive a deleted file .\n                            Note that there are limits on\n                            the number of times a file can\n                            be deleted and undeleted. When\n                            this limit is exceeded, the\n                            system will return the appropriate\n                            error.\n            squeeze         Recover space occupied by\n                            deleted files. This command\n                            preserves the good files, erases\n                            out the file system, then restores\n                            the preserved good files.\n            format          Format a flash device.\n            \n            Command table   Parameters\n            erase           MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            verify          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            delete          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            undelete        MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            squeeze         MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)\n            format          MiscOpDestinationName\n                            MiscOpNotifyOnCompletion (opt)"
            },
            "ciscoFlashMiscOpDestinationName": {
              "type": "string",
              "description": "Destination file, or partition name.\n            File name must be of the form\n                    [device>:][<partition>:]<file>\n            where <device> is a value obtained from FlashDeviceName,\n                  <partition> is obtained from FlashPartitionName\n              and <file> is the name of a file in Flash.\n            While leading and/or trailing whitespaces are acceptable,\n            no whitespaces are allowed within the path itself.\n            \n            A management station could derive its own partition name\n            as per the description for the ciscoFlashPartitionName\n            object.\n            If <device> is not specified, the default Flash device\n            will be assumed.\n            If <partition> is not specified, the default partition\n            will be assumed. If a device is not partitioned into 2\n            or more partitions, this value may be left out.\n            \n            For an operation on a partition, eg., the erase\n            command, this object would specify the partition name\n            in the form:\n                    [device>:][<partition>:]",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "ciscoFlashMiscOpStatus": {
              "type": "string",
              "description": "The status of the specified operation.\n            miscOpInProgress :\n                    specified operation is active\n            \n            miscOpOperationSuccess :\n                    specified operation is supported and completed\n                    successfully\n            \n            miscOpInvalidOperation :\n                    command invalid or command-protocol-device\n                    combination unsupported\n            \n            miscOpInvalidDestName :\n                    invalid target name (file or partition or\n                    device name) specified\n            \n            miscOpDeviceBusy :\n                    specified device is in use and locked by another\n                    process\n            \n            miscOpDeviceOpenError :\n                    invalid device name\n            \n            miscOpDeviceError :\n                    device read, write or erase error\n            \n            miscOpDeviceNotProgrammable :\n                    device is read-only but a write or erase\n                    operation was specified\n            \n            miscOpFileOpenError :\n                    invalid file name; file not found in partition\n            \n            miscOpFileDeleteFailure :\n                    file could not be deleted; delete count exceeded\n            \n            miscOpFileUndeleteFailure :\n                    file could not be undeleted; undelete count\n                    exceeded\n            \n            miscOpFileChecksumError :\n                    file has a bad checksum\n            \n            miscOpNoMemory :\n                    system running low on memory\n            \n            miscOpUnknownFailure :\n                    failure unknown\n            \n            miscOpSqueezeFailure :\n                    the squeeze operation failed\n            \n            miscOpNoSuchFile :\n                    a valid but nonexistent file name was specified\n            \n            miscOpFormatFailure :\n                    the format operation failed"
            },
            "ciscoFlashMiscOpNotifyOnCompletion": {
              "type": "boolean",
              "description": "Specifies whether or not a notification should be\n            generated on the completion of an operation.\n            If specified, ciscoFlashMiscOpCompletionTrap\n            will be generated. It is the responsibility of the\n            management entity to ensure that the SNMP administrative\n            model is configured in such a way as to allow the\n            notification to be delivered."
            },
            "ciscoFlashMiscOpTime": {
              "type": "string",
              "description": "Time taken for the operation. This object will\n            be like a stopwatch, starting when the operation\n            starts, stopping when the operation completes.\n            If a management entity keeps a database of completion\n            times for various operations, it can then use the\n            stopwatch capability to display percentage completion\n            time.",
              "x-yang-type": "yang:timeticks"
            },
            "ciscoFlashMiscOpEntryStatus": {
              "type": "string",
              "description": "The status of this table entry.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "CISCO-FLASH-MIB",
      "description": "MIB operations for CISCO-FLASH-MIB"
    }
  ]
}