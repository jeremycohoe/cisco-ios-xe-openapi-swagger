{
  "openapi": "3.0.0",
  "info": {
    "title": "MPLS-VPN-MIB MIB API",
    "version": "1.0.0",
    "description": "This MIB contains managed object definitions for the\n    Multiprotocol Label Switching (MPLS)/Border Gateway\n    \n    \n    Protocol (BGP) Virtual Private Networks (VPNs) as\n    defined in : Rosen, E., Viswanathan, A., and R.\n    Callon, Multiprotocol Label Switching Architecture,\n    RFC3031, January 2001.\n\n\u26a0\ufe0f **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/MPLS-VPN-MIB:mplsVpnScalars": {
      "get": {
        "summary": "Get mplsVpnScalars data",
        "description": "Retrieve mplsVpnScalars operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnScalars"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnInterfaceConfTable": {
      "get": {
        "summary": "Get mplsVpnInterfaceConfTable data",
        "description": "Retrieve mplsVpnInterfaceConfTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnInterfaceConfTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnInterfaceConfTable/mplsVpnInterfaceConfEntry": {
      "get": {
        "summary": "Get mplsVpnInterfaceConfEntry list",
        "description": "Retrieve list of mplsVpnInterfaceConfEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnInterfaceConfEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnInterfaceConfTable/mplsVpnInterfaceConfEntry={mplsVpnVrfName mplsVpnInterfaceConfIndex}": {
      "get": {
        "summary": "Get mplsVpnInterfaceConfEntry entry",
        "description": "Retrieve specific mplsVpnInterfaceConfEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnInterfaceConfIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnInterfaceConfEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfTable": {
      "get": {
        "summary": "Get mplsVpnVrfTable data",
        "description": "Retrieve mplsVpnVrfTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfTable/mplsVpnVrfEntry": {
      "get": {
        "summary": "Get mplsVpnVrfEntry list",
        "description": "Retrieve list of mplsVpnVrfEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfTable/mplsVpnVrfEntry={mplsVpnVrfName}": {
      "get": {
        "summary": "Get mplsVpnVrfEntry entry",
        "description": "Retrieve specific mplsVpnVrfEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTargetTable": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTargetTable data",
        "description": "Retrieve mplsVpnVrfRouteTargetTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTargetTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTargetTable/mplsVpnVrfRouteTargetEntry": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTargetEntry list",
        "description": "Retrieve list of mplsVpnVrfRouteTargetEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTargetEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTargetTable/mplsVpnVrfRouteTargetEntry={mplsVpnVrfName mplsVpnVrfRouteTargetIndex mplsVpnVrfRouteTargetType}": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTargetEntry entry",
        "description": "Retrieve specific mplsVpnVrfRouteTargetEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfRouteTargetIndex mplsVpnVrfRouteTargetType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTargetEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrAddrTable": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrAddrTable data",
        "description": "Retrieve mplsVpnVrfBgpNbrAddrTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrAddrTable/mplsVpnVrfBgpNbrAddrEntry": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrAddrEntry list",
        "description": "Retrieve list of mplsVpnVrfBgpNbrAddrEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrAddrTable/mplsVpnVrfBgpNbrAddrEntry={mplsVpnVrfName mplsVpnInterfaceConfIndex mplsVpnVrfBgpNbrIndex}": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrAddrEntry entry",
        "description": "Retrieve specific mplsVpnVrfBgpNbrAddrEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnInterfaceConfIndex mplsVpnVrfBgpNbrIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrPrefixTable": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrPrefixTable data",
        "description": "Retrieve mplsVpnVrfBgpNbrPrefixTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrPrefixTable/mplsVpnVrfBgpNbrPrefixEntry": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrPrefixEntry list",
        "description": "Retrieve list of mplsVpnVrfBgpNbrPrefixEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrPrefixTable/mplsVpnVrfBgpNbrPrefixEntry={mplsVpnVrfName mplsVpnVrfBgpPathAttrIpAddrPrefix mplsVpnVrfBgpPathAttrIpAddrPrefixLen mplsVpnVrfBgpPathAttrPeer}": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrPrefixEntry entry",
        "description": "Retrieve specific mplsVpnVrfBgpNbrPrefixEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfBgpPathAttrIpAddrPrefix mplsVpnVrfBgpPathAttrIpAddrPrefixLen mplsVpnVrfBgpPathAttrPeer",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTable": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTable data",
        "description": "Retrieve mplsVpnVrfRouteTable operational data from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTable"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTable/mplsVpnVrfRouteEntry": {
      "get": {
        "summary": "Get mplsVpnVrfRouteEntry list",
        "description": "Retrieve list of mplsVpnVrfRouteEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTable/mplsVpnVrfRouteEntry={mplsVpnVrfName mplsVpnVrfRouteDest mplsVpnVrfRouteMask mplsVpnVrfRouteTos mplsVpnVrfRouteNextHop}": {
      "get": {
        "summary": "Get mplsVpnVrfRouteEntry entry",
        "description": "Retrieve specific mplsVpnVrfRouteEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfRouteDest mplsVpnVrfRouteMask mplsVpnVrfRouteTos mplsVpnVrfRouteNextHop",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnInterfaceConfEntry": {
      "get": {
        "summary": "Get mplsVpnInterfaceConfEntry list",
        "description": "Retrieve list of mplsVpnInterfaceConfEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnInterfaceConfEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnInterfaceConfEntry={mplsVpnVrfName mplsVpnInterfaceConfIndex}": {
      "get": {
        "summary": "Get mplsVpnInterfaceConfEntry entry",
        "description": "Retrieve specific mplsVpnInterfaceConfEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnInterfaceConfIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnInterfaceConfEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfEntry": {
      "get": {
        "summary": "Get mplsVpnVrfEntry list",
        "description": "Retrieve list of mplsVpnVrfEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfEntry={mplsVpnVrfName}": {
      "get": {
        "summary": "Get mplsVpnVrfEntry entry",
        "description": "Retrieve specific mplsVpnVrfEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTargetEntry": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTargetEntry list",
        "description": "Retrieve list of mplsVpnVrfRouteTargetEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTargetEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteTargetEntry={mplsVpnVrfName mplsVpnVrfRouteTargetIndex mplsVpnVrfRouteTargetType}": {
      "get": {
        "summary": "Get mplsVpnVrfRouteTargetEntry entry",
        "description": "Retrieve specific mplsVpnVrfRouteTargetEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfRouteTargetIndex mplsVpnVrfRouteTargetType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteTargetEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrAddrEntry": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrAddrEntry list",
        "description": "Retrieve list of mplsVpnVrfBgpNbrAddrEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrAddrEntry={mplsVpnVrfName mplsVpnInterfaceConfIndex mplsVpnVrfBgpNbrIndex}": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrAddrEntry entry",
        "description": "Retrieve specific mplsVpnVrfBgpNbrAddrEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnInterfaceConfIndex mplsVpnVrfBgpNbrIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrPrefixEntry": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrPrefixEntry list",
        "description": "Retrieve list of mplsVpnVrfBgpNbrPrefixEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfBgpNbrPrefixEntry={mplsVpnVrfName mplsVpnVrfBgpPathAttrIpAddrPrefix mplsVpnVrfBgpPathAttrIpAddrPrefixLen mplsVpnVrfBgpPathAttrPeer}": {
      "get": {
        "summary": "Get mplsVpnVrfBgpNbrPrefixEntry entry",
        "description": "Retrieve specific mplsVpnVrfBgpNbrPrefixEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfBgpPathAttrIpAddrPrefix mplsVpnVrfBgpPathAttrIpAddrPrefixLen mplsVpnVrfBgpPathAttrPeer",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixEntry"
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteEntry": {
      "get": {
        "summary": "Get mplsVpnVrfRouteEntry list",
        "description": "Retrieve list of mplsVpnVrfRouteEntry entries from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteEntry"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-VPN-MIB:mplsVpnVrfRouteEntry={mplsVpnVrfName mplsVpnVrfRouteDest mplsVpnVrfRouteMask mplsVpnVrfRouteTos mplsVpnVrfRouteNextHop}": {
      "get": {
        "summary": "Get mplsVpnVrfRouteEntry entry",
        "description": "Retrieve specific mplsVpnVrfRouteEntry entry by key from MIB",
        "tags": [
          "MPLS-VPN-MIB"
        ],
        "parameters": [
          {
            "name": "mplsVpnVrfName mplsVpnVrfRouteDest mplsVpnVrfRouteMask mplsVpnVrfRouteTos mplsVpnVrfRouteNextHop",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/MPLS-VPN-MIB_mplsVpnVrfRouteEntry"
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "MPLS-VPN-MIB_MPLS-VPN-MIB": {
        "type": "object",
        "description": "The number of VRFs which are configured on this node.",
        "properties": {
          "mplsVpnConfiguredVrfs": {
            "type": "integer",
            "description": "The number of VRFs which are configured on this node.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnActiveVrfs": {
            "type": "integer",
            "description": "The number of VRFs which are active on this node.\n          That is, those VRFs whose corresponding mplsVpnVrfOperStatus \n          object value is equal to operational (1).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnConnectedInterfaces": {
            "type": "integer",
            "description": "Total number of interfaces connected to a VRF.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnNotificationEnable": {
            "type": "boolean",
            "description": "If this object is true, then it enables the\n          generation of all notifications defined in \n          this MIB."
          },
          "mplsVpnVrfConfMaxPossibleRoutes": {
            "type": "integer",
            "description": "Denotes maximum number of routes which the device\n          will allow all VRFs jointly to hold. If this value is\n          set to 0, this indicates that the device is \n          unable to determine the absolute maximum. In this\n          case, the configured maximum MAY not actually\n          be allowed by the device.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfName": {
            "type": "string",
            "description": "mplsVpnVrfName",
            "x-yang-type": "leafref"
          },
          "mplsVpnInterfaceConfIndex": {
            "type": "string",
            "description": "mplsVpnInterfaceConfIndex",
            "x-yang-type": "leafref"
          },
          "mplsVpnInterfaceLabelEdgeType": {
            "type": "string",
            "description": "Either the providerEdge(0) (PE) or customerEdge(1)\n            (CE) bit MUST be set."
          },
          "mplsVpnInterfaceVpnClassification": {
            "type": "string",
            "description": "Denotes whether this link participates in a\n            carrier-of-carrier's, enterprise, or inter-provider\n            scenario."
          },
          "mplsVpnInterfaceVpnRouteDistProtocol": {
            "type": "string",
            "description": "Denotes the route distribution protocol across the\n            PE-CE link. Note that more than one routing protocol\n            may be enabled at the same time."
          },
          "mplsVpnInterfaceConfStorageType": {
            "type": "string",
            "description": "The storage type for this entry.",
            "x-yang-type": "snmpv2-tc:StorageType"
          },
          "mplsVpnInterfaceConfRowStatus": {
            "type": "string",
            "description": "The row status for this entry. This value is\n            used to create a row in this table, signifying\n            that the specified interface is to be associated\n            with the specified interface. If this operation\n            succeeds, the interface will have been associated,\n            otherwise the agent would not allow the association. \n            If the agent only allows read-only operations on\n            this table, it will create entries in this table\n            as they are created.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "mplsVpnVrfDescription": {
            "type": "string",
            "description": "The human-readable description of this VRF.",
            "x-yang-type": "snmp-framework:SnmpAdminString"
          },
          "mplsVpnVrfRouteDistinguisher": {
            "type": "string",
            "description": "The route distinguisher for this VRF.",
            "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
          },
          "mplsVpnVrfCreationTime": {
            "type": "string",
            "description": "The time at which this VRF entry was created.",
            "x-yang-type": "yang:timestamp"
          },
          "mplsVpnVrfOperStatus": {
            "type": "string",
            "description": "Denotes whether a VRF is operational or not. A VRF is \n            up(1) when at least one interface associated with the\n            VRF, which ifOperStatus is up(1). A VRF is down(2) when:\n            \n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            \n            b. There are no interfaces associated with the VRF."
          },
          "mplsVpnVrfActiveInterfaces": {
            "type": "integer",
            "description": "Total number of interfaces connected to this VRF with \n            \n            \n            ifOperStatus = up(1). \n            \n            This counter should be incremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from down(2) to up(1).\n            \n            b. When an interface with ifOperStatus = up(1) is connected\n               to this VRF.\n            \n            This counter should be decremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from up(1) to down(2).\n            \n            b. When one of the connected interfaces with \n               ifOperStatus = up(1) gets disconnected from this VRF.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfAssociatedInterfaces": {
            "type": "integer",
            "description": "Total number of interfaces connected to this VRF \n            (independent of ifOperStatus type).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfConfMidRouteThreshold": {
            "type": "integer",
            "description": "Denotes mid-level water marker for the number\n            of routes which  this VRF may hold.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfConfHighRouteThreshold": {
            "type": "integer",
            "description": "Denotes high-level water marker for the number of\n            routes which  this VRF may hold.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfConfMaxRoutes": {
            "type": "integer",
            "description": "Denotes maximum number of routes which this VRF is\n            configured to hold. This value MUST be less than or\n            equal to mplsVrfMaxPossibleRoutes unless it is set\n            to 0.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfConfLastChanged": {
            "type": "string",
            "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
            "x-yang-type": "yang:timestamp"
          },
          "mplsVpnVrfConfRowStatus": {
            "type": "string",
            "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "mplsVpnVrfConfStorageType": {
            "type": "string",
            "description": "The storage type for this entry.",
            "x-yang-type": "snmpv2-tc:StorageType"
          },
          "mplsVpnVrfRouteTargetIndex": {
            "type": "integer",
            "description": "Auxiliary index for route-targets configured for a \n            particular VRF.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfRouteTargetType": {
            "type": "string",
            "description": "The route target export distribution type."
          },
          "mplsVpnVrfRouteTarget": {
            "type": "string",
            "description": "The route target distribution policy.",
            "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
          },
          "mplsVpnVrfRouteTargetDescr": {
            "type": "string",
            "description": "Description of the route target.",
            "x-yang-type": "snmpv2-tc:DisplayString"
          },
          "mplsVpnVrfRouteTargetRowStatus": {
            "type": "string",
            "description": "Row status for this entry.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "mplsVpnVrfBgpNbrIndex": {
            "type": "integer",
            "description": "This is a unique tertiary index for an entry in the\n            MplsVpnVrfBgpNbrAddrEntry Table.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfBgpNbrRole": {
            "type": "string",
            "description": "Denotes the role played by this EBGP neighbor\n            with respect to this VRF."
          },
          "mplsVpnVrfBgpNbrType": {
            "type": "string",
            "description": "Denotes the address family of the PE address.",
            "x-yang-type": "inet-address:InetAddressType"
          },
          "mplsVpnVrfBgpNbrAddr": {
            "type": "string",
            "description": "Denotes the EBGP neighbor address.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfBgpNbrRowStatus": {
            "type": "string",
            "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "mplsVpnVrfBgpNbrStorageType": {
            "type": "string",
            "description": "The storage type for this entry.",
            "x-yang-type": "snmpv2-tc:StorageType"
          },
          "mplsVpnVrfBgpPathAttrPeer": {
            "type": "string",
            "description": "The IP address of the peer where the path\n            information was learned.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfBgpPathAttrIpAddrPrefixLen": {
            "type": "integer",
            "description": "Length in bits of the IP address prefix\n            in the Network Layer Reachability\n            Information field.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfBgpPathAttrIpAddrPrefix": {
            "type": "string",
            "description": "An IP address prefix in the Network Layer\n            Reachability Information field.  This object\n            is an IP address containing the prefix with\n            length specified by mplsVpnVrfBgpPathAttrIpAddrPrefixLen.\n            Any bits beyond the length specified by\n            mplsVpnVrfBgpPathAttrIpAddrPrefixLen are zeroed.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfBgpPathAttrOrigin": {
            "type": "string",
            "description": "The ultimate origin of the path\n            information."
          },
          "mplsVpnVrfBgpPathAttrASPathSegment": {
            "type": "string",
            "description": "The sequence of AS path segments.  Each AS\n            path segment is represented by a triple\n            <type, length, value>.\n            \n             The type is a 1-octet field which has two\n             possible values:\n                 1      AS_SET: unordered set of ASs a\n                        route in the UPDATE\n                        message has traversed\n                 2      AS_SEQUENCE: ordered set of ASs\n                        a route in the UPDATE\n                        message has traversed.\n                        The length is a 1-octet field containing the\n            \n            \n                        number of ASs in the value field.\n            \n                        The value field contains one or more AS\n                        numbers, each AS is represented in the octet\n                        string as a pair of octets according to the\n                        following algorithm:\n            \n                        first-byte-of-pair = ASNumber / 256;\n                        second-byte-of-pair = ASNumber & 255;",
            "format": "binary"
          },
          "mplsVpnVrfBgpPathAttrNextHop": {
            "type": "string",
            "description": "The address of the border router that\n            should be used for the destination\n            network.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfBgpPathAttrMultiExitDisc": {
            "type": "integer",
            "description": "This metric is used to discriminate\n            between multiple exit points to an\n            adjacent autonomous system.  A value of -1\n            indicates the absence of this attribute.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfBgpPathAttrLocalPref": {
            "type": "integer",
            "description": "The originating BGP4 speaker's degree of\n            preference for an advertised route.  A\n            value of -1 indicates the absence of this\n            attribute.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfBgpPathAttrAtomicAggregate": {
            "type": "string",
            "description": "Whether or not the local system has\n            selected a less specific route without\n            selecting a more specific route."
          },
          "mplsVpnVrfBgpPathAttrAggregatorAS": {
            "type": "integer",
            "description": "The AS number of the last BGP4 speaker that\n            performed route aggregation.  A value of\n            zero (0) indicates the absence of this\n            attribute.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfBgpPathAttrAggregatorAddr": {
            "type": "string",
            "description": "The IP address of the last BGP4 speaker\n            that performed route aggregation.  A value\n            of 0.0.0.0 indicates the absence of this\n            attribute.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfBgpPathAttrCalcLocalPref": {
            "type": "integer",
            "description": "The degree of preference calculated by the\n            receiving BGP4 speaker for an advertised\n            route.  A value of -1 indicates the\n            absence of this attribute.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfBgpPathAttrBest": {
            "type": "string",
            "description": "An indication of whether or not this route\n            was chosen as the best BGP4 route."
          },
          "mplsVpnVrfBgpPathAttrUnknown": {
            "type": "string",
            "description": "One or more path attributes not understood\n            by this BGP4 speaker.  Size zero (0)\n            indicates the absence of such\n            attribute(s).  Octets beyond the maximum\n            size, if any, are not recorded by this\n            object.",
            "format": "binary"
          },
          "mplsVpnVrfRouteDest": {
            "type": "string",
            "description": "The destination IP address of this route.\n            This object may not take a Multicast (Class D)\n            address value.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteMask object is not equal to x.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfRouteDestAddrType": {
            "type": "string",
            "description": "The address type of the mplsVpnVrfRouteDest\n            entry.",
            "x-yang-type": "inet-address:InetAddressType"
          },
          "mplsVpnVrfRouteMask": {
            "type": "string",
            "description": "Indicate the mask to be logical-ANDed with the\n            destination  address  before  being compared to\n            the value  in  the  mplsVpnVrfRouteDest field.\n            For those  systems  that  do  not support\n            arbitrary subnet masks, an agent constructs the\n            value of the mplsVpnVrfRouteMask by reference\n            \n            \n            to the IP Address Class.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteDest object is not equal to\n            mplsVpnVrfRouteDest.",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfRouteMaskAddrType": {
            "type": "string",
            "description": "The address type of mplsVpnVrfRouteMask.",
            "x-yang-type": "inet-address:InetAddressType"
          },
          "mplsVpnVrfRouteTos": {
            "type": "integer",
            "description": "The IP TOS Field is used to specify the policy to\n            be applied to this route.  The encoding of IP TOS\n            is as specified  by  the  following convention.\n            Zero indicates the default path if no more\n            specific policy applies.\n            \n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            |                 |                       |     |\n            |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n            |                 |                       |     |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            \n                       IP TOS                IP TOS\n                  Field     Policy      Field     Policy\n                  Contents    Code      Contents    Code\n                  0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                  0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                  0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                  0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                  1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                  1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                  1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                  1 1 1 0  ==>  28      1 1 1 1  ==>  30.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfRouteNextHop": {
            "type": "string",
            "description": "On remote routes, the address of the next\n            system en route; Otherwise, 0.0.0.0. .",
            "x-yang-type": "inet-address:InetAddress"
          },
          "mplsVpnVrfRouteNextHopAddrType": {
            "type": "string",
            "description": "The address type of the mplsVpnVrfRouteNextHopAddrType\n            object.",
            "x-yang-type": "inet-address:InetAddressType"
          },
          "mplsVpnVrfRouteIfIndex": {
            "type": "string",
            "description": "The ifIndex value that identifies the local\n            interface  through  which  the next hop of this\n            route should be reached.",
            "x-yang-type": "if-mib:InterfaceIndexOrZero"
          },
          "mplsVpnVrfRouteType": {
            "type": "string",
            "description": "The type of route.  Note that local(3)  refers\n            to a route for which the next hop is the final\n            destination; remote(4) refers to a route for\n            that the next  hop is not the final destination.\n            Routes which do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject (2) refers to a route which, if matched,\n            discards the message as unreachable. This is used\n            in some protocols as a means of correctly aggregating\n            routes."
          },
          "mplsVpnVrfRouteProto": {
            "type": "string",
            "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway rout-\n            ing protocols is not  intended  to  imply  that\n            hosts should support those protocols."
          },
          "mplsVpnVrfRouteAge": {
            "type": "integer",
            "description": "The number of seconds since this route was\n            last updated or otherwise determined to be\n            correct. Note that no semantics of `too old'\n            can be implied except through knowledge of the\n            routing protocol by which the route was\n            learned.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfRouteInfo": {
            "type": "string",
            "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsi-\n            \n            \n            ble for this route, as determined by the  value\n            specified  in the route's mplsVpnVrfRouteProto\n            value. If this information is not present, its\n            value SHOULD be set to the OBJECT IDENTIFIER\n            { 0 0 }, which is a syntactically valid object\n            identif-ier, and any implementation conforming\n            to ASN.1 and the Basic Encoding Rules must be\n            able to generate and recognize this value.",
            "x-yang-type": "yang:object-identifier-128"
          },
          "mplsVpnVrfRouteNextHopAS": {
            "type": "integer",
            "description": "The Autonomous System Number of the Next Hop.\n            The semantics of this object are determined by\n            the routing-protocol specified in the route's\n            mplsVpnVrfRouteProto value. When this object is\n            unknown or not relevant its value should be set\n            to zero.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "mplsVpnVrfRouteMetric1": {
            "type": "integer",
            "description": "The primary routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfRouteMetric2": {
            "type": "integer",
            "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfRouteMetric3": {
            "type": "integer",
            "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfRouteMetric4": {
            "type": "integer",
            "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfRouteMetric5": {
            "type": "integer",
            "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "mplsVpnVrfRouteRowStatus": {
            "type": "string",
            "description": "Row status for this table. It is used according\n            to row installation and removal conventions.",
            "x-yang-type": "snmpv2-tc:RowStatus"
          },
          "mplsVpnVrfRouteStorageType": {
            "type": "string",
            "description": "Storage type value.",
            "x-yang-type": "snmpv2-tc:StorageType"
          },
          "mplsVpnScalars": {
            "type": "object",
            "description": "The number of VRFs which are configured on this node.",
            "properties": {
              "mplsVpnConfiguredVrfs": {
                "type": "integer",
                "description": "The number of VRFs which are configured on this node.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnActiveVrfs": {
                "type": "integer",
                "description": "The number of VRFs which are active on this node.\n          That is, those VRFs whose corresponding mplsVpnVrfOperStatus \n          object value is equal to operational (1).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnConnectedInterfaces": {
                "type": "integer",
                "description": "Total number of interfaces connected to a VRF.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnNotificationEnable": {
                "type": "boolean",
                "description": "If this object is true, then it enables the\n          generation of all notifications defined in \n          this MIB."
              },
              "mplsVpnVrfConfMaxPossibleRoutes": {
                "type": "integer",
                "description": "Denotes maximum number of routes which the device\n          will allow all VRFs jointly to hold. If this value is\n          set to 0, this indicates that the device is \n          unable to determine the absolute maximum. In this\n          case, the configured maximum MAY not actually\n          be allowed by the device.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "mplsVpnInterfaceConfTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS capability\n        and associated information.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "mplsVpnVrfName",
                "x-yang-type": "leafref"
              },
              "mplsVpnInterfaceConfIndex": {
                "type": "string",
                "description": "This is a unique index for an entry in the\n            MplsVPNInterfaceConfTable. A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            which are enabled for MPLS/BGP VPN functionality.",
                "x-yang-type": "if-mib:InterfaceIndex"
              },
              "mplsVpnInterfaceLabelEdgeType": {
                "type": "string",
                "description": "Either the providerEdge(0) (PE) or customerEdge(1)\n            (CE) bit MUST be set."
              },
              "mplsVpnInterfaceVpnClassification": {
                "type": "string",
                "description": "Denotes whether this link participates in a\n            carrier-of-carrier's, enterprise, or inter-provider\n            scenario."
              },
              "mplsVpnInterfaceVpnRouteDistProtocol": {
                "type": "string",
                "description": "Denotes the route distribution protocol across the\n            PE-CE link. Note that more than one routing protocol\n            may be enabled at the same time."
              },
              "mplsVpnInterfaceConfStorageType": {
                "type": "string",
                "description": "The storage type for this entry.",
                "x-yang-type": "snmpv2-tc:StorageType"
              },
              "mplsVpnInterfaceConfRowStatus": {
                "type": "string",
                "description": "The row status for this entry. This value is\n            used to create a row in this table, signifying\n            that the specified interface is to be associated\n            with the specified interface. If this operation\n            succeeds, the interface will have been associated,\n            otherwise the agent would not allow the association. \n            If the agent only allows read-only operations on\n            this table, it will create entries in this table\n            as they are created.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "mplsVpnVrfTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS/BGP VPN\n        VRF Table capability and associated information.\n        Entries in this table define VRF routing instances\n        associated with MPLS/VPN interfaces. Note that\n        multiple interfaces can belong to the same VRF\n        instance. The collection of all VRF instances\n        comprises an actual VPN.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "The human-readable name of this VPN. This MAY\n            be equivalent to the RFC2685 VPN-ID.",
                "x-yang-type": "MPLS-VPN-MIB:MplsVpnId"
              },
              "mplsVpnVrfDescription": {
                "type": "string",
                "description": "The human-readable description of this VRF.",
                "x-yang-type": "snmp-framework:SnmpAdminString"
              },
              "mplsVpnVrfRouteDistinguisher": {
                "type": "string",
                "description": "The route distinguisher for this VRF.",
                "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
              },
              "mplsVpnVrfCreationTime": {
                "type": "string",
                "description": "The time at which this VRF entry was created.",
                "x-yang-type": "yang:timestamp"
              },
              "mplsVpnVrfOperStatus": {
                "type": "string",
                "description": "Denotes whether a VRF is operational or not. A VRF is \n            up(1) when at least one interface associated with the\n            VRF, which ifOperStatus is up(1). A VRF is down(2) when:\n            \n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            \n            b. There are no interfaces associated with the VRF."
              },
              "mplsVpnVrfActiveInterfaces": {
                "type": "integer",
                "description": "Total number of interfaces connected to this VRF with \n            \n            \n            ifOperStatus = up(1). \n            \n            This counter should be incremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from down(2) to up(1).\n            \n            b. When an interface with ifOperStatus = up(1) is connected\n               to this VRF.\n            \n            This counter should be decremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from up(1) to down(2).\n            \n            b. When one of the connected interfaces with \n               ifOperStatus = up(1) gets disconnected from this VRF.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfAssociatedInterfaces": {
                "type": "integer",
                "description": "Total number of interfaces connected to this VRF \n            (independent of ifOperStatus type).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfConfMidRouteThreshold": {
                "type": "integer",
                "description": "Denotes mid-level water marker for the number\n            of routes which  this VRF may hold.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfConfHighRouteThreshold": {
                "type": "integer",
                "description": "Denotes high-level water marker for the number of\n            routes which  this VRF may hold.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfConfMaxRoutes": {
                "type": "integer",
                "description": "Denotes maximum number of routes which this VRF is\n            configured to hold. This value MUST be less than or\n            equal to mplsVrfMaxPossibleRoutes unless it is set\n            to 0.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfConfLastChanged": {
                "type": "string",
                "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                "x-yang-type": "yang:timestamp"
              },
              "mplsVpnVrfConfRowStatus": {
                "type": "string",
                "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              },
              "mplsVpnVrfConfStorageType": {
                "type": "string",
                "description": "The storage type for this entry.",
                "x-yang-type": "snmpv2-tc:StorageType"
              }
            }
          },
          "mplsVpnVrfRouteTargetTable": {
            "type": "object",
            "description": "This table specifies per-VRF route target association.\n        Each entry identifies a connectivity policy supported\n        as part of a VPN.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "mplsVpnVrfName",
                "x-yang-type": "leafref"
              },
              "mplsVpnVrfRouteTargetIndex": {
                "type": "integer",
                "description": "Auxiliary index for route-targets configured for a \n            particular VRF.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfRouteTargetType": {
                "type": "string",
                "description": "The route target export distribution type."
              },
              "mplsVpnVrfRouteTarget": {
                "type": "string",
                "description": "The route target distribution policy.",
                "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
              },
              "mplsVpnVrfRouteTargetDescr": {
                "type": "string",
                "description": "Description of the route target.",
                "x-yang-type": "snmpv2-tc:DisplayString"
              },
              "mplsVpnVrfRouteTargetRowStatus": {
                "type": "string",
                "description": "Row status for this entry.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              }
            }
          },
          "mplsVpnVrfBgpNbrAddrTable": {
            "type": "object",
            "description": "Each entry in this table specifies a per-interface \n        MPLS/EBGP neighbor.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "mplsVpnVrfName",
                "x-yang-type": "leafref"
              },
              "mplsVpnInterfaceConfIndex": {
                "type": "string",
                "description": "mplsVpnInterfaceConfIndex",
                "x-yang-type": "leafref"
              },
              "mplsVpnVrfBgpNbrIndex": {
                "type": "integer",
                "description": "This is a unique tertiary index for an entry in the\n            MplsVpnVrfBgpNbrAddrEntry Table.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfBgpNbrRole": {
                "type": "string",
                "description": "Denotes the role played by this EBGP neighbor\n            with respect to this VRF."
              },
              "mplsVpnVrfBgpNbrType": {
                "type": "string",
                "description": "Denotes the address family of the PE address.",
                "x-yang-type": "inet-address:InetAddressType"
              },
              "mplsVpnVrfBgpNbrAddr": {
                "type": "string",
                "description": "Denotes the EBGP neighbor address.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfBgpNbrRowStatus": {
                "type": "string",
                "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              },
              "mplsVpnVrfBgpNbrStorageType": {
                "type": "string",
                "description": "The storage type for this entry.",
                "x-yang-type": "snmpv2-tc:StorageType"
              }
            }
          },
          "mplsVpnVrfBgpNbrPrefixTable": {
            "type": "object",
            "description": "This table specifies per-VRF vpnv4 multi-protocol\n        prefixes supported by BGP.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "mplsVpnVrfName",
                "x-yang-type": "leafref"
              },
              "mplsVpnVrfBgpPathAttrPeer": {
                "type": "string",
                "description": "The IP address of the peer where the path\n            information was learned.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfBgpPathAttrIpAddrPrefixLen": {
                "type": "integer",
                "description": "Length in bits of the IP address prefix\n            in the Network Layer Reachability\n            Information field.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfBgpPathAttrIpAddrPrefix": {
                "type": "string",
                "description": "An IP address prefix in the Network Layer\n            Reachability Information field.  This object\n            is an IP address containing the prefix with\n            length specified by mplsVpnVrfBgpPathAttrIpAddrPrefixLen.\n            Any bits beyond the length specified by\n            mplsVpnVrfBgpPathAttrIpAddrPrefixLen are zeroed.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfBgpPathAttrOrigin": {
                "type": "string",
                "description": "The ultimate origin of the path\n            information."
              },
              "mplsVpnVrfBgpPathAttrASPathSegment": {
                "type": "string",
                "description": "The sequence of AS path segments.  Each AS\n            path segment is represented by a triple\n            <type, length, value>.\n            \n             The type is a 1-octet field which has two\n             possible values:\n                 1      AS_SET: unordered set of ASs a\n                        route in the UPDATE\n                        message has traversed\n                 2      AS_SEQUENCE: ordered set of ASs\n                        a route in the UPDATE\n                        message has traversed.\n                        The length is a 1-octet field containing the\n            \n            \n                        number of ASs in the value field.\n            \n                        The value field contains one or more AS\n                        numbers, each AS is represented in the octet\n                        string as a pair of octets according to the\n                        following algorithm:\n            \n                        first-byte-of-pair = ASNumber / 256;\n                        second-byte-of-pair = ASNumber & 255;",
                "format": "binary"
              },
              "mplsVpnVrfBgpPathAttrNextHop": {
                "type": "string",
                "description": "The address of the border router that\n            should be used for the destination\n            network.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfBgpPathAttrMultiExitDisc": {
                "type": "integer",
                "description": "This metric is used to discriminate\n            between multiple exit points to an\n            adjacent autonomous system.  A value of -1\n            indicates the absence of this attribute.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfBgpPathAttrLocalPref": {
                "type": "integer",
                "description": "The originating BGP4 speaker's degree of\n            preference for an advertised route.  A\n            value of -1 indicates the absence of this\n            attribute.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfBgpPathAttrAtomicAggregate": {
                "type": "string",
                "description": "Whether or not the local system has\n            selected a less specific route without\n            selecting a more specific route."
              },
              "mplsVpnVrfBgpPathAttrAggregatorAS": {
                "type": "integer",
                "description": "The AS number of the last BGP4 speaker that\n            performed route aggregation.  A value of\n            zero (0) indicates the absence of this\n            attribute.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfBgpPathAttrAggregatorAddr": {
                "type": "string",
                "description": "The IP address of the last BGP4 speaker\n            that performed route aggregation.  A value\n            of 0.0.0.0 indicates the absence of this\n            attribute.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfBgpPathAttrCalcLocalPref": {
                "type": "integer",
                "description": "The degree of preference calculated by the\n            receiving BGP4 speaker for an advertised\n            route.  A value of -1 indicates the\n            absence of this attribute.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfBgpPathAttrBest": {
                "type": "string",
                "description": "An indication of whether or not this route\n            was chosen as the best BGP4 route."
              },
              "mplsVpnVrfBgpPathAttrUnknown": {
                "type": "string",
                "description": "One or more path attributes not understood\n            by this BGP4 speaker.  Size zero (0)\n            indicates the absence of such\n            attribute(s).  Octets beyond the maximum\n            size, if any, are not recorded by this\n            object.",
                "format": "binary"
              }
            }
          },
          "mplsVpnVrfRouteTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS/BGP VPN VRF Table\n        routing information. Entries in this table define VRF routing\n        entries associated with the specified MPLS/VPN interfaces. Note\n        that this table contains both BGP and IGP routes, as both may\n        appear in the same VRF.",
            "properties": {
              "mplsVpnVrfName": {
                "type": "string",
                "description": "mplsVpnVrfName",
                "x-yang-type": "leafref"
              },
              "mplsVpnVrfRouteDest": {
                "type": "string",
                "description": "The destination IP address of this route.\n            This object may not take a Multicast (Class D)\n            address value.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteMask object is not equal to x.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfRouteDestAddrType": {
                "type": "string",
                "description": "The address type of the mplsVpnVrfRouteDest\n            entry.",
                "x-yang-type": "inet-address:InetAddressType"
              },
              "mplsVpnVrfRouteMask": {
                "type": "string",
                "description": "Indicate the mask to be logical-ANDed with the\n            destination  address  before  being compared to\n            the value  in  the  mplsVpnVrfRouteDest field.\n            For those  systems  that  do  not support\n            arbitrary subnet masks, an agent constructs the\n            value of the mplsVpnVrfRouteMask by reference\n            \n            \n            to the IP Address Class.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteDest object is not equal to\n            mplsVpnVrfRouteDest.",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfRouteMaskAddrType": {
                "type": "string",
                "description": "The address type of mplsVpnVrfRouteMask.",
                "x-yang-type": "inet-address:InetAddressType"
              },
              "mplsVpnVrfRouteTos": {
                "type": "integer",
                "description": "The IP TOS Field is used to specify the policy to\n            be applied to this route.  The encoding of IP TOS\n            is as specified  by  the  following convention.\n            Zero indicates the default path if no more\n            specific policy applies.\n            \n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            |                 |                       |     |\n            |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n            |                 |                       |     |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            \n                       IP TOS                IP TOS\n                  Field     Policy      Field     Policy\n                  Contents    Code      Contents    Code\n                  0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                  0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                  0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                  0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                  1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                  1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                  1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                  1 1 1 0  ==>  28      1 1 1 1  ==>  30.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfRouteNextHop": {
                "type": "string",
                "description": "On remote routes, the address of the next\n            system en route; Otherwise, 0.0.0.0. .",
                "x-yang-type": "inet-address:InetAddress"
              },
              "mplsVpnVrfRouteNextHopAddrType": {
                "type": "string",
                "description": "The address type of the mplsVpnVrfRouteNextHopAddrType\n            object.",
                "x-yang-type": "inet-address:InetAddressType"
              },
              "mplsVpnVrfRouteIfIndex": {
                "type": "string",
                "description": "The ifIndex value that identifies the local\n            interface  through  which  the next hop of this\n            route should be reached.",
                "x-yang-type": "if-mib:InterfaceIndexOrZero"
              },
              "mplsVpnVrfRouteType": {
                "type": "string",
                "description": "The type of route.  Note that local(3)  refers\n            to a route for which the next hop is the final\n            destination; remote(4) refers to a route for\n            that the next  hop is not the final destination.\n            Routes which do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject (2) refers to a route which, if matched,\n            discards the message as unreachable. This is used\n            in some protocols as a means of correctly aggregating\n            routes."
              },
              "mplsVpnVrfRouteProto": {
                "type": "string",
                "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway rout-\n            ing protocols is not  intended  to  imply  that\n            hosts should support those protocols."
              },
              "mplsVpnVrfRouteAge": {
                "type": "integer",
                "description": "The number of seconds since this route was\n            last updated or otherwise determined to be\n            correct. Note that no semantics of `too old'\n            can be implied except through knowledge of the\n            routing protocol by which the route was\n            learned.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfRouteInfo": {
                "type": "string",
                "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsi-\n            \n            \n            ble for this route, as determined by the  value\n            specified  in the route's mplsVpnVrfRouteProto\n            value. If this information is not present, its\n            value SHOULD be set to the OBJECT IDENTIFIER\n            { 0 0 }, which is a syntactically valid object\n            identif-ier, and any implementation conforming\n            to ASN.1 and the Basic Encoding Rules must be\n            able to generate and recognize this value.",
                "x-yang-type": "yang:object-identifier-128"
              },
              "mplsVpnVrfRouteNextHopAS": {
                "type": "integer",
                "description": "The Autonomous System Number of the Next Hop.\n            The semantics of this object are determined by\n            the routing-protocol specified in the route's\n            mplsVpnVrfRouteProto value. When this object is\n            unknown or not relevant its value should be set\n            to zero.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsVpnVrfRouteMetric1": {
                "type": "integer",
                "description": "The primary routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfRouteMetric2": {
                "type": "integer",
                "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfRouteMetric3": {
                "type": "integer",
                "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfRouteMetric4": {
                "type": "integer",
                "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfRouteMetric5": {
                "type": "integer",
                "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "mplsVpnVrfRouteRowStatus": {
                "type": "string",
                "description": "Row status for this table. It is used according\n            to row installation and removal conventions.",
                "x-yang-type": "snmpv2-tc:RowStatus"
              },
              "mplsVpnVrfRouteStorageType": {
                "type": "string",
                "description": "Storage type value.",
                "x-yang-type": "snmpv2-tc:StorageType"
              }
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnInterfaceConfEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS/BGP VPN.\n          \n          \n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "mplsVpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsVpnInterfaceConfIndex": {
              "type": "string",
              "description": "This is a unique index for an entry in the\n            MplsVPNInterfaceConfTable. A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            which are enabled for MPLS/BGP VPN functionality.",
              "x-yang-type": "if-mib:InterfaceIndex"
            },
            "mplsVpnInterfaceLabelEdgeType": {
              "type": "string",
              "description": "Either the providerEdge(0) (PE) or customerEdge(1)\n            (CE) bit MUST be set."
            },
            "mplsVpnInterfaceVpnClassification": {
              "type": "string",
              "description": "Denotes whether this link participates in a\n            carrier-of-carrier's, enterprise, or inter-provider\n            scenario."
            },
            "mplsVpnInterfaceVpnRouteDistProtocol": {
              "type": "string",
              "description": "Denotes the route distribution protocol across the\n            PE-CE link. Note that more than one routing protocol\n            may be enabled at the same time."
            },
            "mplsVpnInterfaceConfStorageType": {
              "type": "string",
              "description": "The storage type for this entry.",
              "x-yang-type": "snmpv2-tc:StorageType"
            },
            "mplsVpnInterfaceConfRowStatus": {
              "type": "string",
              "description": "The row status for this entry. This value is\n            used to create a row in this table, signifying\n            that the specified interface is to be associated\n            with the specified interface. If this operation\n            succeeds, the interface will have been associated,\n            otherwise the agent would not allow the association. \n            If the agent only allows read-only operations on\n            this table, it will create entries in this table\n            as they are created.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnVrfEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS/BGP VPN. The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "The human-readable name of this VPN. This MAY\n            be equivalent to the RFC2685 VPN-ID.",
              "x-yang-type": "MPLS-VPN-MIB:MplsVpnId"
            },
            "mplsVpnVrfDescription": {
              "type": "string",
              "description": "The human-readable description of this VRF.",
              "x-yang-type": "snmp-framework:SnmpAdminString"
            },
            "mplsVpnVrfRouteDistinguisher": {
              "type": "string",
              "description": "The route distinguisher for this VRF.",
              "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
            },
            "mplsVpnVrfCreationTime": {
              "type": "string",
              "description": "The time at which this VRF entry was created.",
              "x-yang-type": "yang:timestamp"
            },
            "mplsVpnVrfOperStatus": {
              "type": "string",
              "description": "Denotes whether a VRF is operational or not. A VRF is \n            up(1) when at least one interface associated with the\n            VRF, which ifOperStatus is up(1). A VRF is down(2) when:\n            \n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            \n            b. There are no interfaces associated with the VRF."
            },
            "mplsVpnVrfActiveInterfaces": {
              "type": "integer",
              "description": "Total number of interfaces connected to this VRF with \n            \n            \n            ifOperStatus = up(1). \n            \n            This counter should be incremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from down(2) to up(1).\n            \n            b. When an interface with ifOperStatus = up(1) is connected\n               to this VRF.\n            \n            This counter should be decremented when:\n            \n            a. When the ifOperStatus of one of the connected interfaces \n               changes from up(1) to down(2).\n            \n            b. When one of the connected interfaces with \n               ifOperStatus = up(1) gets disconnected from this VRF.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfAssociatedInterfaces": {
              "type": "integer",
              "description": "Total number of interfaces connected to this VRF \n            (independent of ifOperStatus type).",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfConfMidRouteThreshold": {
              "type": "integer",
              "description": "Denotes mid-level water marker for the number\n            of routes which  this VRF may hold.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfConfHighRouteThreshold": {
              "type": "integer",
              "description": "Denotes high-level water marker for the number of\n            routes which  this VRF may hold.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfConfMaxRoutes": {
              "type": "integer",
              "description": "Denotes maximum number of routes which this VRF is\n            configured to hold. This value MUST be less than or\n            equal to mplsVrfMaxPossibleRoutes unless it is set\n            to 0.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfConfLastChanged": {
              "type": "string",
              "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
              "x-yang-type": "yang:timestamp"
            },
            "mplsVpnVrfConfRowStatus": {
              "type": "string",
              "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "mplsVpnVrfConfStorageType": {
              "type": "string",
              "description": "The storage type for this entry.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnVrfRouteTargetEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS/BGP VPN instance. The indexing provides an\n          ordering per-VRF instance.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "mplsVpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsVpnVrfRouteTargetIndex": {
              "type": "integer",
              "description": "Auxiliary index for route-targets configured for a \n            particular VRF.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfRouteTargetType": {
              "type": "string",
              "description": "The route target export distribution type."
            },
            "mplsVpnVrfRouteTarget": {
              "type": "string",
              "description": "The route target distribution policy.",
              "x-yang-type": "MPLS-VPN-MIB:MplsVpnRouteDistinguisher"
            },
            "mplsVpnVrfRouteTargetDescr": {
              "type": "string",
              "description": "Description of the route target.",
              "x-yang-type": "snmpv2-tc:DisplayString"
            },
            "mplsVpnVrfRouteTargetRowStatus": {
              "type": "string",
              "description": "Row status for this entry.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnVrfBgpNbrAddrEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS/BGP VPN. The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "mplsVpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsVpnInterfaceConfIndex": {
              "type": "string",
              "description": "mplsVpnInterfaceConfIndex",
              "x-yang-type": "leafref"
            },
            "mplsVpnVrfBgpNbrIndex": {
              "type": "integer",
              "description": "This is a unique tertiary index for an entry in the\n            MplsVpnVrfBgpNbrAddrEntry Table.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfBgpNbrRole": {
              "type": "string",
              "description": "Denotes the role played by this EBGP neighbor\n            with respect to this VRF."
            },
            "mplsVpnVrfBgpNbrType": {
              "type": "string",
              "description": "Denotes the address family of the PE address.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsVpnVrfBgpNbrAddr": {
              "type": "string",
              "description": "Denotes the EBGP neighbor address.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfBgpNbrRowStatus": {
              "type": "string",
              "description": "This variable is used to create, modify, and/or\n            delete a row in this table.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "mplsVpnVrfBgpNbrStorageType": {
              "type": "string",
              "description": "The storage type for this entry.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnVrfBgpNbrPrefixEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every BGP prefix associated with a VRF supporting a \n          MPLS/BGP VPN. The indexing provides an ordering of \n          BGP prefixes per VRF.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "mplsVpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsVpnVrfBgpPathAttrPeer": {
              "type": "string",
              "description": "The IP address of the peer where the path\n            information was learned.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfBgpPathAttrIpAddrPrefixLen": {
              "type": "integer",
              "description": "Length in bits of the IP address prefix\n            in the Network Layer Reachability\n            Information field.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfBgpPathAttrIpAddrPrefix": {
              "type": "string",
              "description": "An IP address prefix in the Network Layer\n            Reachability Information field.  This object\n            is an IP address containing the prefix with\n            length specified by mplsVpnVrfBgpPathAttrIpAddrPrefixLen.\n            Any bits beyond the length specified by\n            mplsVpnVrfBgpPathAttrIpAddrPrefixLen are zeroed.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfBgpPathAttrOrigin": {
              "type": "string",
              "description": "The ultimate origin of the path\n            information."
            },
            "mplsVpnVrfBgpPathAttrASPathSegment": {
              "type": "string",
              "description": "The sequence of AS path segments.  Each AS\n            path segment is represented by a triple\n            <type, length, value>.\n            \n             The type is a 1-octet field which has two\n             possible values:\n                 1      AS_SET: unordered set of ASs a\n                        route in the UPDATE\n                        message has traversed\n                 2      AS_SEQUENCE: ordered set of ASs\n                        a route in the UPDATE\n                        message has traversed.\n                        The length is a 1-octet field containing the\n            \n            \n                        number of ASs in the value field.\n            \n                        The value field contains one or more AS\n                        numbers, each AS is represented in the octet\n                        string as a pair of octets according to the\n                        following algorithm:\n            \n                        first-byte-of-pair = ASNumber / 256;\n                        second-byte-of-pair = ASNumber & 255;",
              "format": "binary"
            },
            "mplsVpnVrfBgpPathAttrNextHop": {
              "type": "string",
              "description": "The address of the border router that\n            should be used for the destination\n            network.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfBgpPathAttrMultiExitDisc": {
              "type": "integer",
              "description": "This metric is used to discriminate\n            between multiple exit points to an\n            adjacent autonomous system.  A value of -1\n            indicates the absence of this attribute.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfBgpPathAttrLocalPref": {
              "type": "integer",
              "description": "The originating BGP4 speaker's degree of\n            preference for an advertised route.  A\n            value of -1 indicates the absence of this\n            attribute.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfBgpPathAttrAtomicAggregate": {
              "type": "string",
              "description": "Whether or not the local system has\n            selected a less specific route without\n            selecting a more specific route."
            },
            "mplsVpnVrfBgpPathAttrAggregatorAS": {
              "type": "integer",
              "description": "The AS number of the last BGP4 speaker that\n            performed route aggregation.  A value of\n            zero (0) indicates the absence of this\n            attribute.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfBgpPathAttrAggregatorAddr": {
              "type": "string",
              "description": "The IP address of the last BGP4 speaker\n            that performed route aggregation.  A value\n            of 0.0.0.0 indicates the absence of this\n            attribute.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfBgpPathAttrCalcLocalPref": {
              "type": "integer",
              "description": "The degree of preference calculated by the\n            receiving BGP4 speaker for an advertised\n            route.  A value of -1 indicates the\n            absence of this attribute.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfBgpPathAttrBest": {
              "type": "string",
              "description": "An indication of whether or not this route\n            was chosen as the best BGP4 route."
            },
            "mplsVpnVrfBgpPathAttrUnknown": {
              "type": "string",
              "description": "One or more path attributes not understood\n            by this BGP4 speaker.  Size zero (0)\n            indicates the absence of such\n            attribute(s).  Octets beyond the maximum\n            size, if any, are not recorded by this\n            object.",
              "format": "binary"
            }
          }
        }
      },
      "MPLS-VPN-MIB_mplsVpnVrfRouteEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for every route\n          present configured (either dynamically or statically) within\n          the context of a specific VRF capable of supporting MPLS/BGP\n          VPN. The indexing provides an ordering of VRFs per-VPN\n          interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "mplsVpnVrfName": {
              "type": "string",
              "description": "mplsVpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsVpnVrfRouteDest": {
              "type": "string",
              "description": "The destination IP address of this route.\n            This object may not take a Multicast (Class D)\n            address value.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteMask object is not equal to x.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfRouteDestAddrType": {
              "type": "string",
              "description": "The address type of the mplsVpnVrfRouteDest\n            entry.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsVpnVrfRouteMask": {
              "type": "string",
              "description": "Indicate the mask to be logical-ANDed with the\n            destination  address  before  being compared to\n            the value  in  the  mplsVpnVrfRouteDest field.\n            For those  systems  that  do  not support\n            arbitrary subnet masks, an agent constructs the\n            value of the mplsVpnVrfRouteMask by reference\n            \n            \n            to the IP Address Class.\n            \n            Any assignment (implicit or otherwise) of an\n            instance of this object to a value x must be\n            rejected if the bit-wise logical-AND of x with\n            the value of the corresponding instance of the\n            mplsVpnVrfRouteDest object is not equal to\n            mplsVpnVrfRouteDest.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfRouteMaskAddrType": {
              "type": "string",
              "description": "The address type of mplsVpnVrfRouteMask.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsVpnVrfRouteTos": {
              "type": "integer",
              "description": "The IP TOS Field is used to specify the policy to\n            be applied to this route.  The encoding of IP TOS\n            is as specified  by  the  following convention.\n            Zero indicates the default path if no more\n            specific policy applies.\n            \n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            |                 |                       |     |\n            |   PRECEDENCE    |    TYPE OF SERVICE    |  0  |\n            |                 |                       |     |\n            +-----+-----+-----+-----+-----+-----+-----+-----+\n            \n                       IP TOS                IP TOS\n                  Field     Policy      Field     Policy\n                  Contents    Code      Contents    Code\n                  0 0 0 0  ==>   0      0 0 0 1  ==>   2\n                  0 0 1 0  ==>   4      0 0 1 1  ==>   6\n                  0 1 0 0  ==>   8      0 1 0 1  ==>  10\n                  0 1 1 0  ==>  12      0 1 1 1  ==>  14\n                  1 0 0 0  ==>  16      1 0 0 1  ==>  18\n                  1 0 1 0  ==>  20      1 0 1 1  ==>  22\n                  1 1 0 0  ==>  24      1 1 0 1  ==>  26\n                  1 1 1 0  ==>  28      1 1 1 1  ==>  30.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfRouteNextHop": {
              "type": "string",
              "description": "On remote routes, the address of the next\n            system en route; Otherwise, 0.0.0.0. .",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsVpnVrfRouteNextHopAddrType": {
              "type": "string",
              "description": "The address type of the mplsVpnVrfRouteNextHopAddrType\n            object.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsVpnVrfRouteIfIndex": {
              "type": "string",
              "description": "The ifIndex value that identifies the local\n            interface  through  which  the next hop of this\n            route should be reached.",
              "x-yang-type": "if-mib:InterfaceIndexOrZero"
            },
            "mplsVpnVrfRouteType": {
              "type": "string",
              "description": "The type of route.  Note that local(3)  refers\n            to a route for which the next hop is the final\n            destination; remote(4) refers to a route for\n            that the next  hop is not the final destination.\n            Routes which do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject (2) refers to a route which, if matched,\n            discards the message as unreachable. This is used\n            in some protocols as a means of correctly aggregating\n            routes."
            },
            "mplsVpnVrfRouteProto": {
              "type": "string",
              "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway rout-\n            ing protocols is not  intended  to  imply  that\n            hosts should support those protocols."
            },
            "mplsVpnVrfRouteAge": {
              "type": "integer",
              "description": "The number of seconds since this route was\n            last updated or otherwise determined to be\n            correct. Note that no semantics of `too old'\n            can be implied except through knowledge of the\n            routing protocol by which the route was\n            learned.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfRouteInfo": {
              "type": "string",
              "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsi-\n            \n            \n            ble for this route, as determined by the  value\n            specified  in the route's mplsVpnVrfRouteProto\n            value. If this information is not present, its\n            value SHOULD be set to the OBJECT IDENTIFIER\n            { 0 0 }, which is a syntactically valid object\n            identif-ier, and any implementation conforming\n            to ASN.1 and the Basic Encoding Rules must be\n            able to generate and recognize this value.",
              "x-yang-type": "yang:object-identifier-128"
            },
            "mplsVpnVrfRouteNextHopAS": {
              "type": "integer",
              "description": "The Autonomous System Number of the Next Hop.\n            The semantics of this object are determined by\n            the routing-protocol specified in the route's\n            mplsVpnVrfRouteProto value. When this object is\n            unknown or not relevant its value should be set\n            to zero.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsVpnVrfRouteMetric1": {
              "type": "integer",
              "description": "The primary routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfRouteMetric2": {
              "type": "integer",
              "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfRouteMetric3": {
              "type": "integer",
              "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfRouteMetric4": {
              "type": "integer",
              "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfRouteMetric5": {
              "type": "integer",
              "description": "An alternate routing metric for this route.\n            The semantics of this metric are determined by\n            the routing-protocol specified in  the  route's\n            mplsVpnVrfRouteProto value. If this metric is not\n            used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsVpnVrfRouteRowStatus": {
              "type": "string",
              "description": "Row status for this table. It is used according\n            to row installation and removal conventions.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "mplsVpnVrfRouteStorageType": {
              "type": "string",
              "description": "Storage type value.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "MPLS-VPN-MIB",
      "description": "MIB operations for MPLS-VPN-MIB"
    }
  ]
}