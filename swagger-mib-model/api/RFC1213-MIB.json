{
  "openapi": "3.0.0",
  "info": {
    "title": "RFC1213-MIB MIB API",
    "version": "1.0.0",
    "description": "A textual description of the entity.  This value\n          should include the full name and version\n          identification of the system's hardware type,\n          software operating-system, and networking\n          software.  It is mandatory that this only contain\n          printable ASCII characters.\n\n\u26a0\ufe0f **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/RFC1213-MIB:system": {
      "get": {
        "summary": "Get system data",
        "description": "Retrieve system operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_system"
                },
                "example": {
                  "RFC1213-MIB:system": {
                    "sysDescr": "GigabitEthernet1/0/1",
                    "sysObjectID": "example-string",
                    "sysUpTime": "example-string",
                    "sysContact": "example-string",
                    "sysName": "interface-1",
                    "sysLocation": "example-string",
                    "sysServices": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:interfaces": {
      "get": {
        "summary": "Get interfaces data",
        "description": "Retrieve interfaces operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_interfaces"
                },
                "example": {
                  "RFC1213-MIB:interfaces": {
                    "ifNumber": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ip": {
      "get": {
        "summary": "Get ip data",
        "description": "Retrieve ip operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ip"
                },
                "example": {
                  "RFC1213-MIB:ip": {
                    "ipForwarding": "192.168.1.1",
                    "ipDefaultTTL": -2147483648,
                    "ipInReceives": 0,
                    "ipInHdrErrors": 0,
                    "ipInAddrErrors": 0,
                    "ipForwDatagrams": 0,
                    "ipInUnknownProtos": 0,
                    "ipInDiscards": 0,
                    "ipInDelivers": 0,
                    "ipOutRequests": 0,
                    "ipOutDiscards": 0,
                    "ipOutNoRoutes": 0,
                    "ipReasmTimeout": -2147483648,
                    "ipReasmReqds": 0,
                    "ipReasmOKs": 0,
                    "ipReasmFails": 0,
                    "ipFragOKs": 0,
                    "ipFragFails": 0,
                    "ipFragCreates": 0,
                    "ipRoutingDiscards": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:icmp": {
      "get": {
        "summary": "Get icmp data",
        "description": "Retrieve icmp operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_icmp"
                },
                "example": {
                  "RFC1213-MIB:icmp": {
                    "icmpInMsgs": 0,
                    "icmpInErrors": 0,
                    "icmpInDestUnreachs": 0,
                    "icmpInTimeExcds": 0,
                    "icmpInParmProbs": 0,
                    "icmpInSrcQuenchs": 0,
                    "icmpInRedirects": 0,
                    "icmpInEchos": 0,
                    "icmpInEchoReps": 0,
                    "icmpInTimestamps": 0,
                    "icmpInTimestampReps": 0,
                    "icmpInAddrMasks": 0,
                    "icmpInAddrMaskReps": 0,
                    "icmpOutMsgs": 0,
                    "icmpOutErrors": 0,
                    "icmpOutDestUnreachs": 0,
                    "icmpOutTimeExcds": 0,
                    "icmpOutParmProbs": 0,
                    "icmpOutSrcQuenchs": 0,
                    "icmpOutRedirects": 0,
                    "icmpOutEchos": 0,
                    "icmpOutEchoReps": 0,
                    "icmpOutTimestamps": 0,
                    "icmpOutTimestampReps": 0,
                    "icmpOutAddrMasks": 0,
                    "icmpOutAddrMaskReps": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcp": {
      "get": {
        "summary": "Get tcp data",
        "description": "Retrieve tcp operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_tcp"
                },
                "example": {
                  "RFC1213-MIB:tcp": {
                    "tcpRtoAlgorithm": "example-string",
                    "tcpRtoMin": -2147483648,
                    "tcpRtoMax": -2147483648,
                    "tcpMaxConn": -2147483648,
                    "tcpActiveOpens": 0,
                    "tcpPassiveOpens": 0,
                    "tcpAttemptFails": 0,
                    "tcpEstabResets": 0,
                    "tcpCurrEstab": 0,
                    "tcpInSegs": 0,
                    "tcpOutSegs": 0,
                    "tcpRetransSegs": 0,
                    "tcpInErrs": 0,
                    "tcpOutRsts": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udp": {
      "get": {
        "summary": "Get udp data",
        "description": "Retrieve udp operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_udp"
                },
                "example": {
                  "RFC1213-MIB:udp": {
                    "udpInDatagrams": 0,
                    "udpNoPorts": 0,
                    "udpInErrors": 0,
                    "udpOutDatagrams": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egp": {
      "get": {
        "summary": "Get egp data",
        "description": "Retrieve egp operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_egp"
                },
                "example": {
                  "RFC1213-MIB:egp": {
                    "egpInMsgs": 0,
                    "egpInErrors": 0,
                    "egpOutMsgs": 0,
                    "egpOutErrors": 0,
                    "egpAs": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:snmp": {
      "get": {
        "summary": "Get snmp data",
        "description": "Retrieve snmp operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_snmp"
                },
                "example": {
                  "RFC1213-MIB:snmp": {
                    "snmpInPkts": 0,
                    "snmpOutPkts": 0,
                    "snmpInBadVersions": 0,
                    "snmpInBadCommunityNames": 0,
                    "snmpInBadCommunityUses": 0,
                    "snmpInASNParseErrs": 0,
                    "snmpInTooBigs": 0,
                    "snmpInNoSuchNames": 0,
                    "snmpInBadValues": 0,
                    "snmpInReadOnlys": 0,
                    "snmpInGenErrs": 0,
                    "snmpInTotalReqVars": 0,
                    "snmpInTotalSetVars": 0,
                    "snmpInGetRequests": 0,
                    "snmpInGetNexts": 0,
                    "snmpInSetRequests": 0,
                    "snmpInGetResponses": 0,
                    "snmpInTraps": 0,
                    "snmpOutTooBigs": 0,
                    "snmpOutNoSuchNames": 0,
                    "snmpOutBadValues": 0,
                    "snmpOutGenErrs": 0,
                    "snmpOutGetRequests": 0,
                    "snmpOutGetNexts": 0,
                    "snmpOutSetRequests": 0,
                    "snmpOutGetResponses": 0,
                    "snmpOutTraps": 0,
                    "snmpEnableAuthenTraps": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ifTable": {
      "get": {
        "summary": "Get ifTable data",
        "description": "Retrieve ifTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ifTable"
                },
                "example": {
                  "RFC1213-MIB:ifTable": {
                    "ifIndex": 1,
                    "ifDescr": "GigabitEthernet1/0/1",
                    "ifType": "ethernetCsmacd(6)",
                    "ifMtu": 1500,
                    "ifSpeed": 1000000000,
                    "ifPhysAddress": "00:11:22:33:44:55",
                    "ifAdminStatus": "up(1)",
                    "ifOperStatus": "up(1)",
                    "ifLastChange": "example-string",
                    "ifInOctets": 1234567890,
                    "ifInUcastPkts": 0,
                    "ifInNUcastPkts": 0,
                    "ifInDiscards": 0,
                    "ifInErrors": 0,
                    "ifInUnknownProtos": 0,
                    "ifOutOctets": 1234567890,
                    "ifOutUcastPkts": 0,
                    "ifOutNUcastPkts": 0,
                    "ifOutDiscards": 0,
                    "ifOutErrors": 0,
                    "ifOutQLen": 0,
                    "ifSpecific": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ifTable/ifEntry": {
      "get": {
        "summary": "Get ifEntry list",
        "description": "Retrieve list of ifEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ifEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ifEntry": [
                    {
                      "ifIndex": 1,
                      "ifDescr": "GigabitEthernet1/0/1",
                      "ifType": "ethernetCsmacd(6)",
                      "ifMtu": 1500,
                      "ifSpeed": 1000000000,
                      "ifPhysAddress": "00:11:22:33:44:55",
                      "ifAdminStatus": "up(1)",
                      "ifOperStatus": "up(1)",
                      "ifLastChange": "example-string",
                      "ifInOctets": 1234567890,
                      "ifInUcastPkts": 0,
                      "ifInNUcastPkts": 0,
                      "ifInDiscards": 0,
                      "ifInErrors": 0,
                      "ifInUnknownProtos": 0,
                      "ifOutOctets": 1234567890,
                      "ifOutUcastPkts": 0,
                      "ifOutNUcastPkts": 0,
                      "ifOutDiscards": 0,
                      "ifOutErrors": 0,
                      "ifOutQLen": 0,
                      "ifSpecific": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ifTable/ifEntry={ifIndex}": {
      "get": {
        "summary": "Get ifEntry entry",
        "description": "Retrieve specific ifEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ifEntry"
                },
                "example": {
                  "RFC1213-MIB:ifEntry": {
                    "ifIndex": 1,
                    "ifDescr": "GigabitEthernet1/0/1",
                    "ifType": "ethernetCsmacd(6)",
                    "ifMtu": 1500,
                    "ifSpeed": 1000000000,
                    "ifPhysAddress": "00:11:22:33:44:55",
                    "ifAdminStatus": "up(1)",
                    "ifOperStatus": "up(1)",
                    "ifLastChange": "example-string",
                    "ifInOctets": 1234567890,
                    "ifInUcastPkts": 0,
                    "ifInNUcastPkts": 0,
                    "ifInDiscards": 0,
                    "ifInErrors": 0,
                    "ifInUnknownProtos": 0,
                    "ifOutOctets": 1234567890,
                    "ifOutUcastPkts": 0,
                    "ifOutNUcastPkts": 0,
                    "ifOutDiscards": 0,
                    "ifOutErrors": 0,
                    "ifOutQLen": 0,
                    "ifSpecific": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:atTable": {
      "get": {
        "summary": "Get atTable data",
        "description": "Retrieve atTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_atTable"
                },
                "example": {
                  "RFC1213-MIB:atTable": {
                    "atIfIndex": 1,
                    "atIfIndex_2": 1,
                    "atPhysAddress": "00:11:22:33:44:55",
                    "atNetAddress": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:atTable/atEntry": {
      "get": {
        "summary": "Get atEntry list",
        "description": "Retrieve list of atEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_atEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:atEntry": [
                    {
                      "atIfIndex": 1,
                      "atIfIndex_2": 1,
                      "atPhysAddress": "00:11:22:33:44:55",
                      "atNetAddress": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:atTable/atEntry={atIfIndex atIfIndex_2 atNetAddress}": {
      "get": {
        "summary": "Get atEntry entry",
        "description": "Retrieve specific atEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "atIfIndex atIfIndex_2 atNetAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_atEntry"
                },
                "example": {
                  "RFC1213-MIB:atEntry": {
                    "atIfIndex": 1,
                    "atIfIndex_2": 1,
                    "atPhysAddress": "00:11:22:33:44:55",
                    "atNetAddress": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipAddrTable": {
      "get": {
        "summary": "Get ipAddrTable data",
        "description": "Retrieve ipAddrTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipAddrTable"
                },
                "example": {
                  "RFC1213-MIB:ipAddrTable": {
                    "ipAdEntAddr": "192.168.1.1",
                    "ipAdEntIfIndex": 1,
                    "ipAdEntNetMask": "192.168.1.1",
                    "ipAdEntBcastAddr": -2147483648,
                    "ipAdEntReasmMaxSize": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipAddrTable/ipAddrEntry": {
      "get": {
        "summary": "Get ipAddrEntry list",
        "description": "Retrieve list of ipAddrEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipAddrEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipAddrEntry": [
                    {
                      "ipAdEntAddr": "192.168.1.1",
                      "ipAdEntIfIndex": 1,
                      "ipAdEntNetMask": "192.168.1.1",
                      "ipAdEntBcastAddr": -2147483648,
                      "ipAdEntReasmMaxSize": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipAddrTable/ipAddrEntry={ipAdEntAddr}": {
      "get": {
        "summary": "Get ipAddrEntry entry",
        "description": "Retrieve specific ipAddrEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipAdEntAddr",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipAddrEntry"
                },
                "example": {
                  "RFC1213-MIB:ipAddrEntry": {
                    "ipAdEntAddr": "192.168.1.1",
                    "ipAdEntIfIndex": 1,
                    "ipAdEntNetMask": "192.168.1.1",
                    "ipAdEntBcastAddr": -2147483648,
                    "ipAdEntReasmMaxSize": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipRouteTable": {
      "get": {
        "summary": "Get ipRouteTable data",
        "description": "Retrieve ipRouteTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipRouteTable"
                },
                "example": {
                  "RFC1213-MIB:ipRouteTable": {
                    "ipRouteDest": "192.168.1.1",
                    "ipRouteIfIndex": 1,
                    "ipRouteMetric1": -2147483648,
                    "ipRouteMetric2": -2147483648,
                    "ipRouteMetric3": -2147483648,
                    "ipRouteMetric4": -2147483648,
                    "ipRouteNextHop": "192.168.1.1",
                    "ipRouteType": "192.168.1.1",
                    "ipRouteProto": "192.168.1.1",
                    "ipRouteAge": -2147483648,
                    "ipRouteMask": "192.168.1.1",
                    "ipRouteMetric5": -2147483648,
                    "ipRouteInfo": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipRouteTable/ipRouteEntry": {
      "get": {
        "summary": "Get ipRouteEntry list",
        "description": "Retrieve list of ipRouteEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipRouteEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipRouteEntry": [
                    {
                      "ipRouteDest": "192.168.1.1",
                      "ipRouteIfIndex": 1,
                      "ipRouteMetric1": -2147483648,
                      "ipRouteMetric2": -2147483648,
                      "ipRouteMetric3": -2147483648,
                      "ipRouteMetric4": -2147483648,
                      "ipRouteNextHop": "192.168.1.1",
                      "ipRouteType": "192.168.1.1",
                      "ipRouteProto": "192.168.1.1",
                      "ipRouteAge": -2147483648,
                      "ipRouteMask": "192.168.1.1",
                      "ipRouteMetric5": -2147483648,
                      "ipRouteInfo": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipRouteTable/ipRouteEntry={ipRouteDest}": {
      "get": {
        "summary": "Get ipRouteEntry entry",
        "description": "Retrieve specific ipRouteEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipRouteDest",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipRouteEntry"
                },
                "example": {
                  "RFC1213-MIB:ipRouteEntry": {
                    "ipRouteDest": "192.168.1.1",
                    "ipRouteIfIndex": 1,
                    "ipRouteMetric1": -2147483648,
                    "ipRouteMetric2": -2147483648,
                    "ipRouteMetric3": -2147483648,
                    "ipRouteMetric4": -2147483648,
                    "ipRouteNextHop": "192.168.1.1",
                    "ipRouteType": "192.168.1.1",
                    "ipRouteProto": "192.168.1.1",
                    "ipRouteAge": -2147483648,
                    "ipRouteMask": "192.168.1.1",
                    "ipRouteMetric5": -2147483648,
                    "ipRouteInfo": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipNetToMediaTable": {
      "get": {
        "summary": "Get ipNetToMediaTable data",
        "description": "Retrieve ipNetToMediaTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipNetToMediaTable"
                },
                "example": {
                  "RFC1213-MIB:ipNetToMediaTable": {
                    "ipNetToMediaIfIndex": 1,
                    "ipNetToMediaPhysAddress": "00:11:22:33:44:55",
                    "ipNetToMediaNetAddress": "192.168.1.1",
                    "ipNetToMediaType": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipNetToMediaTable/ipNetToMediaEntry": {
      "get": {
        "summary": "Get ipNetToMediaEntry list",
        "description": "Retrieve list of ipNetToMediaEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipNetToMediaEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipNetToMediaEntry": [
                    {
                      "ipNetToMediaIfIndex": 1,
                      "ipNetToMediaPhysAddress": "00:11:22:33:44:55",
                      "ipNetToMediaNetAddress": "192.168.1.1",
                      "ipNetToMediaType": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipNetToMediaTable/ipNetToMediaEntry={ipNetToMediaIfIndex ipNetToMediaNetAddress}": {
      "get": {
        "summary": "Get ipNetToMediaEntry entry",
        "description": "Retrieve specific ipNetToMediaEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipNetToMediaIfIndex ipNetToMediaNetAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipNetToMediaEntry"
                },
                "example": {
                  "RFC1213-MIB:ipNetToMediaEntry": {
                    "ipNetToMediaIfIndex": 1,
                    "ipNetToMediaPhysAddress": "00:11:22:33:44:55",
                    "ipNetToMediaNetAddress": "192.168.1.1",
                    "ipNetToMediaType": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcpConnTable": {
      "get": {
        "summary": "Get tcpConnTable data",
        "description": "Retrieve tcpConnTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_tcpConnTable"
                },
                "example": {
                  "RFC1213-MIB:tcpConnTable": {
                    "tcpConnState": "up(1)",
                    "tcpConnLocalAddress": "192.168.1.1",
                    "tcpConnLocalPort": -2147483648,
                    "tcpConnRemAddress": "192.168.1.1",
                    "tcpConnRemPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcpConnTable/tcpConnEntry": {
      "get": {
        "summary": "Get tcpConnEntry list",
        "description": "Retrieve list of tcpConnEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_tcpConnEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:tcpConnEntry": [
                    {
                      "tcpConnState": "up(1)",
                      "tcpConnLocalAddress": "192.168.1.1",
                      "tcpConnLocalPort": -2147483648,
                      "tcpConnRemAddress": "192.168.1.1",
                      "tcpConnRemPort": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcpConnTable/tcpConnEntry={tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort}": {
      "get": {
        "summary": "Get tcpConnEntry entry",
        "description": "Retrieve specific tcpConnEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_tcpConnEntry"
                },
                "example": {
                  "RFC1213-MIB:tcpConnEntry": {
                    "tcpConnState": "up(1)",
                    "tcpConnLocalAddress": "192.168.1.1",
                    "tcpConnLocalPort": -2147483648,
                    "tcpConnRemAddress": "192.168.1.1",
                    "tcpConnRemPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udpTable": {
      "get": {
        "summary": "Get udpTable data",
        "description": "Retrieve udpTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_udpTable"
                },
                "example": {
                  "RFC1213-MIB:udpTable": {
                    "udpLocalAddress": "192.168.1.1",
                    "udpLocalPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udpTable/udpEntry": {
      "get": {
        "summary": "Get udpEntry list",
        "description": "Retrieve list of udpEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_udpEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:udpEntry": [
                    {
                      "udpLocalAddress": "192.168.1.1",
                      "udpLocalPort": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udpTable/udpEntry={udpLocalAddress udpLocalPort}": {
      "get": {
        "summary": "Get udpEntry entry",
        "description": "Retrieve specific udpEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "udpLocalAddress udpLocalPort",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_udpEntry"
                },
                "example": {
                  "RFC1213-MIB:udpEntry": {
                    "udpLocalAddress": "192.168.1.1",
                    "udpLocalPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egpNeighTable": {
      "get": {
        "summary": "Get egpNeighTable data",
        "description": "Retrieve egpNeighTable operational data from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_egpNeighTable"
                },
                "example": {
                  "RFC1213-MIB:egpNeighTable": {
                    "egpNeighState": "up(1)",
                    "egpNeighAddr": "192.168.1.1",
                    "egpNeighAs": -2147483648,
                    "egpNeighInMsgs": 0,
                    "egpNeighInErrs": 0,
                    "egpNeighOutMsgs": 0,
                    "egpNeighOutErrs": 0,
                    "egpNeighInErrMsgs": 0,
                    "egpNeighOutErrMsgs": 0,
                    "egpNeighStateUps": 0,
                    "egpNeighStateDowns": 0,
                    "egpNeighIntervalHello": -2147483648,
                    "egpNeighIntervalPoll": -2147483648,
                    "egpNeighMode": "example-string",
                    "egpNeighEventTrigger": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egpNeighTable/egpNeighEntry": {
      "get": {
        "summary": "Get egpNeighEntry list",
        "description": "Retrieve list of egpNeighEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_egpNeighEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:egpNeighEntry": [
                    {
                      "egpNeighState": "up(1)",
                      "egpNeighAddr": "192.168.1.1",
                      "egpNeighAs": -2147483648,
                      "egpNeighInMsgs": 0,
                      "egpNeighInErrs": 0,
                      "egpNeighOutMsgs": 0,
                      "egpNeighOutErrs": 0,
                      "egpNeighInErrMsgs": 0,
                      "egpNeighOutErrMsgs": 0,
                      "egpNeighStateUps": 0,
                      "egpNeighStateDowns": 0,
                      "egpNeighIntervalHello": -2147483648,
                      "egpNeighIntervalPoll": -2147483648,
                      "egpNeighMode": "example-string",
                      "egpNeighEventTrigger": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egpNeighTable/egpNeighEntry={egpNeighAddr}": {
      "get": {
        "summary": "Get egpNeighEntry entry",
        "description": "Retrieve specific egpNeighEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "egpNeighAddr",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_egpNeighEntry"
                },
                "example": {
                  "RFC1213-MIB:egpNeighEntry": {
                    "egpNeighState": "up(1)",
                    "egpNeighAddr": "192.168.1.1",
                    "egpNeighAs": -2147483648,
                    "egpNeighInMsgs": 0,
                    "egpNeighInErrs": 0,
                    "egpNeighOutMsgs": 0,
                    "egpNeighOutErrs": 0,
                    "egpNeighInErrMsgs": 0,
                    "egpNeighOutErrMsgs": 0,
                    "egpNeighStateUps": 0,
                    "egpNeighStateDowns": 0,
                    "egpNeighIntervalHello": -2147483648,
                    "egpNeighIntervalPoll": -2147483648,
                    "egpNeighMode": "example-string",
                    "egpNeighEventTrigger": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ifEntry": {
      "get": {
        "summary": "Get ifEntry list",
        "description": "Retrieve list of ifEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ifEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ifEntry": [
                    {
                      "ifIndex": 1,
                      "ifDescr": "GigabitEthernet1/0/1",
                      "ifType": "ethernetCsmacd(6)",
                      "ifMtu": 1500,
                      "ifSpeed": 1000000000,
                      "ifPhysAddress": "00:11:22:33:44:55",
                      "ifAdminStatus": "up(1)",
                      "ifOperStatus": "up(1)",
                      "ifLastChange": "example-string",
                      "ifInOctets": 1234567890,
                      "ifInUcastPkts": 0,
                      "ifInNUcastPkts": 0,
                      "ifInDiscards": 0,
                      "ifInErrors": 0,
                      "ifInUnknownProtos": 0,
                      "ifOutOctets": 1234567890,
                      "ifOutUcastPkts": 0,
                      "ifOutNUcastPkts": 0,
                      "ifOutDiscards": 0,
                      "ifOutErrors": 0,
                      "ifOutQLen": 0,
                      "ifSpecific": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ifEntry={ifIndex}": {
      "get": {
        "summary": "Get ifEntry entry",
        "description": "Retrieve specific ifEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ifIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ifEntry"
                },
                "example": {
                  "RFC1213-MIB:ifEntry": {
                    "ifIndex": 1,
                    "ifDescr": "GigabitEthernet1/0/1",
                    "ifType": "ethernetCsmacd(6)",
                    "ifMtu": 1500,
                    "ifSpeed": 1000000000,
                    "ifPhysAddress": "00:11:22:33:44:55",
                    "ifAdminStatus": "up(1)",
                    "ifOperStatus": "up(1)",
                    "ifLastChange": "example-string",
                    "ifInOctets": 1234567890,
                    "ifInUcastPkts": 0,
                    "ifInNUcastPkts": 0,
                    "ifInDiscards": 0,
                    "ifInErrors": 0,
                    "ifInUnknownProtos": 0,
                    "ifOutOctets": 1234567890,
                    "ifOutUcastPkts": 0,
                    "ifOutNUcastPkts": 0,
                    "ifOutDiscards": 0,
                    "ifOutErrors": 0,
                    "ifOutQLen": 0,
                    "ifSpecific": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:atEntry": {
      "get": {
        "summary": "Get atEntry list",
        "description": "Retrieve list of atEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_atEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:atEntry": [
                    {
                      "atIfIndex": 1,
                      "atIfIndex_2": 1,
                      "atPhysAddress": "00:11:22:33:44:55",
                      "atNetAddress": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:atEntry={atIfIndex atIfIndex_2 atNetAddress}": {
      "get": {
        "summary": "Get atEntry entry",
        "description": "Retrieve specific atEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "atIfIndex atIfIndex_2 atNetAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_atEntry"
                },
                "example": {
                  "RFC1213-MIB:atEntry": {
                    "atIfIndex": 1,
                    "atIfIndex_2": 1,
                    "atPhysAddress": "00:11:22:33:44:55",
                    "atNetAddress": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipAddrEntry": {
      "get": {
        "summary": "Get ipAddrEntry list",
        "description": "Retrieve list of ipAddrEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipAddrEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipAddrEntry": [
                    {
                      "ipAdEntAddr": "192.168.1.1",
                      "ipAdEntIfIndex": 1,
                      "ipAdEntNetMask": "192.168.1.1",
                      "ipAdEntBcastAddr": -2147483648,
                      "ipAdEntReasmMaxSize": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipAddrEntry={ipAdEntAddr}": {
      "get": {
        "summary": "Get ipAddrEntry entry",
        "description": "Retrieve specific ipAddrEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipAdEntAddr",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipAddrEntry"
                },
                "example": {
                  "RFC1213-MIB:ipAddrEntry": {
                    "ipAdEntAddr": "192.168.1.1",
                    "ipAdEntIfIndex": 1,
                    "ipAdEntNetMask": "192.168.1.1",
                    "ipAdEntBcastAddr": -2147483648,
                    "ipAdEntReasmMaxSize": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipRouteEntry": {
      "get": {
        "summary": "Get ipRouteEntry list",
        "description": "Retrieve list of ipRouteEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipRouteEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipRouteEntry": [
                    {
                      "ipRouteDest": "192.168.1.1",
                      "ipRouteIfIndex": 1,
                      "ipRouteMetric1": -2147483648,
                      "ipRouteMetric2": -2147483648,
                      "ipRouteMetric3": -2147483648,
                      "ipRouteMetric4": -2147483648,
                      "ipRouteNextHop": "192.168.1.1",
                      "ipRouteType": "192.168.1.1",
                      "ipRouteProto": "192.168.1.1",
                      "ipRouteAge": -2147483648,
                      "ipRouteMask": "192.168.1.1",
                      "ipRouteMetric5": -2147483648,
                      "ipRouteInfo": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipRouteEntry={ipRouteDest}": {
      "get": {
        "summary": "Get ipRouteEntry entry",
        "description": "Retrieve specific ipRouteEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipRouteDest",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipRouteEntry"
                },
                "example": {
                  "RFC1213-MIB:ipRouteEntry": {
                    "ipRouteDest": "192.168.1.1",
                    "ipRouteIfIndex": 1,
                    "ipRouteMetric1": -2147483648,
                    "ipRouteMetric2": -2147483648,
                    "ipRouteMetric3": -2147483648,
                    "ipRouteMetric4": -2147483648,
                    "ipRouteNextHop": "192.168.1.1",
                    "ipRouteType": "192.168.1.1",
                    "ipRouteProto": "192.168.1.1",
                    "ipRouteAge": -2147483648,
                    "ipRouteMask": "192.168.1.1",
                    "ipRouteMetric5": -2147483648,
                    "ipRouteInfo": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipNetToMediaEntry": {
      "get": {
        "summary": "Get ipNetToMediaEntry list",
        "description": "Retrieve list of ipNetToMediaEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_ipNetToMediaEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:ipNetToMediaEntry": [
                    {
                      "ipNetToMediaIfIndex": 1,
                      "ipNetToMediaPhysAddress": "00:11:22:33:44:55",
                      "ipNetToMediaNetAddress": "192.168.1.1",
                      "ipNetToMediaType": "192.168.1.1"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:ipNetToMediaEntry={ipNetToMediaIfIndex ipNetToMediaNetAddress}": {
      "get": {
        "summary": "Get ipNetToMediaEntry entry",
        "description": "Retrieve specific ipNetToMediaEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "ipNetToMediaIfIndex ipNetToMediaNetAddress",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_ipNetToMediaEntry"
                },
                "example": {
                  "RFC1213-MIB:ipNetToMediaEntry": {
                    "ipNetToMediaIfIndex": 1,
                    "ipNetToMediaPhysAddress": "00:11:22:33:44:55",
                    "ipNetToMediaNetAddress": "192.168.1.1",
                    "ipNetToMediaType": "192.168.1.1"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcpConnEntry": {
      "get": {
        "summary": "Get tcpConnEntry list",
        "description": "Retrieve list of tcpConnEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_tcpConnEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:tcpConnEntry": [
                    {
                      "tcpConnState": "up(1)",
                      "tcpConnLocalAddress": "192.168.1.1",
                      "tcpConnLocalPort": -2147483648,
                      "tcpConnRemAddress": "192.168.1.1",
                      "tcpConnRemPort": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:tcpConnEntry={tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort}": {
      "get": {
        "summary": "Get tcpConnEntry entry",
        "description": "Retrieve specific tcpConnEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "tcpConnLocalAddress tcpConnLocalPort tcpConnRemAddress tcpConnRemPort",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_tcpConnEntry"
                },
                "example": {
                  "RFC1213-MIB:tcpConnEntry": {
                    "tcpConnState": "up(1)",
                    "tcpConnLocalAddress": "192.168.1.1",
                    "tcpConnLocalPort": -2147483648,
                    "tcpConnRemAddress": "192.168.1.1",
                    "tcpConnRemPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udpEntry": {
      "get": {
        "summary": "Get udpEntry list",
        "description": "Retrieve list of udpEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_udpEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:udpEntry": [
                    {
                      "udpLocalAddress": "192.168.1.1",
                      "udpLocalPort": -2147483648
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:udpEntry={udpLocalAddress udpLocalPort}": {
      "get": {
        "summary": "Get udpEntry entry",
        "description": "Retrieve specific udpEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "udpLocalAddress udpLocalPort",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_udpEntry"
                },
                "example": {
                  "RFC1213-MIB:udpEntry": {
                    "udpLocalAddress": "192.168.1.1",
                    "udpLocalPort": -2147483648
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egpNeighEntry": {
      "get": {
        "summary": "Get egpNeighEntry list",
        "description": "Retrieve list of egpNeighEntry entries from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RFC1213-MIB_egpNeighEntry"
                  }
                },
                "example": {
                  "RFC1213-MIB:egpNeighEntry": [
                    {
                      "egpNeighState": "up(1)",
                      "egpNeighAddr": "192.168.1.1",
                      "egpNeighAs": -2147483648,
                      "egpNeighInMsgs": 0,
                      "egpNeighInErrs": 0,
                      "egpNeighOutMsgs": 0,
                      "egpNeighOutErrs": 0,
                      "egpNeighInErrMsgs": 0,
                      "egpNeighOutErrMsgs": 0,
                      "egpNeighStateUps": 0,
                      "egpNeighStateDowns": 0,
                      "egpNeighIntervalHello": -2147483648,
                      "egpNeighIntervalPoll": -2147483648,
                      "egpNeighMode": "example-string",
                      "egpNeighEventTrigger": "example-string"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/RFC1213-MIB:egpNeighEntry={egpNeighAddr}": {
      "get": {
        "summary": "Get egpNeighEntry entry",
        "description": "Retrieve specific egpNeighEntry entry by key from MIB",
        "tags": [
          "RFC1213-MIB"
        ],
        "parameters": [
          {
            "name": "egpNeighAddr",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "$ref": "#/components/schemas/RFC1213-MIB_egpNeighEntry"
                },
                "example": {
                  "RFC1213-MIB:egpNeighEntry": {
                    "egpNeighState": "up(1)",
                    "egpNeighAddr": "192.168.1.1",
                    "egpNeighAs": -2147483648,
                    "egpNeighInMsgs": 0,
                    "egpNeighInErrs": 0,
                    "egpNeighOutMsgs": 0,
                    "egpNeighOutErrs": 0,
                    "egpNeighInErrMsgs": 0,
                    "egpNeighOutErrMsgs": 0,
                    "egpNeighStateUps": 0,
                    "egpNeighStateDowns": 0,
                    "egpNeighIntervalHello": -2147483648,
                    "egpNeighIntervalPoll": -2147483648,
                    "egpNeighMode": "example-string",
                    "egpNeighEventTrigger": "example-string"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "RFC1213-MIB_RFC1213-MIB": {
        "type": "object",
        "description": "RFC1213-MIB",
        "properties": {
          "sysDescr": {
            "type": "string",
            "description": "A textual description of the entity.  This value\n          should include the full name and version\n          identification of the system's hardware type,\n          software operating-system, and networking\n          software.  It is mandatory that this only contain\n          printable ASCII characters.",
            "x-yang-type": "RFC1213-MIB:DisplayString"
          },
          "sysObjectID": {
            "type": "string",
            "description": "The vendor's authoritative identification of the\n          network management subsystem contained in the\n          entity.  This value is allocated within the SMI\n          enterprises subtree (1.3.6.1.4.1) and provides an\n          easy and unambiguous means for determining `what\n          kind of box' is being managed.  For example, if\n          vendor `Flintstones, Inc.' was assigned the\n          subtree 1.3.6.1.4.1.4242, it could assign the\n          identifier 1.3.6.1.4.1.4242.1.1 to its `Fred\n          Router'.",
            "x-yang-type": "yang:object-identifier-128"
          },
          "sysUpTime": {
            "type": "string",
            "description": "The time (in hundredths of a second) since the\n          network management portion of the system was last\n          re-initialized.",
            "x-yang-type": "yang:timeticks"
          },
          "sysContact": {
            "type": "string",
            "description": "The textual identification of the contact person\n          for this managed node, together with information\n          on how to contact this person.",
            "x-yang-type": "RFC1213-MIB:DisplayString"
          },
          "sysName": {
            "type": "string",
            "description": "An administratively-assigned name for this\n          managed node.  By convention, this is the node's\n          fully-qualified domain name.",
            "x-yang-type": "RFC1213-MIB:DisplayString"
          },
          "sysLocation": {
            "type": "string",
            "description": "The physical location of this node (e.g.,\n          `telephone closet, 3rd floor').",
            "x-yang-type": "RFC1213-MIB:DisplayString"
          },
          "sysServices": {
            "type": "integer",
            "description": "A value which indicates the set of services that\n          this entity primarily offers.\n          \n          The value is a sum.  This sum initially takes the\n          value zero, Then, for each layer, L, in the range\n          1 through 7, that this node performs transactions\n          for, 2 raised to (L - 1) is added to the sum.  For\n          example, a node which performs primarily routing\n          functions would have a value of 4 (2^(3-1)).  In\n          contrast, a node which is a host offering\n          application services would have a value of 72\n          (2^(4-1) + 2^(7-1)).  Note that in the context of\n          the Internet suite of protocols, values should be\n          calculated accordingly:\n          \n               layer  functionality\n                   1  physical (e.g., repeaters)\n                   2  datalink/subnetwork (e.g., bridges)\n                   3  internet (e.g., IP gateways)\n                   4  end-to-end  (e.g., IP hosts)\n                   7  applications (e.g., mail relays)\n          \n          For systems including OSI protocols, layers 5 and\n          6 may also be counted.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ifNumber": {
            "type": "integer",
            "description": "The number of network interfaces (regardless of\n          their current state) present on this system.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipForwarding": {
            "type": "string",
            "description": "The indication of whether this entity is acting\n          as an IP gateway in respect to the forwarding of\n          datagrams received by, but not addressed to, this\n          entity.  IP gateways forward datagrams.  IP hosts\n          do not (except those source-routed via the host).\n          \n          Note that for some managed nodes, this object may\n          take on only a subset of the values possible.\n          Accordingly, it is appropriate for an agent to\n          return a `badValue' response if a management\n          station attempts to change this object to an\n          inappropriate value."
          },
          "ipDefaultTTL": {
            "type": "integer",
            "description": "The default value inserted into the Time-To-Live\n          field of the IP header of datagrams originated at\n          this entity, whenever a TTL value is not supplied\n          by the transport layer protocol.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipInReceives": {
            "type": "integer",
            "description": "The total number of input datagrams received from\n          interfaces, including those received in error.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipInHdrErrors": {
            "type": "integer",
            "description": "The number of input datagrams discarded due to\n          errors in their IP headers, including bad\n          checksums, version number mismatch, other format\n          errors, time-to-live exceeded, errors discovered\n          in processing their IP options, etc.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipInAddrErrors": {
            "type": "integer",
            "description": "The number of input datagrams discarded because\n          the IP address in their IP header's destination\n          field was not a valid address to be received at\n          this entity.  This count includes invalid\n          addresses (e.g., 0.0.0.0) and addresses of\n          unsupported Classes (e.g., Class E).  For entities\n          which are not IP Gateways and therefore do not\n          forward datagrams, this counter includes datagrams\n          discarded because the destination address was not\n          a local address.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipForwDatagrams": {
            "type": "integer",
            "description": "The number of input datagrams for which this\n          entity was not their final IP destination, as a\n          result of which an attempt was made to find a\n          route to forward them to that final destination.\n          In entities which do not act as IP Gateways, this\n          counter will include only those packets which were\n          Source-Routed via this entity, and the Source-\n          Route option processing was successful.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipInUnknownProtos": {
            "type": "integer",
            "description": "The number of locally-addressed datagrams\n          received successfully but discarded because of an\n          unknown or unsupported protocol.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipInDiscards": {
            "type": "integer",
            "description": "The number of input IP datagrams for which no\n          problems were encountered to prevent their\n          continued processing, but which were discarded\n          (e.g., for lack of buffer space).  Note that this\n          counter does not include any datagrams discarded\n          while awaiting re-assembly.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipInDelivers": {
            "type": "integer",
            "description": "The total number of input datagrams successfully\n          delivered to IP user-protocols (including ICMP).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipOutRequests": {
            "type": "integer",
            "description": "The total number of IP datagrams which local IP\n          user-protocols (including ICMP) supplied to IP in\n          requests for transmission.  Note that this counter\n          does not include any datagrams counted in\n          ipForwDatagrams.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipOutDiscards": {
            "type": "integer",
            "description": "The number of output IP datagrams for which no\n          problem was encountered to prevent their\n          transmission to their destination, but which were\n          discarded (e.g., for lack of buffer space).  Note\n          that this counter would include datagrams counted\n          in ipForwDatagrams if any such packets met this\n          (discretionary) discard criterion.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipOutNoRoutes": {
            "type": "integer",
            "description": "The number of IP datagrams discarded because no\n          route could be found to transmit them to their\n          destination.  Note that this counter includes any\n          packets counted in ipForwDatagrams which meet this\n          `no-route' criterion.  Note that this includes any\n          datagrams which a host cannot route because all of\n          its default gateways are down.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipReasmTimeout": {
            "type": "integer",
            "description": "The maximum number of seconds which received\n          fragments are held while they are awaiting\n          reassembly at this entity.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipReasmReqds": {
            "type": "integer",
            "description": "The number of IP fragments received which needed\n          to be reassembled at this entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipReasmOKs": {
            "type": "integer",
            "description": "The number of IP datagrams successfully re-\n          assembled.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipReasmFails": {
            "type": "integer",
            "description": "The number of failures detected by the IP re-\n          assembly algorithm (for whatever reason: timed\n          out, errors, etc).  Note that this is not\n          necessarily a count of discarded IP fragments\n          since some algorithms (notably the algorithm in\n          RFC 815) can lose track of the number of fragments\n          by combining them as they are received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipFragOKs": {
            "type": "integer",
            "description": "The number of IP datagrams that have been\n          successfully fragmented at this entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipFragFails": {
            "type": "integer",
            "description": "The number of IP datagrams that have been\n          discarded because they needed to be fragmented at\n          this entity but could not be, e.g., because their\n          Don't Fragment flag was set.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipFragCreates": {
            "type": "integer",
            "description": "The number of IP datagram fragments that have\n          been generated as a result of fragmentation at\n          this entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ipRoutingDiscards": {
            "type": "integer",
            "description": "The number of routing entries which were chosen\n          to be discarded even though they are valid.  One\n          possible reason for discarding such an entry could\n          be to free-up buffer space for other routing\n          entries.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInMsgs": {
            "type": "integer",
            "description": "The total number of ICMP messages which the\n          entity received.  Note that this counter includes\n          all those counted by icmpInErrors.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInErrors": {
            "type": "integer",
            "description": "The number of ICMP messages which the entity\n          received but determined as having ICMP-specific\n          errors (bad ICMP checksums, bad length, etc.).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInDestUnreachs": {
            "type": "integer",
            "description": "The number of ICMP Destination Unreachable\n          messages received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInTimeExcds": {
            "type": "integer",
            "description": "The number of ICMP Time Exceeded messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInParmProbs": {
            "type": "integer",
            "description": "The number of ICMP Parameter Problem messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInSrcQuenchs": {
            "type": "integer",
            "description": "The number of ICMP Source Quench messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInRedirects": {
            "type": "integer",
            "description": "The number of ICMP Redirect messages received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInEchos": {
            "type": "integer",
            "description": "The number of ICMP Echo (request) messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInEchoReps": {
            "type": "integer",
            "description": "The number of ICMP Echo Reply messages received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInTimestamps": {
            "type": "integer",
            "description": "The number of ICMP Timestamp (request) messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInTimestampReps": {
            "type": "integer",
            "description": "The number of ICMP Timestamp Reply messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInAddrMasks": {
            "type": "integer",
            "description": "The number of ICMP Address Mask Request messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpInAddrMaskReps": {
            "type": "integer",
            "description": "The number of ICMP Address Mask Reply messages\n          received.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutMsgs": {
            "type": "integer",
            "description": "The total number of ICMP messages which this\n          entity attempted to send.  Note that this counter\n          includes all those counted by icmpOutErrors.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutErrors": {
            "type": "integer",
            "description": "The number of ICMP messages which this entity did\n          not send due to problems discovered within ICMP\n          such as a lack of buffers.  This value should not\n          include errors discovered outside the ICMP layer\n          such as the inability of IP to route the resultant\n          datagram.  In some implementations there may be no\n          types of error which contribute to this counter's\n          value.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutDestUnreachs": {
            "type": "integer",
            "description": "The number of ICMP Destination Unreachable\n          messages sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutTimeExcds": {
            "type": "integer",
            "description": "The number of ICMP Time Exceeded messages sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutParmProbs": {
            "type": "integer",
            "description": "The number of ICMP Parameter Problem messages\n          sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutSrcQuenchs": {
            "type": "integer",
            "description": "The number of ICMP Source Quench messages sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutRedirects": {
            "type": "integer",
            "description": "The number of ICMP Redirect messages sent.  For a\n          host, this object will always be zero, since hosts\n          do not send redirects.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutEchos": {
            "type": "integer",
            "description": "The number of ICMP Echo (request) messages sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutEchoReps": {
            "type": "integer",
            "description": "The number of ICMP Echo Reply messages sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutTimestamps": {
            "type": "integer",
            "description": "The number of ICMP Timestamp (request) messages\n          sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutTimestampReps": {
            "type": "integer",
            "description": "The number of ICMP Timestamp Reply messages\n          sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutAddrMasks": {
            "type": "integer",
            "description": "The number of ICMP Address Mask Request messages\n          sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "icmpOutAddrMaskReps": {
            "type": "integer",
            "description": "The number of ICMP Address Mask Reply messages\n          sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpRtoAlgorithm": {
            "type": "string",
            "description": "The algorithm used to determine the timeout value\n          used for retransmitting unacknowledged octets."
          },
          "tcpRtoMin": {
            "type": "integer",
            "description": "The minimum value permitted by a TCP\n          implementation for the retransmission timeout,\n          measured in milliseconds.  More refined semantics\n          for objects of this type depend upon the algorithm\n          used to determine the retransmission timeout.  In\n          particular, when the timeout algorithm is rsre(3),\n          an object of this type has the semantics of the\n          LBOUND quantity described in RFC 793.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "tcpRtoMax": {
            "type": "integer",
            "description": "The maximum value permitted by a TCP\n          implementation for the retransmission timeout,\n          measured in milliseconds.  More refined semantics\n          for objects of this type depend upon the algorithm\n          used to determine the retransmission timeout.  In\n          particular, when the timeout algorithm is rsre(3),\n          an object of this type has the semantics of the\n          UBOUND quantity described in RFC 793.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "tcpMaxConn": {
            "type": "integer",
            "description": "The limit on the total number of TCP connections\n          the entity can support.  In entities where the\n          maximum number of connections is dynamic, this\n          object should contain the value -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "tcpActiveOpens": {
            "type": "integer",
            "description": "The number of times TCP connections have made a\n          direct transition to the SYN-SENT state from the\n          CLOSED state.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpPassiveOpens": {
            "type": "integer",
            "description": "The number of times TCP connections have made a\n          direct transition to the SYN-RCVD state from the\n          LISTEN state.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpAttemptFails": {
            "type": "integer",
            "description": "The number of times TCP connections have made a\n          direct transition to the CLOSED state from either\n          the SYN-SENT state or the SYN-RCVD state, plus the\n          number of times TCP connections have made a direct\n          transition to the LISTEN state from the SYN-RCVD\n          state.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpEstabResets": {
            "type": "integer",
            "description": "The number of times TCP connections have made a\n          direct transition to the CLOSED state from either\n          the ESTABLISHED state or the CLOSE-WAIT state.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpCurrEstab": {
            "type": "integer",
            "description": "The number of TCP connections for which the\n          current state is either ESTABLISHED or CLOSE-\n          WAIT.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpInSegs": {
            "type": "integer",
            "description": "The total number of segments received, including\n          those received in error.  This count includes\n          segments received on currently established\n          connections.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpOutSegs": {
            "type": "integer",
            "description": "The total number of segments sent, including\n          those on current connections but excluding those\n          containing only retransmitted octets.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpRetransSegs": {
            "type": "integer",
            "description": "The total number of segments retransmitted - that\n          is, the number of TCP segments transmitted\n          containing one or more previously transmitted\n          octets.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpInErrs": {
            "type": "integer",
            "description": "The total number of segments received in error\n          (e.g., bad TCP checksums).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "tcpOutRsts": {
            "type": "integer",
            "description": "The number of TCP segments sent containing the\n          RST flag.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "udpInDatagrams": {
            "type": "integer",
            "description": "The total number of UDP datagrams delivered to\n          UDP users.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "udpNoPorts": {
            "type": "integer",
            "description": "The total number of received UDP datagrams for\n          which there was no application at the destination\n          port.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "udpInErrors": {
            "type": "integer",
            "description": "The number of received UDP datagrams that could\n          not be delivered for reasons other than the lack\n          of an application at the destination port.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "udpOutDatagrams": {
            "type": "integer",
            "description": "The total number of UDP datagrams sent from this\n          entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpInMsgs": {
            "type": "integer",
            "description": "The number of EGP messages received without\n          error.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpInErrors": {
            "type": "integer",
            "description": "The number of EGP messages received that proved\n          to be in error.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpOutMsgs": {
            "type": "integer",
            "description": "The total number of locally generated EGP\n          messages.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpOutErrors": {
            "type": "integer",
            "description": "The number of locally generated EGP messages not\n          sent due to resource limitations within an EGP\n          entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpAs": {
            "type": "integer",
            "description": "The autonomous system number of this EGP entity.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "snmpInPkts": {
            "type": "integer",
            "description": "The total number of Messages delivered to the\n          SNMP entity from the transport service.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutPkts": {
            "type": "integer",
            "description": "The total number of SNMP Messages which were\n          passed from the SNMP protocol entity to the\n          transport service.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInBadVersions": {
            "type": "integer",
            "description": "The total number of SNMP Messages which were\n          delivered to the SNMP protocol entity and were for\n          an unsupported SNMP version.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInBadCommunityNames": {
            "type": "integer",
            "description": "The total number of SNMP Messages delivered to\n          the SNMP protocol entity which used a SNMP\n          community name not known to said entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInBadCommunityUses": {
            "type": "integer",
            "description": "The total number of SNMP Messages delivered to\n          the SNMP protocol entity which represented an SNMP\n          operation which was not allowed by the SNMP\n          community named in the Message.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInASNParseErrs": {
            "type": "integer",
            "description": "The total number of ASN.1 or BER errors\n          encountered by the SNMP protocol entity when\n          decoding received SNMP Messages.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInTooBigs": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `tooBig'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInNoSuchNames": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `noSuchName'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInBadValues": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `badValue'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInReadOnlys": {
            "type": "integer",
            "description": "The total number valid SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `readOnly'.  It should be noted that it is a\n          protocol error to generate an SNMP PDU which\n          contains the value `readOnly' in the error-status\n          field, as such this object is provided as a means\n          of detecting incorrect implementations of the\n          SNMP.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInGenErrs": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `genErr'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInTotalReqVars": {
            "type": "integer",
            "description": "The total number of MIB objects which have been\n          retrieved successfully by the SNMP protocol entity\n          as the result of receiving valid SNMP Get-Request\n          and Get-Next PDUs.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInTotalSetVars": {
            "type": "integer",
            "description": "The total number of MIB objects which have been\n          altered successfully by the SNMP protocol entity\n          as the result of receiving valid SNMP Set-Request\n          PDUs.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInGetRequests": {
            "type": "integer",
            "description": "The total number of SNMP Get-Request PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInGetNexts": {
            "type": "integer",
            "description": "The total number of SNMP Get-Next PDUs which have\n          been accepted and processed by the SNMP protocol\n          entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInSetRequests": {
            "type": "integer",
            "description": "The total number of SNMP Set-Request PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInGetResponses": {
            "type": "integer",
            "description": "The total number of SNMP Get-Response PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpInTraps": {
            "type": "integer",
            "description": "The total number of SNMP Trap PDUs which have\n          been accepted and processed by the SNMP protocol\n          entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutTooBigs": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `tooBig.'",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutNoSuchNames": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status is\n          `noSuchName'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutBadValues": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `badValue'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutGenErrs": {
            "type": "integer",
            "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `genErr'.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutGetRequests": {
            "type": "integer",
            "description": "The total number of SNMP Get-Request PDUs which\n          have been generated by the SNMP protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutGetNexts": {
            "type": "integer",
            "description": "The total number of SNMP Get-Next PDUs which have\n          been generated by the SNMP protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutSetRequests": {
            "type": "integer",
            "description": "The total number of SNMP Set-Request PDUs which\n          have been generated by the SNMP protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutGetResponses": {
            "type": "integer",
            "description": "The total number of SNMP Get-Response PDUs which\n          have been generated by the SNMP protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpOutTraps": {
            "type": "integer",
            "description": "The total number of SNMP Trap PDUs which have\n          been generated by the SNMP protocol entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "snmpEnableAuthenTraps": {
            "type": "string",
            "description": "Indicates whether the SNMP agent process is\n          permitted to generate authentication-failure\n          traps.  The value of this object overrides any\n          configuration information; as such, it provides a\n          means whereby all authentication-failure traps may\n          be disabled.\n          \n          Note that it is strongly recommended that this\n          object be stored in non-volatile memory so that it\n          remains constant between re-initializations of the\n          network management system."
          },
          "ifIndex": {
            "type": "integer",
            "description": "A unique value for each interface.  Its value\n            ranges between 1 and the value of ifNumber.  The\n            value for each interface must remain constant at\n            least from one re-initialization of the entity's\n            network management system to the next re-\n            initialization.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ifDescr": {
            "type": "string",
            "description": "A textual string containing information about the\n            interface.  This string should include the name of\n            the manufacturer, the product name and the version\n            of the hardware interface.",
            "x-yang-type": "RFC1213-MIB:DisplayString"
          },
          "ifType": {
            "type": "string",
            "description": "The type of interface.  Additional values for ifType\n            are assigned by the Internet Assigned Numbers\n            Authority (IANA), through updating the syntax of the\n            IANAifType textual convention.",
            "x-yang-type": "ianaiftype-mib:IANAifType"
          },
          "ifMtu": {
            "type": "integer",
            "description": "The size of the largest datagram which can be\n            sent/received on the interface, specified in\n            octets.  For interfaces that are used for\n            transmitting network datagrams, this is the size\n            of the largest network datagram that can be sent\n            on the interface.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ifSpeed": {
            "type": "integer",
            "description": "An estimate of the interface's current bandwidth\n            in bits per second.  For interfaces which do not\n            vary in bandwidth or for those where no accurate\n            estimation can be made, this object should contain\n            the nominal bandwidth.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifPhysAddress": {
            "type": "string",
            "description": "The interface's address at the protocol layer\n            immediately `below' the network layer in the\n            protocol stack.  For interfaces which do not have\n            such an address (e.g., a serial line), this object\n            should contain an octet string of zero length.",
            "x-yang-type": "RFC1213-MIB:PhysAddress"
          },
          "ifAdminStatus": {
            "type": "string",
            "description": "The desired state of the interface.  The\n            testing(3) state indicates that no operational\n            packets can be passed."
          },
          "ifOperStatus": {
            "type": "string",
            "description": "The current operational state of the interface.\n            The testing(3) state indicates that no operational\n            packets can be passed."
          },
          "ifLastChange": {
            "type": "string",
            "description": "The value of sysUpTime at the time the interface\n            entered its current operational state.  If the\n            current state was entered prior to the last re-\n            initialization of the local network management\n            subsystem, then this object contains a zero\n            value.",
            "x-yang-type": "yang:timeticks"
          },
          "ifInOctets": {
            "type": "integer",
            "description": "The total number of octets received on the\n            interface, including framing characters.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifInUcastPkts": {
            "type": "integer",
            "description": "The number of subnetwork-unicast packets\n            delivered to a higher-layer protocol.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifInNUcastPkts": {
            "type": "integer",
            "description": "The number of non-unicast (i.e., subnetwork-\n            broadcast or subnetwork-multicast) packets\n            delivered to a higher-layer protocol.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifInDiscards": {
            "type": "integer",
            "description": "The number of inbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being deliverable to a\n            higher-layer protocol.  One possible reason for\n            discarding such a packet could be to free up\n            buffer space.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifInErrors": {
            "type": "integer",
            "description": "The number of inbound packets that contained\n            errors preventing them from being deliverable to a\n            higher-layer protocol.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifInUnknownProtos": {
            "type": "integer",
            "description": "The number of packets received via the interface\n            which were discarded because of an unknown or\n            unsupported protocol.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutOctets": {
            "type": "integer",
            "description": "The total number of octets transmitted out of the\n            interface, including framing characters.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutUcastPkts": {
            "type": "integer",
            "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a\n            subnetwork-unicast address, including those that\n            were discarded or not sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutNUcastPkts": {
            "type": "integer",
            "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a non-\n            unicast (i.e., a subnetwork-broadcast or\n            subnetwork-multicast) address, including those\n            that were discarded or not sent.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutDiscards": {
            "type": "integer",
            "description": "The number of outbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being transmitted.  One\n            possible reason for discarding such a packet could\n            be to free up buffer space.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutErrors": {
            "type": "integer",
            "description": "The number of outbound packets that could not be\n            transmitted because of errors.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifOutQLen": {
            "type": "integer",
            "description": "The length of the output packet queue (in\n            packets).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "ifSpecific": {
            "type": "string",
            "description": "A reference to MIB definitions specific to the\n            particular media being used to realize the\n            interface.  For example, if the interface is\n            realized by an ethernet, then the value of this\n            object refers to a document defining objects\n            specific to ethernet.  If this information is not\n            present, its value should be set to the OBJECT\n            IDENTIFIER { 0 0 }, which is a syntactically valid\n            object identifier, and any conformant\n            implementation of ASN.1 and BER must be able to\n            generate and recognize this value.",
            "x-yang-type": "yang:object-identifier-128"
          },
          "atIfIndex": {
            "type": "integer",
            "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "atIfIndex_2": {
            "type": "integer",
            "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "atPhysAddress": {
            "type": "string",
            "description": "The media-dependent `physical' address.\n            \n            Setting this object to a null string (one of zero\n            length) has the effect of invaliding the\n            corresponding entry in the atTable object.  That\n            is, it effectively disassociates the interface\n            identified with said entry from the mapping\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant atPhysAddress object.",
            "x-yang-type": "RFC1213-MIB:PhysAddress"
          },
          "atNetAddress": {
            "type": "string",
            "description": "The NetworkAddress (e.g., the IP address)\n            corresponding to the media-dependent `physical'\n            address.",
            "format": "inet:ipv4-address"
          },
          "ipAdEntAddr": {
            "type": "string",
            "description": "The IP address to which this entry's addressing\n            information pertains.",
            "format": "inet:ipv4-address"
          },
          "ipAdEntIfIndex": {
            "type": "integer",
            "description": "The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipAdEntNetMask": {
            "type": "string",
            "description": "The subnet mask associated with the IP address of\n            this entry.  The value of the mask is an IP\n            address with all the network bits set to 1 and all\n            the hosts bits set to 0.",
            "format": "inet:ipv4-address"
          },
          "ipAdEntBcastAddr": {
            "type": "integer",
            "description": "The value of the least-significant bit in the IP\n            broadcast address used for sending datagrams on\n            the (logical) interface associated with the IP\n            address of this entry.  For example, when the\n            Internet standard all-ones broadcast address is\n            used, the value will be 1.  This value applies to\n            both the subnet and network broadcasts addresses\n            used by the entity on this (logical) interface.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipAdEntReasmMaxSize": {
            "type": "integer",
            "description": "The size of the largest IP datagram which this\n            entity can re-assemble from incoming IP fragmented\n            datagrams received on this interface.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteDest": {
            "type": "string",
            "description": "The destination IP address of this route.  An\n            entry with a value of 0.0.0.0 is considered a\n            default route.  Multiple routes to a single\n            destination can appear in the table, but access to\n            such multiple entries is dependent on the table-\n            access mechanisms defined by the network\n            management protocol in use.",
            "format": "inet:ipv4-address"
          },
          "ipRouteIfIndex": {
            "type": "integer",
            "description": "The index value which uniquely identifies the\n            local interface through which the next hop of this\n            route should be reached.  The interface identified\n            by a particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteMetric1": {
            "type": "integer",
            "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteMetric2": {
            "type": "integer",
            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteMetric3": {
            "type": "integer",
            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteMetric4": {
            "type": "integer",
            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteNextHop": {
            "type": "string",
            "description": "The IP address of the next hop of this route.\n            (In the case of a route bound to an interface\n            which is realized via a broadcast media, the value\n            of this field is the agent's IP address on that\n            interface.)",
            "format": "inet:ipv4-address"
          },
          "ipRouteType": {
            "type": "string",
            "description": "The type of route.  Note that the values\n            direct(3) and indirect(4) refer to the notion of\n            direct and indirect routing in the IP\n            architecture.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipRouteTable object.  That is, it\n            effectively disassociates the destination\n            identified with said entry from the route\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant ipRouteType object."
          },
          "ipRouteProto": {
            "type": "string",
            "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway routing\n            protocols is not intended to imply that hosts\n            should support those protocols."
          },
          "ipRouteAge": {
            "type": "integer",
            "description": "The number of seconds since this route was last\n            updated or otherwise determined to be correct.\n            Note that no semantics of `too old' can be implied\n            except through knowledge of the routing protocol\n            by which the route was learned.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteMask": {
            "type": "string",
            "description": "Indicate the mask to be logical-ANDed with the\n            destination address before being compared to the\n            value in the ipRouteDest field.  For those systems\n            that do not support arbitrary subnet masks, an\n            agent constructs the value of the ipRouteMask by\n            determining whether the value of the correspondent\n            ipRouteDest field belong to a class-A, B, or C\n            network, and then using one of:\n            \n                 mask           network\n                 255.0.0.0      class-A\n                 255.255.0.0    class-B\n                 255.255.255.0  class-C\n            \n            If the value of the ipRouteDest is 0.0.0.0 (a\n            default route), then the mask value is also\n            0.0.0.0.  It should be noted that all IP routing\n            subsystems implicitly use this mechanism.",
            "format": "inet:ipv4-address"
          },
          "ipRouteMetric5": {
            "type": "integer",
            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipRouteInfo": {
            "type": "string",
            "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsible\n            for this route, as determined by the value\n            specified in the route's ipRouteProto value.  If\n            this information is not present, its value should\n            be set to the OBJECT IDENTIFIER { 0 0 }, which is\n            a syntactically valid object identifier, and any\n            conformant implementation of ASN.1 and BER must be\n            able to generate and recognize this value.",
            "x-yang-type": "yang:object-identifier-128"
          },
          "ipNetToMediaIfIndex": {
            "type": "integer",
            "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "ipNetToMediaPhysAddress": {
            "type": "string",
            "description": "The media-dependent `physical' address.",
            "x-yang-type": "RFC1213-MIB:PhysAddress"
          },
          "ipNetToMediaNetAddress": {
            "type": "string",
            "description": "The IpAddress corresponding to the media-\n            dependent `physical' address.",
            "format": "inet:ipv4-address"
          },
          "ipNetToMediaType": {
            "type": "string",
            "description": "The type of mapping.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipNetToMediaTable.  That is, it effectively\n            disassociates the interface identified with said\n            entry from the mapping identified with said entry.\n            It is an implementation-specific matter as to\n            whether the agent removes an invalidated entry\n            from the table.  Accordingly, management stations\n            must be prepared to receive tabular information\n            from agents that corresponds to entries not\n            currently in use.  Proper interpretation of such\n            entries requires examination of the relevant\n            ipNetToMediaType object."
          },
          "tcpConnState": {
            "type": "string",
            "description": "The state of this TCP connection.\n            \n            The only value which may be set by a management\n            station is deleteTCB(12).  Accordingly, it is\n            appropriate for an agent to return a `badValue'\n            response if a management station attempts to set\n            this object to any other value.\n            \n            If a management station sets this object to the\n            value deleteTCB(12), then this has the effect of\n            deleting the TCB (as defined in RFC 793) of the\n            corresponding connection on the managed node,\n            resulting in immediate termination of the\n            connection.\n            \n            As an implementation-specific option, a RST\n            segment may be sent from the managed node to the\n            other TCP endpoint (note however that RST segments\n            are not sent reliably)."
          },
          "tcpConnLocalAddress": {
            "type": "string",
            "description": "The local IP address for this TCP connection.  In\n            the case of a connection in the listen state which\n            is willing to accept connections for any IP\n            interface associated with the node, the value\n            0.0.0.0 is used.",
            "format": "inet:ipv4-address"
          },
          "tcpConnLocalPort": {
            "type": "integer",
            "description": "The local port number for this TCP connection.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "tcpConnRemAddress": {
            "type": "string",
            "description": "The remote IP address for this TCP connection.",
            "format": "inet:ipv4-address"
          },
          "tcpConnRemPort": {
            "type": "integer",
            "description": "The remote port number for this TCP connection.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "udpLocalAddress": {
            "type": "string",
            "description": "The local IP address for this UDP listener.  In\n            the case of a UDP listener which is willing to\n            accept datagrams for any IP interface associated\n            with the node, the value 0.0.0.0 is used.",
            "format": "inet:ipv4-address"
          },
          "udpLocalPort": {
            "type": "integer",
            "description": "The local port number for this UDP listener.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "egpNeighState": {
            "type": "string",
            "description": "The EGP state of the local system with respect to\n            this entry's EGP neighbor.  Each EGP state is\n            represented by a value that is one greater than\n            the numerical value associated with said state in\n            RFC 904."
          },
          "egpNeighAddr": {
            "type": "string",
            "description": "The IP address of this entry's EGP neighbor.",
            "format": "inet:ipv4-address"
          },
          "egpNeighAs": {
            "type": "integer",
            "description": "The autonomous system of this EGP peer.  Zero\n            should be specified if the autonomous system\n            number of the neighbor is not yet known.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "egpNeighInMsgs": {
            "type": "integer",
            "description": "The number of EGP messages received without error\n            from this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighInErrs": {
            "type": "integer",
            "description": "The number of EGP messages received from this EGP\n            peer that proved to be in error (e.g., bad EGP\n            checksum).",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighOutMsgs": {
            "type": "integer",
            "description": "The number of locally generated EGP messages to\n            this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighOutErrs": {
            "type": "integer",
            "description": "The number of locally generated EGP messages not\n            sent to this EGP peer due to resource limitations\n            within an EGP entity.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighInErrMsgs": {
            "type": "integer",
            "description": "The number of EGP-defined error messages received\n            from this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighOutErrMsgs": {
            "type": "integer",
            "description": "The number of EGP-defined error messages sent to\n            this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighStateUps": {
            "type": "integer",
            "description": "The number of EGP state transitions to the UP\n            state with this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighStateDowns": {
            "type": "integer",
            "description": "The number of EGP state transitions from the UP\n            state to any other state with this EGP peer.",
            "minimum": 0,
            "maximum": 4294967295
          },
          "egpNeighIntervalHello": {
            "type": "integer",
            "description": "The interval between EGP Hello command\n            retransmissions (in hundredths of a second).  This\n            represents the t1 timer as defined in RFC 904.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "egpNeighIntervalPoll": {
            "type": "integer",
            "description": "The interval between EGP poll command\n            retransmissions (in hundredths of a second).  This\n            represents the t3 timer as defined in RFC 904.",
            "minimum": -2147483648,
            "maximum": 2147483647
          },
          "egpNeighMode": {
            "type": "string",
            "description": "The polling mode of this EGP entity, either\n            passive or active."
          },
          "egpNeighEventTrigger": {
            "type": "string",
            "description": "A control variable used to trigger operator-\n            initiated Start and Stop events.  When read, this\n            variable always returns the most recent value that\n            egpNeighEventTrigger was set to.  If it has not\n            been set since the last initialization of the\n            network management subsystem on the node, it\n            returns a value of `stop'.\n            \n            When set, this variable causes a Start or Stop\n            event on the specified neighbor, as specified on\n            pages 8-10 of RFC 904.  Briefly, a Start event\n            causes an Idle peer to begin neighbor acquisition\n            and a non-Idle peer to reinitiate neighbor\n            acquisition.  A stop event causes a non-Idle peer\n            to return to the Idle state until a Start event\n            occurs, either via egpNeighEventTrigger or\n            otherwise."
          },
          "system": {
            "type": "object",
            "description": "A textual description of the entity.  This value\n          should include the full name and version\n          identification of the system's hardware type,\n          software operating-system, and networking\n          software.  It is mandatory that this only contain\n          printable ASCII characters.",
            "properties": {
              "sysDescr": {
                "type": "string",
                "description": "A textual description of the entity.  This value\n          should include the full name and version\n          identification of the system's hardware type,\n          software operating-system, and networking\n          software.  It is mandatory that this only contain\n          printable ASCII characters.",
                "x-yang-type": "RFC1213-MIB:DisplayString"
              },
              "sysObjectID": {
                "type": "string",
                "description": "The vendor's authoritative identification of the\n          network management subsystem contained in the\n          entity.  This value is allocated within the SMI\n          enterprises subtree (1.3.6.1.4.1) and provides an\n          easy and unambiguous means for determining `what\n          kind of box' is being managed.  For example, if\n          vendor `Flintstones, Inc.' was assigned the\n          subtree 1.3.6.1.4.1.4242, it could assign the\n          identifier 1.3.6.1.4.1.4242.1.1 to its `Fred\n          Router'.",
                "x-yang-type": "yang:object-identifier-128"
              },
              "sysUpTime": {
                "type": "string",
                "description": "The time (in hundredths of a second) since the\n          network management portion of the system was last\n          re-initialized.",
                "x-yang-type": "yang:timeticks"
              },
              "sysContact": {
                "type": "string",
                "description": "The textual identification of the contact person\n          for this managed node, together with information\n          on how to contact this person.",
                "x-yang-type": "RFC1213-MIB:DisplayString"
              },
              "sysName": {
                "type": "string",
                "description": "An administratively-assigned name for this\n          managed node.  By convention, this is the node's\n          fully-qualified domain name.",
                "x-yang-type": "RFC1213-MIB:DisplayString"
              },
              "sysLocation": {
                "type": "string",
                "description": "The physical location of this node (e.g.,\n          `telephone closet, 3rd floor').",
                "x-yang-type": "RFC1213-MIB:DisplayString"
              },
              "sysServices": {
                "type": "integer",
                "description": "A value which indicates the set of services that\n          this entity primarily offers.\n          \n          The value is a sum.  This sum initially takes the\n          value zero, Then, for each layer, L, in the range\n          1 through 7, that this node performs transactions\n          for, 2 raised to (L - 1) is added to the sum.  For\n          example, a node which performs primarily routing\n          functions would have a value of 4 (2^(3-1)).  In\n          contrast, a node which is a host offering\n          application services would have a value of 72\n          (2^(4-1) + 2^(7-1)).  Note that in the context of\n          the Internet suite of protocols, values should be\n          calculated accordingly:\n          \n               layer  functionality\n                   1  physical (e.g., repeaters)\n                   2  datalink/subnetwork (e.g., bridges)\n                   3  internet (e.g., IP gateways)\n                   4  end-to-end  (e.g., IP hosts)\n                   7  applications (e.g., mail relays)\n          \n          For systems including OSI protocols, layers 5 and\n          6 may also be counted.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "interfaces": {
            "type": "object",
            "description": "The number of network interfaces (regardless of\n          their current state) present on this system.",
            "properties": {
              "ifNumber": {
                "type": "integer",
                "description": "The number of network interfaces (regardless of\n          their current state) present on this system.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "ip": {
            "type": "object",
            "description": "ip",
            "properties": {
              "ipForwarding": {
                "type": "string",
                "description": "The indication of whether this entity is acting\n          as an IP gateway in respect to the forwarding of\n          datagrams received by, but not addressed to, this\n          entity.  IP gateways forward datagrams.  IP hosts\n          do not (except those source-routed via the host).\n          \n          Note that for some managed nodes, this object may\n          take on only a subset of the values possible.\n          Accordingly, it is appropriate for an agent to\n          return a `badValue' response if a management\n          station attempts to change this object to an\n          inappropriate value."
              },
              "ipDefaultTTL": {
                "type": "integer",
                "description": "The default value inserted into the Time-To-Live\n          field of the IP header of datagrams originated at\n          this entity, whenever a TTL value is not supplied\n          by the transport layer protocol.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipInReceives": {
                "type": "integer",
                "description": "The total number of input datagrams received from\n          interfaces, including those received in error.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipInHdrErrors": {
                "type": "integer",
                "description": "The number of input datagrams discarded due to\n          errors in their IP headers, including bad\n          checksums, version number mismatch, other format\n          errors, time-to-live exceeded, errors discovered\n          in processing their IP options, etc.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipInAddrErrors": {
                "type": "integer",
                "description": "The number of input datagrams discarded because\n          the IP address in their IP header's destination\n          field was not a valid address to be received at\n          this entity.  This count includes invalid\n          addresses (e.g., 0.0.0.0) and addresses of\n          unsupported Classes (e.g., Class E).  For entities\n          which are not IP Gateways and therefore do not\n          forward datagrams, this counter includes datagrams\n          discarded because the destination address was not\n          a local address.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipForwDatagrams": {
                "type": "integer",
                "description": "The number of input datagrams for which this\n          entity was not their final IP destination, as a\n          result of which an attempt was made to find a\n          route to forward them to that final destination.\n          In entities which do not act as IP Gateways, this\n          counter will include only those packets which were\n          Source-Routed via this entity, and the Source-\n          Route option processing was successful.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipInUnknownProtos": {
                "type": "integer",
                "description": "The number of locally-addressed datagrams\n          received successfully but discarded because of an\n          unknown or unsupported protocol.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipInDiscards": {
                "type": "integer",
                "description": "The number of input IP datagrams for which no\n          problems were encountered to prevent their\n          continued processing, but which were discarded\n          (e.g., for lack of buffer space).  Note that this\n          counter does not include any datagrams discarded\n          while awaiting re-assembly.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipInDelivers": {
                "type": "integer",
                "description": "The total number of input datagrams successfully\n          delivered to IP user-protocols (including ICMP).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipOutRequests": {
                "type": "integer",
                "description": "The total number of IP datagrams which local IP\n          user-protocols (including ICMP) supplied to IP in\n          requests for transmission.  Note that this counter\n          does not include any datagrams counted in\n          ipForwDatagrams.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipOutDiscards": {
                "type": "integer",
                "description": "The number of output IP datagrams for which no\n          problem was encountered to prevent their\n          transmission to their destination, but which were\n          discarded (e.g., for lack of buffer space).  Note\n          that this counter would include datagrams counted\n          in ipForwDatagrams if any such packets met this\n          (discretionary) discard criterion.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipOutNoRoutes": {
                "type": "integer",
                "description": "The number of IP datagrams discarded because no\n          route could be found to transmit them to their\n          destination.  Note that this counter includes any\n          packets counted in ipForwDatagrams which meet this\n          `no-route' criterion.  Note that this includes any\n          datagrams which a host cannot route because all of\n          its default gateways are down.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipReasmTimeout": {
                "type": "integer",
                "description": "The maximum number of seconds which received\n          fragments are held while they are awaiting\n          reassembly at this entity.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipReasmReqds": {
                "type": "integer",
                "description": "The number of IP fragments received which needed\n          to be reassembled at this entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipReasmOKs": {
                "type": "integer",
                "description": "The number of IP datagrams successfully re-\n          assembled.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipReasmFails": {
                "type": "integer",
                "description": "The number of failures detected by the IP re-\n          assembly algorithm (for whatever reason: timed\n          out, errors, etc).  Note that this is not\n          necessarily a count of discarded IP fragments\n          since some algorithms (notably the algorithm in\n          RFC 815) can lose track of the number of fragments\n          by combining them as they are received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipFragOKs": {
                "type": "integer",
                "description": "The number of IP datagrams that have been\n          successfully fragmented at this entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipFragFails": {
                "type": "integer",
                "description": "The number of IP datagrams that have been\n          discarded because they needed to be fragmented at\n          this entity but could not be, e.g., because their\n          Don't Fragment flag was set.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipFragCreates": {
                "type": "integer",
                "description": "The number of IP datagram fragments that have\n          been generated as a result of fragmentation at\n          this entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ipRoutingDiscards": {
                "type": "integer",
                "description": "The number of routing entries which were chosen\n          to be discarded even though they are valid.  One\n          possible reason for discarding such an entry could\n          be to free-up buffer space for other routing\n          entries.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "icmp": {
            "type": "object",
            "description": "The total number of ICMP messages which the\n          entity received.  Note that this counter includes\n          all those counted by icmpInErrors.",
            "properties": {
              "icmpInMsgs": {
                "type": "integer",
                "description": "The total number of ICMP messages which the\n          entity received.  Note that this counter includes\n          all those counted by icmpInErrors.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInErrors": {
                "type": "integer",
                "description": "The number of ICMP messages which the entity\n          received but determined as having ICMP-specific\n          errors (bad ICMP checksums, bad length, etc.).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInDestUnreachs": {
                "type": "integer",
                "description": "The number of ICMP Destination Unreachable\n          messages received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInTimeExcds": {
                "type": "integer",
                "description": "The number of ICMP Time Exceeded messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInParmProbs": {
                "type": "integer",
                "description": "The number of ICMP Parameter Problem messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInSrcQuenchs": {
                "type": "integer",
                "description": "The number of ICMP Source Quench messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInRedirects": {
                "type": "integer",
                "description": "The number of ICMP Redirect messages received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInEchos": {
                "type": "integer",
                "description": "The number of ICMP Echo (request) messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInEchoReps": {
                "type": "integer",
                "description": "The number of ICMP Echo Reply messages received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInTimestamps": {
                "type": "integer",
                "description": "The number of ICMP Timestamp (request) messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInTimestampReps": {
                "type": "integer",
                "description": "The number of ICMP Timestamp Reply messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInAddrMasks": {
                "type": "integer",
                "description": "The number of ICMP Address Mask Request messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpInAddrMaskReps": {
                "type": "integer",
                "description": "The number of ICMP Address Mask Reply messages\n          received.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutMsgs": {
                "type": "integer",
                "description": "The total number of ICMP messages which this\n          entity attempted to send.  Note that this counter\n          includes all those counted by icmpOutErrors.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutErrors": {
                "type": "integer",
                "description": "The number of ICMP messages which this entity did\n          not send due to problems discovered within ICMP\n          such as a lack of buffers.  This value should not\n          include errors discovered outside the ICMP layer\n          such as the inability of IP to route the resultant\n          datagram.  In some implementations there may be no\n          types of error which contribute to this counter's\n          value.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutDestUnreachs": {
                "type": "integer",
                "description": "The number of ICMP Destination Unreachable\n          messages sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutTimeExcds": {
                "type": "integer",
                "description": "The number of ICMP Time Exceeded messages sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutParmProbs": {
                "type": "integer",
                "description": "The number of ICMP Parameter Problem messages\n          sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutSrcQuenchs": {
                "type": "integer",
                "description": "The number of ICMP Source Quench messages sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutRedirects": {
                "type": "integer",
                "description": "The number of ICMP Redirect messages sent.  For a\n          host, this object will always be zero, since hosts\n          do not send redirects.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutEchos": {
                "type": "integer",
                "description": "The number of ICMP Echo (request) messages sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutEchoReps": {
                "type": "integer",
                "description": "The number of ICMP Echo Reply messages sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutTimestamps": {
                "type": "integer",
                "description": "The number of ICMP Timestamp (request) messages\n          sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutTimestampReps": {
                "type": "integer",
                "description": "The number of ICMP Timestamp Reply messages\n          sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutAddrMasks": {
                "type": "integer",
                "description": "The number of ICMP Address Mask Request messages\n          sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "icmpOutAddrMaskReps": {
                "type": "integer",
                "description": "The number of ICMP Address Mask Reply messages\n          sent.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "tcp": {
            "type": "object",
            "description": "tcp",
            "properties": {
              "tcpRtoAlgorithm": {
                "type": "string",
                "description": "The algorithm used to determine the timeout value\n          used for retransmitting unacknowledged octets."
              },
              "tcpRtoMin": {
                "type": "integer",
                "description": "The minimum value permitted by a TCP\n          implementation for the retransmission timeout,\n          measured in milliseconds.  More refined semantics\n          for objects of this type depend upon the algorithm\n          used to determine the retransmission timeout.  In\n          particular, when the timeout algorithm is rsre(3),\n          an object of this type has the semantics of the\n          LBOUND quantity described in RFC 793.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "tcpRtoMax": {
                "type": "integer",
                "description": "The maximum value permitted by a TCP\n          implementation for the retransmission timeout,\n          measured in milliseconds.  More refined semantics\n          for objects of this type depend upon the algorithm\n          used to determine the retransmission timeout.  In\n          particular, when the timeout algorithm is rsre(3),\n          an object of this type has the semantics of the\n          UBOUND quantity described in RFC 793.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "tcpMaxConn": {
                "type": "integer",
                "description": "The limit on the total number of TCP connections\n          the entity can support.  In entities where the\n          maximum number of connections is dynamic, this\n          object should contain the value -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "tcpActiveOpens": {
                "type": "integer",
                "description": "The number of times TCP connections have made a\n          direct transition to the SYN-SENT state from the\n          CLOSED state.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpPassiveOpens": {
                "type": "integer",
                "description": "The number of times TCP connections have made a\n          direct transition to the SYN-RCVD state from the\n          LISTEN state.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpAttemptFails": {
                "type": "integer",
                "description": "The number of times TCP connections have made a\n          direct transition to the CLOSED state from either\n          the SYN-SENT state or the SYN-RCVD state, plus the\n          number of times TCP connections have made a direct\n          transition to the LISTEN state from the SYN-RCVD\n          state.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpEstabResets": {
                "type": "integer",
                "description": "The number of times TCP connections have made a\n          direct transition to the CLOSED state from either\n          the ESTABLISHED state or the CLOSE-WAIT state.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpCurrEstab": {
                "type": "integer",
                "description": "The number of TCP connections for which the\n          current state is either ESTABLISHED or CLOSE-\n          WAIT.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpInSegs": {
                "type": "integer",
                "description": "The total number of segments received, including\n          those received in error.  This count includes\n          segments received on currently established\n          connections.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpOutSegs": {
                "type": "integer",
                "description": "The total number of segments sent, including\n          those on current connections but excluding those\n          containing only retransmitted octets.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpRetransSegs": {
                "type": "integer",
                "description": "The total number of segments retransmitted - that\n          is, the number of TCP segments transmitted\n          containing one or more previously transmitted\n          octets.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpInErrs": {
                "type": "integer",
                "description": "The total number of segments received in error\n          (e.g., bad TCP checksums).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "tcpOutRsts": {
                "type": "integer",
                "description": "The number of TCP segments sent containing the\n          RST flag.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "udp": {
            "type": "object",
            "description": "The total number of UDP datagrams delivered to\n          UDP users.",
            "properties": {
              "udpInDatagrams": {
                "type": "integer",
                "description": "The total number of UDP datagrams delivered to\n          UDP users.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "udpNoPorts": {
                "type": "integer",
                "description": "The total number of received UDP datagrams for\n          which there was no application at the destination\n          port.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "udpInErrors": {
                "type": "integer",
                "description": "The number of received UDP datagrams that could\n          not be delivered for reasons other than the lack\n          of an application at the destination port.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "udpOutDatagrams": {
                "type": "integer",
                "description": "The total number of UDP datagrams sent from this\n          entity.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "egp": {
            "type": "object",
            "description": "The number of EGP messages received without\n          error.",
            "properties": {
              "egpInMsgs": {
                "type": "integer",
                "description": "The number of EGP messages received without\n          error.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpInErrors": {
                "type": "integer",
                "description": "The number of EGP messages received that proved\n          to be in error.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpOutMsgs": {
                "type": "integer",
                "description": "The total number of locally generated EGP\n          messages.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpOutErrors": {
                "type": "integer",
                "description": "The number of locally generated EGP messages not\n          sent due to resource limitations within an EGP\n          entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpAs": {
                "type": "integer",
                "description": "The autonomous system number of this EGP entity.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "snmp": {
            "type": "object",
            "description": "The total number of Messages delivered to the\n          SNMP entity from the transport service.",
            "properties": {
              "snmpInPkts": {
                "type": "integer",
                "description": "The total number of Messages delivered to the\n          SNMP entity from the transport service.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutPkts": {
                "type": "integer",
                "description": "The total number of SNMP Messages which were\n          passed from the SNMP protocol entity to the\n          transport service.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInBadVersions": {
                "type": "integer",
                "description": "The total number of SNMP Messages which were\n          delivered to the SNMP protocol entity and were for\n          an unsupported SNMP version.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInBadCommunityNames": {
                "type": "integer",
                "description": "The total number of SNMP Messages delivered to\n          the SNMP protocol entity which used a SNMP\n          community name not known to said entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInBadCommunityUses": {
                "type": "integer",
                "description": "The total number of SNMP Messages delivered to\n          the SNMP protocol entity which represented an SNMP\n          operation which was not allowed by the SNMP\n          community named in the Message.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInASNParseErrs": {
                "type": "integer",
                "description": "The total number of ASN.1 or BER errors\n          encountered by the SNMP protocol entity when\n          decoding received SNMP Messages.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInTooBigs": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `tooBig'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInNoSuchNames": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `noSuchName'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInBadValues": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `badValue'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInReadOnlys": {
                "type": "integer",
                "description": "The total number valid SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `readOnly'.  It should be noted that it is a\n          protocol error to generate an SNMP PDU which\n          contains the value `readOnly' in the error-status\n          field, as such this object is provided as a means\n          of detecting incorrect implementations of the\n          SNMP.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInGenErrs": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          delivered to the SNMP protocol entity and for\n          which the value of the error-status field is\n          `genErr'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInTotalReqVars": {
                "type": "integer",
                "description": "The total number of MIB objects which have been\n          retrieved successfully by the SNMP protocol entity\n          as the result of receiving valid SNMP Get-Request\n          and Get-Next PDUs.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInTotalSetVars": {
                "type": "integer",
                "description": "The total number of MIB objects which have been\n          altered successfully by the SNMP protocol entity\n          as the result of receiving valid SNMP Set-Request\n          PDUs.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInGetRequests": {
                "type": "integer",
                "description": "The total number of SNMP Get-Request PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInGetNexts": {
                "type": "integer",
                "description": "The total number of SNMP Get-Next PDUs which have\n          been accepted and processed by the SNMP protocol\n          entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInSetRequests": {
                "type": "integer",
                "description": "The total number of SNMP Set-Request PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInGetResponses": {
                "type": "integer",
                "description": "The total number of SNMP Get-Response PDUs which\n          have been accepted and processed by the SNMP\n          protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpInTraps": {
                "type": "integer",
                "description": "The total number of SNMP Trap PDUs which have\n          been accepted and processed by the SNMP protocol\n          entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutTooBigs": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `tooBig.'",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutNoSuchNames": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status is\n          `noSuchName'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutBadValues": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `badValue'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutGenErrs": {
                "type": "integer",
                "description": "The total number of SNMP PDUs which were\n          generated by the SNMP protocol entity and for\n          which the value of the error-status field is\n          `genErr'.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutGetRequests": {
                "type": "integer",
                "description": "The total number of SNMP Get-Request PDUs which\n          have been generated by the SNMP protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutGetNexts": {
                "type": "integer",
                "description": "The total number of SNMP Get-Next PDUs which have\n          been generated by the SNMP protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutSetRequests": {
                "type": "integer",
                "description": "The total number of SNMP Set-Request PDUs which\n          have been generated by the SNMP protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutGetResponses": {
                "type": "integer",
                "description": "The total number of SNMP Get-Response PDUs which\n          have been generated by the SNMP protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpOutTraps": {
                "type": "integer",
                "description": "The total number of SNMP Trap PDUs which have\n          been generated by the SNMP protocol entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "snmpEnableAuthenTraps": {
                "type": "string",
                "description": "Indicates whether the SNMP agent process is\n          permitted to generate authentication-failure\n          traps.  The value of this object overrides any\n          configuration information; as such, it provides a\n          means whereby all authentication-failure traps may\n          be disabled.\n          \n          Note that it is strongly recommended that this\n          object be stored in non-volatile memory so that it\n          remains constant between re-initializations of the\n          network management system."
              }
            }
          },
          "ifTable": {
            "type": "object",
            "description": "A list of interface entries.  The number of\n        entries is given by the value of ifNumber.",
            "properties": {
              "ifIndex": {
                "type": "integer",
                "description": "A unique value for each interface.  Its value\n            ranges between 1 and the value of ifNumber.  The\n            value for each interface must remain constant at\n            least from one re-initialization of the entity's\n            network management system to the next re-\n            initialization.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ifDescr": {
                "type": "string",
                "description": "A textual string containing information about the\n            interface.  This string should include the name of\n            the manufacturer, the product name and the version\n            of the hardware interface.",
                "x-yang-type": "RFC1213-MIB:DisplayString"
              },
              "ifType": {
                "type": "string",
                "description": "The type of interface.  Additional values for ifType\n            are assigned by the Internet Assigned Numbers\n            Authority (IANA), through updating the syntax of the\n            IANAifType textual convention.",
                "x-yang-type": "ianaiftype-mib:IANAifType"
              },
              "ifMtu": {
                "type": "integer",
                "description": "The size of the largest datagram which can be\n            sent/received on the interface, specified in\n            octets.  For interfaces that are used for\n            transmitting network datagrams, this is the size\n            of the largest network datagram that can be sent\n            on the interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ifSpeed": {
                "type": "integer",
                "description": "An estimate of the interface's current bandwidth\n            in bits per second.  For interfaces which do not\n            vary in bandwidth or for those where no accurate\n            estimation can be made, this object should contain\n            the nominal bandwidth.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifPhysAddress": {
                "type": "string",
                "description": "The interface's address at the protocol layer\n            immediately `below' the network layer in the\n            protocol stack.  For interfaces which do not have\n            such an address (e.g., a serial line), this object\n            should contain an octet string of zero length.",
                "x-yang-type": "RFC1213-MIB:PhysAddress"
              },
              "ifAdminStatus": {
                "type": "string",
                "description": "The desired state of the interface.  The\n            testing(3) state indicates that no operational\n            packets can be passed."
              },
              "ifOperStatus": {
                "type": "string",
                "description": "The current operational state of the interface.\n            The testing(3) state indicates that no operational\n            packets can be passed."
              },
              "ifLastChange": {
                "type": "string",
                "description": "The value of sysUpTime at the time the interface\n            entered its current operational state.  If the\n            current state was entered prior to the last re-\n            initialization of the local network management\n            subsystem, then this object contains a zero\n            value.",
                "x-yang-type": "yang:timeticks"
              },
              "ifInOctets": {
                "type": "integer",
                "description": "The total number of octets received on the\n            interface, including framing characters.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifInUcastPkts": {
                "type": "integer",
                "description": "The number of subnetwork-unicast packets\n            delivered to a higher-layer protocol.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifInNUcastPkts": {
                "type": "integer",
                "description": "The number of non-unicast (i.e., subnetwork-\n            broadcast or subnetwork-multicast) packets\n            delivered to a higher-layer protocol.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifInDiscards": {
                "type": "integer",
                "description": "The number of inbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being deliverable to a\n            higher-layer protocol.  One possible reason for\n            discarding such a packet could be to free up\n            buffer space.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifInErrors": {
                "type": "integer",
                "description": "The number of inbound packets that contained\n            errors preventing them from being deliverable to a\n            higher-layer protocol.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifInUnknownProtos": {
                "type": "integer",
                "description": "The number of packets received via the interface\n            which were discarded because of an unknown or\n            unsupported protocol.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutOctets": {
                "type": "integer",
                "description": "The total number of octets transmitted out of the\n            interface, including framing characters.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutUcastPkts": {
                "type": "integer",
                "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a\n            subnetwork-unicast address, including those that\n            were discarded or not sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutNUcastPkts": {
                "type": "integer",
                "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a non-\n            unicast (i.e., a subnetwork-broadcast or\n            subnetwork-multicast) address, including those\n            that were discarded or not sent.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutDiscards": {
                "type": "integer",
                "description": "The number of outbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being transmitted.  One\n            possible reason for discarding such a packet could\n            be to free up buffer space.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutErrors": {
                "type": "integer",
                "description": "The number of outbound packets that could not be\n            transmitted because of errors.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifOutQLen": {
                "type": "integer",
                "description": "The length of the output packet queue (in\n            packets).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "ifSpecific": {
                "type": "string",
                "description": "A reference to MIB definitions specific to the\n            particular media being used to realize the\n            interface.  For example, if the interface is\n            realized by an ethernet, then the value of this\n            object refers to a document defining objects\n            specific to ethernet.  If this information is not\n            present, its value should be set to the OBJECT\n            IDENTIFIER { 0 0 }, which is a syntactically valid\n            object identifier, and any conformant\n            implementation of ASN.1 and BER must be able to\n            generate and recognize this value.",
                "x-yang-type": "yang:object-identifier-128"
              }
            }
          },
          "atTable": {
            "type": "object",
            "description": "The Address Translation tables contain the\n        NetworkAddress to `physical' address equivalences.\n        Some interfaces do not use translation tables for\n        determining address equivalences (e.g., DDN-X.25\n        has an algorithmic method); if all interfaces are\n        of this type, then the Address Translation table\n        is empty, i.e., has zero entries.",
            "properties": {
              "atIfIndex": {
                "type": "integer",
                "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "atIfIndex_2": {
                "type": "integer",
                "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "atPhysAddress": {
                "type": "string",
                "description": "The media-dependent `physical' address.\n            \n            Setting this object to a null string (one of zero\n            length) has the effect of invaliding the\n            corresponding entry in the atTable object.  That\n            is, it effectively disassociates the interface\n            identified with said entry from the mapping\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant atPhysAddress object.",
                "x-yang-type": "RFC1213-MIB:PhysAddress"
              },
              "atNetAddress": {
                "type": "string",
                "description": "The NetworkAddress (e.g., the IP address)\n            corresponding to the media-dependent `physical'\n            address.",
                "format": "inet:ipv4-address"
              }
            }
          },
          "ipAddrTable": {
            "type": "object",
            "description": "The table of addressing information relevant to\n        this entity's IP addresses.",
            "properties": {
              "ipAdEntAddr": {
                "type": "string",
                "description": "The IP address to which this entry's addressing\n            information pertains.",
                "format": "inet:ipv4-address"
              },
              "ipAdEntIfIndex": {
                "type": "integer",
                "description": "The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipAdEntNetMask": {
                "type": "string",
                "description": "The subnet mask associated with the IP address of\n            this entry.  The value of the mask is an IP\n            address with all the network bits set to 1 and all\n            the hosts bits set to 0.",
                "format": "inet:ipv4-address"
              },
              "ipAdEntBcastAddr": {
                "type": "integer",
                "description": "The value of the least-significant bit in the IP\n            broadcast address used for sending datagrams on\n            the (logical) interface associated with the IP\n            address of this entry.  For example, when the\n            Internet standard all-ones broadcast address is\n            used, the value will be 1.  This value applies to\n            both the subnet and network broadcasts addresses\n            used by the entity on this (logical) interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipAdEntReasmMaxSize": {
                "type": "integer",
                "description": "The size of the largest IP datagram which this\n            entity can re-assemble from incoming IP fragmented\n            datagrams received on this interface.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "ipRouteTable": {
            "type": "object",
            "description": "This entity's IP Routing table.",
            "properties": {
              "ipRouteDest": {
                "type": "string",
                "description": "The destination IP address of this route.  An\n            entry with a value of 0.0.0.0 is considered a\n            default route.  Multiple routes to a single\n            destination can appear in the table, but access to\n            such multiple entries is dependent on the table-\n            access mechanisms defined by the network\n            management protocol in use.",
                "format": "inet:ipv4-address"
              },
              "ipRouteIfIndex": {
                "type": "integer",
                "description": "The index value which uniquely identifies the\n            local interface through which the next hop of this\n            route should be reached.  The interface identified\n            by a particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteMetric1": {
                "type": "integer",
                "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteMetric2": {
                "type": "integer",
                "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteMetric3": {
                "type": "integer",
                "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteMetric4": {
                "type": "integer",
                "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteNextHop": {
                "type": "string",
                "description": "The IP address of the next hop of this route.\n            (In the case of a route bound to an interface\n            which is realized via a broadcast media, the value\n            of this field is the agent's IP address on that\n            interface.)",
                "format": "inet:ipv4-address"
              },
              "ipRouteType": {
                "type": "string",
                "description": "The type of route.  Note that the values\n            direct(3) and indirect(4) refer to the notion of\n            direct and indirect routing in the IP\n            architecture.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipRouteTable object.  That is, it\n            effectively disassociates the destination\n            identified with said entry from the route\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant ipRouteType object."
              },
              "ipRouteProto": {
                "type": "string",
                "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway routing\n            protocols is not intended to imply that hosts\n            should support those protocols."
              },
              "ipRouteAge": {
                "type": "integer",
                "description": "The number of seconds since this route was last\n            updated or otherwise determined to be correct.\n            Note that no semantics of `too old' can be implied\n            except through knowledge of the routing protocol\n            by which the route was learned.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteMask": {
                "type": "string",
                "description": "Indicate the mask to be logical-ANDed with the\n            destination address before being compared to the\n            value in the ipRouteDest field.  For those systems\n            that do not support arbitrary subnet masks, an\n            agent constructs the value of the ipRouteMask by\n            determining whether the value of the correspondent\n            ipRouteDest field belong to a class-A, B, or C\n            network, and then using one of:\n            \n                 mask           network\n                 255.0.0.0      class-A\n                 255.255.0.0    class-B\n                 255.255.255.0  class-C\n            \n            If the value of the ipRouteDest is 0.0.0.0 (a\n            default route), then the mask value is also\n            0.0.0.0.  It should be noted that all IP routing\n            subsystems implicitly use this mechanism.",
                "format": "inet:ipv4-address"
              },
              "ipRouteMetric5": {
                "type": "integer",
                "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipRouteInfo": {
                "type": "string",
                "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsible\n            for this route, as determined by the value\n            specified in the route's ipRouteProto value.  If\n            this information is not present, its value should\n            be set to the OBJECT IDENTIFIER { 0 0 }, which is\n            a syntactically valid object identifier, and any\n            conformant implementation of ASN.1 and BER must be\n            able to generate and recognize this value.",
                "x-yang-type": "yang:object-identifier-128"
              }
            }
          },
          "ipNetToMediaTable": {
            "type": "object",
            "description": "The IP Address Translation table used for mapping\n        from IP addresses to physical addresses.",
            "properties": {
              "ipNetToMediaIfIndex": {
                "type": "integer",
                "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "ipNetToMediaPhysAddress": {
                "type": "string",
                "description": "The media-dependent `physical' address.",
                "x-yang-type": "RFC1213-MIB:PhysAddress"
              },
              "ipNetToMediaNetAddress": {
                "type": "string",
                "description": "The IpAddress corresponding to the media-\n            dependent `physical' address.",
                "format": "inet:ipv4-address"
              },
              "ipNetToMediaType": {
                "type": "string",
                "description": "The type of mapping.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipNetToMediaTable.  That is, it effectively\n            disassociates the interface identified with said\n            entry from the mapping identified with said entry.\n            It is an implementation-specific matter as to\n            whether the agent removes an invalidated entry\n            from the table.  Accordingly, management stations\n            must be prepared to receive tabular information\n            from agents that corresponds to entries not\n            currently in use.  Proper interpretation of such\n            entries requires examination of the relevant\n            ipNetToMediaType object."
              }
            }
          },
          "tcpConnTable": {
            "type": "object",
            "description": "A table containing TCP connection-specific\n        information.",
            "properties": {
              "tcpConnState": {
                "type": "string",
                "description": "The state of this TCP connection.\n            \n            The only value which may be set by a management\n            station is deleteTCB(12).  Accordingly, it is\n            appropriate for an agent to return a `badValue'\n            response if a management station attempts to set\n            this object to any other value.\n            \n            If a management station sets this object to the\n            value deleteTCB(12), then this has the effect of\n            deleting the TCB (as defined in RFC 793) of the\n            corresponding connection on the managed node,\n            resulting in immediate termination of the\n            connection.\n            \n            As an implementation-specific option, a RST\n            segment may be sent from the managed node to the\n            other TCP endpoint (note however that RST segments\n            are not sent reliably)."
              },
              "tcpConnLocalAddress": {
                "type": "string",
                "description": "The local IP address for this TCP connection.  In\n            the case of a connection in the listen state which\n            is willing to accept connections for any IP\n            interface associated with the node, the value\n            0.0.0.0 is used.",
                "format": "inet:ipv4-address"
              },
              "tcpConnLocalPort": {
                "type": "integer",
                "description": "The local port number for this TCP connection.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "tcpConnRemAddress": {
                "type": "string",
                "description": "The remote IP address for this TCP connection.",
                "format": "inet:ipv4-address"
              },
              "tcpConnRemPort": {
                "type": "integer",
                "description": "The remote port number for this TCP connection.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "udpTable": {
            "type": "object",
            "description": "A table containing UDP listener information.",
            "properties": {
              "udpLocalAddress": {
                "type": "string",
                "description": "The local IP address for this UDP listener.  In\n            the case of a UDP listener which is willing to\n            accept datagrams for any IP interface associated\n            with the node, the value 0.0.0.0 is used.",
                "format": "inet:ipv4-address"
              },
              "udpLocalPort": {
                "type": "integer",
                "description": "The local port number for this UDP listener.",
                "minimum": -2147483648,
                "maximum": 2147483647
              }
            }
          },
          "egpNeighTable": {
            "type": "object",
            "description": "The EGP neighbor table.",
            "properties": {
              "egpNeighState": {
                "type": "string",
                "description": "The EGP state of the local system with respect to\n            this entry's EGP neighbor.  Each EGP state is\n            represented by a value that is one greater than\n            the numerical value associated with said state in\n            RFC 904."
              },
              "egpNeighAddr": {
                "type": "string",
                "description": "The IP address of this entry's EGP neighbor.",
                "format": "inet:ipv4-address"
              },
              "egpNeighAs": {
                "type": "integer",
                "description": "The autonomous system of this EGP peer.  Zero\n            should be specified if the autonomous system\n            number of the neighbor is not yet known.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "egpNeighInMsgs": {
                "type": "integer",
                "description": "The number of EGP messages received without error\n            from this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighInErrs": {
                "type": "integer",
                "description": "The number of EGP messages received from this EGP\n            peer that proved to be in error (e.g., bad EGP\n            checksum).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighOutMsgs": {
                "type": "integer",
                "description": "The number of locally generated EGP messages to\n            this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighOutErrs": {
                "type": "integer",
                "description": "The number of locally generated EGP messages not\n            sent to this EGP peer due to resource limitations\n            within an EGP entity.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighInErrMsgs": {
                "type": "integer",
                "description": "The number of EGP-defined error messages received\n            from this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighOutErrMsgs": {
                "type": "integer",
                "description": "The number of EGP-defined error messages sent to\n            this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighStateUps": {
                "type": "integer",
                "description": "The number of EGP state transitions to the UP\n            state with this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighStateDowns": {
                "type": "integer",
                "description": "The number of EGP state transitions from the UP\n            state to any other state with this EGP peer.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "egpNeighIntervalHello": {
                "type": "integer",
                "description": "The interval between EGP Hello command\n            retransmissions (in hundredths of a second).  This\n            represents the t1 timer as defined in RFC 904.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "egpNeighIntervalPoll": {
                "type": "integer",
                "description": "The interval between EGP poll command\n            retransmissions (in hundredths of a second).  This\n            represents the t3 timer as defined in RFC 904.",
                "minimum": -2147483648,
                "maximum": 2147483647
              },
              "egpNeighMode": {
                "type": "string",
                "description": "The polling mode of this EGP entity, either\n            passive or active."
              },
              "egpNeighEventTrigger": {
                "type": "string",
                "description": "A control variable used to trigger operator-\n            initiated Start and Stop events.  When read, this\n            variable always returns the most recent value that\n            egpNeighEventTrigger was set to.  If it has not\n            been set since the last initialization of the\n            network management subsystem on the node, it\n            returns a value of `stop'.\n            \n            When set, this variable causes a Start or Stop\n            event on the specified neighbor, as specified on\n            pages 8-10 of RFC 904.  Briefly, a Start event\n            causes an Idle peer to begin neighbor acquisition\n            and a non-Idle peer to reinitiate neighbor\n            acquisition.  A stop event causes a non-Idle peer\n            to return to the Idle state until a Start event\n            occurs, either via egpNeighEventTrigger or\n            otherwise."
              }
            }
          }
        }
      },
      "RFC1213-MIB_ifEntry": {
        "type": "array",
        "description": "An interface entry containing objects at the\n          subnetwork layer and below for a particular\n          interface.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ifIndex": {
              "type": "integer",
              "description": "A unique value for each interface.  Its value\n            ranges between 1 and the value of ifNumber.  The\n            value for each interface must remain constant at\n            least from one re-initialization of the entity's\n            network management system to the next re-\n            initialization.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ifDescr": {
              "type": "string",
              "description": "A textual string containing information about the\n            interface.  This string should include the name of\n            the manufacturer, the product name and the version\n            of the hardware interface.",
              "x-yang-type": "RFC1213-MIB:DisplayString"
            },
            "ifType": {
              "type": "string",
              "description": "The type of interface.  Additional values for ifType\n            are assigned by the Internet Assigned Numbers\n            Authority (IANA), through updating the syntax of the\n            IANAifType textual convention.",
              "x-yang-type": "ianaiftype-mib:IANAifType"
            },
            "ifMtu": {
              "type": "integer",
              "description": "The size of the largest datagram which can be\n            sent/received on the interface, specified in\n            octets.  For interfaces that are used for\n            transmitting network datagrams, this is the size\n            of the largest network datagram that can be sent\n            on the interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ifSpeed": {
              "type": "integer",
              "description": "An estimate of the interface's current bandwidth\n            in bits per second.  For interfaces which do not\n            vary in bandwidth or for those where no accurate\n            estimation can be made, this object should contain\n            the nominal bandwidth.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifPhysAddress": {
              "type": "string",
              "description": "The interface's address at the protocol layer\n            immediately `below' the network layer in the\n            protocol stack.  For interfaces which do not have\n            such an address (e.g., a serial line), this object\n            should contain an octet string of zero length.",
              "x-yang-type": "RFC1213-MIB:PhysAddress"
            },
            "ifAdminStatus": {
              "type": "string",
              "description": "The desired state of the interface.  The\n            testing(3) state indicates that no operational\n            packets can be passed."
            },
            "ifOperStatus": {
              "type": "string",
              "description": "The current operational state of the interface.\n            The testing(3) state indicates that no operational\n            packets can be passed."
            },
            "ifLastChange": {
              "type": "string",
              "description": "The value of sysUpTime at the time the interface\n            entered its current operational state.  If the\n            current state was entered prior to the last re-\n            initialization of the local network management\n            subsystem, then this object contains a zero\n            value.",
              "x-yang-type": "yang:timeticks"
            },
            "ifInOctets": {
              "type": "integer",
              "description": "The total number of octets received on the\n            interface, including framing characters.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifInUcastPkts": {
              "type": "integer",
              "description": "The number of subnetwork-unicast packets\n            delivered to a higher-layer protocol.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifInNUcastPkts": {
              "type": "integer",
              "description": "The number of non-unicast (i.e., subnetwork-\n            broadcast or subnetwork-multicast) packets\n            delivered to a higher-layer protocol.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifInDiscards": {
              "type": "integer",
              "description": "The number of inbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being deliverable to a\n            higher-layer protocol.  One possible reason for\n            discarding such a packet could be to free up\n            buffer space.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifInErrors": {
              "type": "integer",
              "description": "The number of inbound packets that contained\n            errors preventing them from being deliverable to a\n            higher-layer protocol.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifInUnknownProtos": {
              "type": "integer",
              "description": "The number of packets received via the interface\n            which were discarded because of an unknown or\n            unsupported protocol.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutOctets": {
              "type": "integer",
              "description": "The total number of octets transmitted out of the\n            interface, including framing characters.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutUcastPkts": {
              "type": "integer",
              "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a\n            subnetwork-unicast address, including those that\n            were discarded or not sent.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutNUcastPkts": {
              "type": "integer",
              "description": "The total number of packets that higher-level\n            protocols requested be transmitted to a non-\n            unicast (i.e., a subnetwork-broadcast or\n            subnetwork-multicast) address, including those\n            that were discarded or not sent.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutDiscards": {
              "type": "integer",
              "description": "The number of outbound packets which were chosen\n            to be discarded even though no errors had been\n            detected to prevent their being transmitted.  One\n            possible reason for discarding such a packet could\n            be to free up buffer space.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutErrors": {
              "type": "integer",
              "description": "The number of outbound packets that could not be\n            transmitted because of errors.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifOutQLen": {
              "type": "integer",
              "description": "The length of the output packet queue (in\n            packets).",
              "minimum": 0,
              "maximum": 4294967295
            },
            "ifSpecific": {
              "type": "string",
              "description": "A reference to MIB definitions specific to the\n            particular media being used to realize the\n            interface.  For example, if the interface is\n            realized by an ethernet, then the value of this\n            object refers to a document defining objects\n            specific to ethernet.  If this information is not\n            present, its value should be set to the OBJECT\n            IDENTIFIER { 0 0 }, which is a syntactically valid\n            object identifier, and any conformant\n            implementation of ASN.1 and BER must be able to\n            generate and recognize this value.",
              "x-yang-type": "yang:object-identifier-128"
            }
          }
        }
      },
      "RFC1213-MIB_atEntry": {
        "type": "array",
        "description": "Each entry contains one NetworkAddress to\n          `physical' address equivalence.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "atIfIndex": {
              "type": "integer",
              "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "atIfIndex_2": {
              "type": "integer",
              "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "atPhysAddress": {
              "type": "string",
              "description": "The media-dependent `physical' address.\n            \n            Setting this object to a null string (one of zero\n            length) has the effect of invaliding the\n            corresponding entry in the atTable object.  That\n            is, it effectively disassociates the interface\n            identified with said entry from the mapping\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant atPhysAddress object.",
              "x-yang-type": "RFC1213-MIB:PhysAddress"
            },
            "atNetAddress": {
              "type": "string",
              "description": "The NetworkAddress (e.g., the IP address)\n            corresponding to the media-dependent `physical'\n            address.",
              "format": "inet:ipv4-address"
            }
          }
        }
      },
      "RFC1213-MIB_ipAddrEntry": {
        "type": "array",
        "description": "The addressing information for one of this\n          entity's IP addresses.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ipAdEntAddr": {
              "type": "string",
              "description": "The IP address to which this entry's addressing\n            information pertains.",
              "format": "inet:ipv4-address"
            },
            "ipAdEntIfIndex": {
              "type": "integer",
              "description": "The index value which uniquely identifies the\n            interface to which this entry is applicable.  The\n            interface identified by a particular value of this\n            index is the same interface as identified by the\n            same value of ifIndex.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipAdEntNetMask": {
              "type": "string",
              "description": "The subnet mask associated with the IP address of\n            this entry.  The value of the mask is an IP\n            address with all the network bits set to 1 and all\n            the hosts bits set to 0.",
              "format": "inet:ipv4-address"
            },
            "ipAdEntBcastAddr": {
              "type": "integer",
              "description": "The value of the least-significant bit in the IP\n            broadcast address used for sending datagrams on\n            the (logical) interface associated with the IP\n            address of this entry.  For example, when the\n            Internet standard all-ones broadcast address is\n            used, the value will be 1.  This value applies to\n            both the subnet and network broadcasts addresses\n            used by the entity on this (logical) interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipAdEntReasmMaxSize": {
              "type": "integer",
              "description": "The size of the largest IP datagram which this\n            entity can re-assemble from incoming IP fragmented\n            datagrams received on this interface.",
              "minimum": -2147483648,
              "maximum": 2147483647
            }
          }
        }
      },
      "RFC1213-MIB_ipRouteEntry": {
        "type": "array",
        "description": "A route to a particular destination.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ipRouteDest": {
              "type": "string",
              "description": "The destination IP address of this route.  An\n            entry with a value of 0.0.0.0 is considered a\n            default route.  Multiple routes to a single\n            destination can appear in the table, but access to\n            such multiple entries is dependent on the table-\n            access mechanisms defined by the network\n            management protocol in use.",
              "format": "inet:ipv4-address"
            },
            "ipRouteIfIndex": {
              "type": "integer",
              "description": "The index value which uniquely identifies the\n            local interface through which the next hop of this\n            route should be reached.  The interface identified\n            by a particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteMetric1": {
              "type": "integer",
              "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteMetric2": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteMetric3": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteMetric4": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteNextHop": {
              "type": "string",
              "description": "The IP address of the next hop of this route.\n            (In the case of a route bound to an interface\n            which is realized via a broadcast media, the value\n            of this field is the agent's IP address on that\n            interface.)",
              "format": "inet:ipv4-address"
            },
            "ipRouteType": {
              "type": "string",
              "description": "The type of route.  Note that the values\n            direct(3) and indirect(4) refer to the notion of\n            direct and indirect routing in the IP\n            architecture.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipRouteTable object.  That is, it\n            effectively disassociates the destination\n            identified with said entry from the route\n            identified with said entry.  It is an\n            implementation-specific matter as to whether the\n            agent removes an invalidated entry from the table.\n            Accordingly, management stations must be prepared\n            to receive tabular information from agents that\n            corresponds to entries not currently in use.\n            Proper interpretation of such entries requires\n            examination of the relevant ipRouteType object."
            },
            "ipRouteProto": {
              "type": "string",
              "description": "The routing mechanism via which this route was\n            learned.  Inclusion of values for gateway routing\n            protocols is not intended to imply that hosts\n            should support those protocols."
            },
            "ipRouteAge": {
              "type": "integer",
              "description": "The number of seconds since this route was last\n            updated or otherwise determined to be correct.\n            Note that no semantics of `too old' can be implied\n            except through knowledge of the routing protocol\n            by which the route was learned.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteMask": {
              "type": "string",
              "description": "Indicate the mask to be logical-ANDed with the\n            destination address before being compared to the\n            value in the ipRouteDest field.  For those systems\n            that do not support arbitrary subnet masks, an\n            agent constructs the value of the ipRouteMask by\n            determining whether the value of the correspondent\n            ipRouteDest field belong to a class-A, B, or C\n            network, and then using one of:\n            \n                 mask           network\n                 255.0.0.0      class-A\n                 255.255.0.0    class-B\n                 255.255.255.0  class-C\n            \n            If the value of the ipRouteDest is 0.0.0.0 (a\n            default route), then the mask value is also\n            0.0.0.0.  It should be noted that all IP routing\n            subsystems implicitly use this mechanism.",
              "format": "inet:ipv4-address"
            },
            "ipRouteMetric5": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the\n            routing-protocol specified in the route's\n            ipRouteProto value.  If this metric is not used,\n            its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipRouteInfo": {
              "type": "string",
              "description": "A reference to MIB definitions specific to the\n            particular routing protocol which is responsible\n            for this route, as determined by the value\n            specified in the route's ipRouteProto value.  If\n            this information is not present, its value should\n            be set to the OBJECT IDENTIFIER { 0 0 }, which is\n            a syntactically valid object identifier, and any\n            conformant implementation of ASN.1 and BER must be\n            able to generate and recognize this value.",
              "x-yang-type": "yang:object-identifier-128"
            }
          }
        }
      },
      "RFC1213-MIB_ipNetToMediaEntry": {
        "type": "array",
        "description": "Each entry contains one IpAddress to `physical'\n          address equivalence.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "ipNetToMediaIfIndex": {
              "type": "integer",
              "description": "The interface on which this entry's equivalence\n            is effective.  The interface identified by a\n            particular value of this index is the same\n            interface as identified by the same value of\n            ifIndex.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "ipNetToMediaPhysAddress": {
              "type": "string",
              "description": "The media-dependent `physical' address.",
              "x-yang-type": "RFC1213-MIB:PhysAddress"
            },
            "ipNetToMediaNetAddress": {
              "type": "string",
              "description": "The IpAddress corresponding to the media-\n            dependent `physical' address.",
              "format": "inet:ipv4-address"
            },
            "ipNetToMediaType": {
              "type": "string",
              "description": "The type of mapping.\n            \n            Setting this object to the value invalid(2) has\n            the effect of invalidating the corresponding entry\n            in the ipNetToMediaTable.  That is, it effectively\n            disassociates the interface identified with said\n            entry from the mapping identified with said entry.\n            It is an implementation-specific matter as to\n            whether the agent removes an invalidated entry\n            from the table.  Accordingly, management stations\n            must be prepared to receive tabular information\n            from agents that corresponds to entries not\n            currently in use.  Proper interpretation of such\n            entries requires examination of the relevant\n            ipNetToMediaType object."
            }
          }
        }
      },
      "RFC1213-MIB_tcpConnEntry": {
        "type": "array",
        "description": "Information about a particular current TCP\n          connection.  An object of this type is transient,\n          in that it ceases to exist when (or soon after)\n          the connection makes the transition to the CLOSED\n          state.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "tcpConnState": {
              "type": "string",
              "description": "The state of this TCP connection.\n            \n            The only value which may be set by a management\n            station is deleteTCB(12).  Accordingly, it is\n            appropriate for an agent to return a `badValue'\n            response if a management station attempts to set\n            this object to any other value.\n            \n            If a management station sets this object to the\n            value deleteTCB(12), then this has the effect of\n            deleting the TCB (as defined in RFC 793) of the\n            corresponding connection on the managed node,\n            resulting in immediate termination of the\n            connection.\n            \n            As an implementation-specific option, a RST\n            segment may be sent from the managed node to the\n            other TCP endpoint (note however that RST segments\n            are not sent reliably)."
            },
            "tcpConnLocalAddress": {
              "type": "string",
              "description": "The local IP address for this TCP connection.  In\n            the case of a connection in the listen state which\n            is willing to accept connections for any IP\n            interface associated with the node, the value\n            0.0.0.0 is used.",
              "format": "inet:ipv4-address"
            },
            "tcpConnLocalPort": {
              "type": "integer",
              "description": "The local port number for this TCP connection.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "tcpConnRemAddress": {
              "type": "string",
              "description": "The remote IP address for this TCP connection.",
              "format": "inet:ipv4-address"
            },
            "tcpConnRemPort": {
              "type": "integer",
              "description": "The remote port number for this TCP connection.",
              "minimum": -2147483648,
              "maximum": 2147483647
            }
          }
        }
      },
      "RFC1213-MIB_udpEntry": {
        "type": "array",
        "description": "Information about a particular current UDP\n          listener.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "udpLocalAddress": {
              "type": "string",
              "description": "The local IP address for this UDP listener.  In\n            the case of a UDP listener which is willing to\n            accept datagrams for any IP interface associated\n            with the node, the value 0.0.0.0 is used.",
              "format": "inet:ipv4-address"
            },
            "udpLocalPort": {
              "type": "integer",
              "description": "The local port number for this UDP listener.",
              "minimum": -2147483648,
              "maximum": 2147483647
            }
          }
        }
      },
      "RFC1213-MIB_egpNeighEntry": {
        "type": "array",
        "description": "Information about this entity's relationship with\n          a particular EGP neighbor.",
        "properties": {},
        "items": {
          "type": "object",
          "properties": {
            "egpNeighState": {
              "type": "string",
              "description": "The EGP state of the local system with respect to\n            this entry's EGP neighbor.  Each EGP state is\n            represented by a value that is one greater than\n            the numerical value associated with said state in\n            RFC 904."
            },
            "egpNeighAddr": {
              "type": "string",
              "description": "The IP address of this entry's EGP neighbor.",
              "format": "inet:ipv4-address"
            },
            "egpNeighAs": {
              "type": "integer",
              "description": "The autonomous system of this EGP peer.  Zero\n            should be specified if the autonomous system\n            number of the neighbor is not yet known.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "egpNeighInMsgs": {
              "type": "integer",
              "description": "The number of EGP messages received without error\n            from this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighInErrs": {
              "type": "integer",
              "description": "The number of EGP messages received from this EGP\n            peer that proved to be in error (e.g., bad EGP\n            checksum).",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighOutMsgs": {
              "type": "integer",
              "description": "The number of locally generated EGP messages to\n            this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighOutErrs": {
              "type": "integer",
              "description": "The number of locally generated EGP messages not\n            sent to this EGP peer due to resource limitations\n            within an EGP entity.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighInErrMsgs": {
              "type": "integer",
              "description": "The number of EGP-defined error messages received\n            from this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighOutErrMsgs": {
              "type": "integer",
              "description": "The number of EGP-defined error messages sent to\n            this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighStateUps": {
              "type": "integer",
              "description": "The number of EGP state transitions to the UP\n            state with this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighStateDowns": {
              "type": "integer",
              "description": "The number of EGP state transitions from the UP\n            state to any other state with this EGP peer.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "egpNeighIntervalHello": {
              "type": "integer",
              "description": "The interval between EGP Hello command\n            retransmissions (in hundredths of a second).  This\n            represents the t1 timer as defined in RFC 904.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "egpNeighIntervalPoll": {
              "type": "integer",
              "description": "The interval between EGP poll command\n            retransmissions (in hundredths of a second).  This\n            represents the t3 timer as defined in RFC 904.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "egpNeighMode": {
              "type": "string",
              "description": "The polling mode of this EGP entity, either\n            passive or active."
            },
            "egpNeighEventTrigger": {
              "type": "string",
              "description": "A control variable used to trigger operator-\n            initiated Start and Stop events.  When read, this\n            variable always returns the most recent value that\n            egpNeighEventTrigger was set to.  If it has not\n            been set since the last initialization of the\n            network management subsystem on the node, it\n            returns a value of `stop'.\n            \n            When set, this variable causes a Start or Stop\n            event on the specified neighbor, as specified on\n            pages 8-10 of RFC 904.  Briefly, a Start event\n            causes an Idle peer to begin neighbor acquisition\n            and a non-Idle peer to reinitiate neighbor\n            acquisition.  A stop event causes a non-Idle peer\n            to return to the Idle state until a Start event\n            occurs, either via egpNeighEventTrigger or\n            otherwise."
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "RFC1213-MIB",
      "description": "MIB operations for RFC1213-MIB"
    }
  ]
}