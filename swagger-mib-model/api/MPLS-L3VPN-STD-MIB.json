{
  "openapi": "3.0.0",
  "info": {
    "title": "MPLS-L3VPN-STD-MIB MIB API",
    "version": "1.0.0",
    "description": "This MIB contains managed object definitions for the\n    Layer-3 Multiprotocol Label Switching Virtual\n    Private Networks.\n    \n    Copyright (C) The Internet Society (2006).  This\n    version of this MIB module is part of RFC4382; see\n    the RFC itself for full legal notices.\n\n\u26a0\ufe0f **IMPORTANT - MIB DATA ACCESS**:\nThis YANG model exists for SMIv2-to-YANG translation purposes, but MIB data on IOS-XE devices is primarily accessed via **SNMP protocol**, not RESTCONF.\n\n**RESTCONF Limitation**: Many MIB paths may return 404 errors via RESTCONF `/data` endpoints because the device exposes MIB data through SNMP, not the YANG datastore.\n\n**Recommended Access Methods**:\n- Use SNMP (v2c/v3) to query MIB data directly\n- Use NETCONF `<get>` operations for devices supporting YANG-modeled MIB access\n- Check device capabilities: some newer IOS-XE versions may support limited RESTCONF access to specific MIBs\n\n**YANG Model Purpose**: These YANG models define the structure of SNMP MIBs in YANG format for tooling compatibility, but do not guarantee RESTCONF data availability.\n",
    "contact": {
      "name": "Cisco DevNet",
      "url": "https://developer.cisco.com"
    }
  },
  "servers": [
    {
      "url": "https://10.85.134.65/restconf",
      "description": "IOS-XE Device (C9300)"
    }
  ],
  "paths": {
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnScalars": {
      "get": {
        "summary": "Get mplsL3VpnScalars data",
        "description": "Retrieve mplsL3VpnScalars operational data from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "The number of VRFs that are configured on this node.",
                  "properties": {
                    "mplsL3VpnConfiguredVrfs": {
                      "type": "integer",
                      "description": "The number of VRFs that are configured on this node.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnActiveVrfs": {
                      "type": "integer",
                      "description": "The number of VRFs that are active on this node.\n          That is, those VRFs whose corresponding mplsL3VpnVrfOperStatus\n          object value is equal to operational (1).",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnConnectedInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to a VRF.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnNotificationEnable": {
                      "type": "boolean",
                      "description": "If this object is true, then it enables the\n          generation of all notifications defined in\n          this MIB.  This object's value should be\n          preserved across agent reboots."
                    },
                    "mplsL3VpnVrfConfMaxPossRts": {
                      "type": "integer",
                      "description": "Denotes maximum number of routes that the device\n          will allow all VRFs jointly to hold.  If this value is\n          set to 0, this indicates that the device is\n          unable to determine the absolute maximum.  In this\n          case, the configured maximum MAY not actually\n          be allowed by the device.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfRteMxThrshTime": {
                      "type": "integer",
                      "description": "Denotes the interval in seconds, at which the route max threshold\n          notification may be reissued after the maximum value has been\n          exceeded (or has been reached if mplsL3VpnVrfConfMaxRoutes and\n          mplsL3VpnVrfConfHighRteThresh are equal) and the initial\n          notification has been issued.  This value is intended to prevent\n          continuous generation of notifications by an agent in the event\n          that routes are continually added to a VRF after it has reached\n          its maximum value.  If this value is set to 0, the agent should\n          only issue a single notification at the time that the maximum\n          threshold has been reached, and should not issue any more\n          notifications until the value of routes has fallen below the\n          configured threshold value.  This is the recommended default\n          behavior.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnIllLblRcvThrsh": {
                      "type": "integer",
                      "description": "The number of illegally received labels above which\n          the mplsNumVrfSecIllglLblThrshExcd notification\n          is issued.  The persistence of this value mimics\n          that of the device's configuration.",
                      "minimum": 0,
                      "maximum": 4294967295
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnScalars": {
                    "mplsL3VpnConfiguredVrfs": 0,
                    "mplsL3VpnActiveVrfs": 0,
                    "mplsL3VpnConnectedInterfaces": 0,
                    "mplsL3VpnNotificationEnable": true,
                    "mplsL3VpnVrfConfMaxPossRts": 0,
                    "mplsL3VpnVrfConfRteMxThrshTime": 0,
                    "mplsL3VpnIllLblRcvThrsh": 0
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfTable": {
      "get": {
        "summary": "Get mplsL3VpnIfConfTable data",
        "description": "Retrieve mplsL3VpnIfConfTable operational data from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "This table specifies per-interface MPLS capability\n        and associated information.",
                  "properties": {
                    "mplsL3VpnIfConfEntry": {
                      "type": "array",
                      "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "mplsL3VpnVrfName": {
                            "type": "string",
                            "description": "mplsL3VpnVrfName",
                            "x-yang-type": "leafref"
                          },
                          "mplsL3VpnIfConfIndex": {
                            "type": "string",
                            "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                            "x-yang-type": "if-mib:InterfaceIndex"
                          },
                          "mplsL3VpnIfVpnClassification": {
                            "type": "string",
                            "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                          },
                          "mplsL3VpnIfVpnRouteDistProtocol": {
                            "type": "string",
                            "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                          },
                          "mplsL3VpnIfConfStorageType": {
                            "type": "string",
                            "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                            "x-yang-type": "snmpv2-tc:StorageType"
                          },
                          "mplsL3VpnIfConfRowStatus": {
                            "type": "string",
                            "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfTable": {
                    "mplsL3VpnIfConfEntry": [
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnIfConfIndex": "1",
                        "mplsL3VpnIfVpnClassification": "example-string",
                        "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                        "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                        "mplsL3VpnIfConfRowStatus": "up(1)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnIfConfIndex": "2",
                        "mplsL3VpnIfVpnClassification": "example-string",
                        "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                        "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                        "mplsL3VpnIfConfRowStatus": "up(1)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnIfConfIndex": "3",
                        "mplsL3VpnIfVpnClassification": "example-string",
                        "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                        "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                        "mplsL3VpnIfConfRowStatus": "up(1)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfTable/mplsL3VpnIfConfEntry": {
      "get": {
        "summary": "Get mplsL3VpnIfConfEntry list",
        "description": "Retrieve list of mplsL3VpnIfConfEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnIfConfIndex": {
                        "type": "string",
                        "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                        "x-yang-type": "if-mib:InterfaceIndex"
                      },
                      "mplsL3VpnIfVpnClassification": {
                        "type": "string",
                        "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                      },
                      "mplsL3VpnIfVpnRouteDistProtocol": {
                        "type": "string",
                        "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                      },
                      "mplsL3VpnIfConfStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      },
                      "mplsL3VpnIfConfRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnIfConfIndex": "example-string",
                      "mplsL3VpnIfVpnClassification": "example-string",
                      "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                      "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                      "mplsL3VpnIfConfRowStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfTable/mplsL3VpnIfConfEntry={mplsL3VpnVrfName mplsL3VpnIfConfIndex}": {
      "get": {
        "summary": "Get mplsL3VpnIfConfEntry entry",
        "description": "Retrieve specific mplsL3VpnIfConfEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnIfConfIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnIfConfIndex": {
                      "type": "string",
                      "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                      "x-yang-type": "if-mib:InterfaceIndex"
                    },
                    "mplsL3VpnIfVpnClassification": {
                      "type": "string",
                      "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                    },
                    "mplsL3VpnIfVpnRouteDistProtocol": {
                      "type": "string",
                      "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                    },
                    "mplsL3VpnIfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    },
                    "mplsL3VpnIfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnIfConfIndex": "example-string",
                    "mplsL3VpnIfVpnClassification": "example-string",
                    "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                    "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                    "mplsL3VpnIfConfRowStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfTable": {
      "get": {
        "summary": "Get mplsL3VpnVrfTable data",
        "description": "Retrieve mplsL3VpnVrfTable operational data from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "This table specifies per-interface MPLS L3VPN\n        VRF Table capability and associated information.\n        Entries in this table define VRF routing instances\n        associated with MPLS/VPN interfaces.  Note that\n        multiple interfaces can belong to the same VRF\n        instance.  The collection of all VRF instances\n        comprises an actual VPN.",
                  "properties": {
                    "mplsL3VpnVrfEntry": {
                      "type": "array",
                      "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "mplsL3VpnVrfName": {
                            "type": "string",
                            "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                            "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                          },
                          "mplsL3VpnVrfVpnId": {
                            "type": "string",
                            "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                            "x-yang-type": "vpn-tc:VPNIdOrZero"
                          },
                          "mplsL3VpnVrfDescription": {
                            "type": "string",
                            "description": "The human-readable description of this VRF.",
                            "x-yang-type": "snmp-framework:SnmpAdminString"
                          },
                          "mplsL3VpnVrfRD": {
                            "type": "string",
                            "description": "The route distinguisher for this VRF.",
                            "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                          },
                          "mplsL3VpnVrfCreationTime": {
                            "type": "string",
                            "description": "The time at which this VRF entry was created.",
                            "x-yang-type": "yang:timestamp"
                          },
                          "mplsL3VpnVrfOperStatus": {
                            "type": "string",
                            "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                          },
                          "mplsL3VpnVrfActiveInterfaces": {
                            "type": "integer",
                            "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfAssociatedInterfaces": {
                            "type": "integer",
                            "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfConfMidRteThresh": {
                            "type": "integer",
                            "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfConfHighRteThresh": {
                            "type": "integer",
                            "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfConfMaxRoutes": {
                            "type": "integer",
                            "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfConfLastChanged": {
                            "type": "string",
                            "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                            "x-yang-type": "yang:timestamp"
                          },
                          "mplsL3VpnVrfConfRowStatus": {
                            "type": "string",
                            "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          },
                          "mplsL3VpnVrfConfAdminStatus": {
                            "type": "string",
                            "description": "Indicates the desired operational status of this\n            VRF."
                          },
                          "mplsL3VpnVrfConfStorageType": {
                            "type": "string",
                            "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                            "x-yang-type": "snmpv2-tc:StorageType"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfTable": {
                    "mplsL3VpnVrfEntry": [
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfVpnId": "example-string",
                        "mplsL3VpnVrfDescription": "192.168.1.1",
                        "mplsL3VpnVrfRD": "example-string",
                        "mplsL3VpnVrfCreationTime": "example-string",
                        "mplsL3VpnVrfOperStatus": "up(1)",
                        "mplsL3VpnVrfActiveInterfaces": 0,
                        "mplsL3VpnVrfAssociatedInterfaces": 0,
                        "mplsL3VpnVrfConfMidRteThresh": 0,
                        "mplsL3VpnVrfConfHighRteThresh": 0,
                        "mplsL3VpnVrfConfMaxRoutes": 0,
                        "mplsL3VpnVrfConfLastChanged": "example-string",
                        "mplsL3VpnVrfConfRowStatus": "up(1)",
                        "mplsL3VpnVrfConfAdminStatus": "up(1)",
                        "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfVpnId": "example-string",
                        "mplsL3VpnVrfDescription": "192.168.1.1",
                        "mplsL3VpnVrfRD": "example-string",
                        "mplsL3VpnVrfCreationTime": "example-string",
                        "mplsL3VpnVrfOperStatus": "up(1)",
                        "mplsL3VpnVrfActiveInterfaces": 0,
                        "mplsL3VpnVrfAssociatedInterfaces": 0,
                        "mplsL3VpnVrfConfMidRteThresh": 0,
                        "mplsL3VpnVrfConfHighRteThresh": 0,
                        "mplsL3VpnVrfConfMaxRoutes": 0,
                        "mplsL3VpnVrfConfLastChanged": "example-string",
                        "mplsL3VpnVrfConfRowStatus": "up(1)",
                        "mplsL3VpnVrfConfAdminStatus": "up(1)",
                        "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfVpnId": "example-string",
                        "mplsL3VpnVrfDescription": "192.168.1.1",
                        "mplsL3VpnVrfRD": "example-string",
                        "mplsL3VpnVrfCreationTime": "example-string",
                        "mplsL3VpnVrfOperStatus": "up(1)",
                        "mplsL3VpnVrfActiveInterfaces": 0,
                        "mplsL3VpnVrfAssociatedInterfaces": 0,
                        "mplsL3VpnVrfConfMidRteThresh": 0,
                        "mplsL3VpnVrfConfHighRteThresh": 0,
                        "mplsL3VpnVrfConfMaxRoutes": 0,
                        "mplsL3VpnVrfConfLastChanged": "example-string",
                        "mplsL3VpnVrfConfRowStatus": "up(1)",
                        "mplsL3VpnVrfConfAdminStatus": "up(1)",
                        "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfTable/mplsL3VpnVrfEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfEntry list",
        "description": "Retrieve list of mplsL3VpnVrfEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                      },
                      "mplsL3VpnVrfVpnId": {
                        "type": "string",
                        "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                        "x-yang-type": "vpn-tc:VPNIdOrZero"
                      },
                      "mplsL3VpnVrfDescription": {
                        "type": "string",
                        "description": "The human-readable description of this VRF.",
                        "x-yang-type": "snmp-framework:SnmpAdminString"
                      },
                      "mplsL3VpnVrfRD": {
                        "type": "string",
                        "description": "The route distinguisher for this VRF.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                      },
                      "mplsL3VpnVrfCreationTime": {
                        "type": "string",
                        "description": "The time at which this VRF entry was created.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "mplsL3VpnVrfOperStatus": {
                        "type": "string",
                        "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                      },
                      "mplsL3VpnVrfActiveInterfaces": {
                        "type": "integer",
                        "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfAssociatedInterfaces": {
                        "type": "integer",
                        "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfMidRteThresh": {
                        "type": "integer",
                        "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfHighRteThresh": {
                        "type": "integer",
                        "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfMaxRoutes": {
                        "type": "integer",
                        "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfLastChanged": {
                        "type": "string",
                        "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "mplsL3VpnVrfConfRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "mplsL3VpnVrfConfAdminStatus": {
                        "type": "string",
                        "description": "Indicates the desired operational status of this\n            VRF."
                      },
                      "mplsL3VpnVrfConfStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfVpnId": "example-string",
                      "mplsL3VpnVrfDescription": "192.168.1.1",
                      "mplsL3VpnVrfRD": "example-string",
                      "mplsL3VpnVrfCreationTime": "example-string",
                      "mplsL3VpnVrfOperStatus": "up(1)",
                      "mplsL3VpnVrfActiveInterfaces": 0,
                      "mplsL3VpnVrfAssociatedInterfaces": 0,
                      "mplsL3VpnVrfConfMidRteThresh": 0,
                      "mplsL3VpnVrfConfHighRteThresh": 0,
                      "mplsL3VpnVrfConfMaxRoutes": 0,
                      "mplsL3VpnVrfConfLastChanged": "example-string",
                      "mplsL3VpnVrfConfRowStatus": "up(1)",
                      "mplsL3VpnVrfConfAdminStatus": "up(1)",
                      "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfTable/mplsL3VpnVrfEntry={mplsL3VpnVrfName}": {
      "get": {
        "summary": "Get mplsL3VpnVrfEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                    },
                    "mplsL3VpnVrfVpnId": {
                      "type": "string",
                      "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                      "x-yang-type": "vpn-tc:VPNIdOrZero"
                    },
                    "mplsL3VpnVrfDescription": {
                      "type": "string",
                      "description": "The human-readable description of this VRF.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRD": {
                      "type": "string",
                      "description": "The route distinguisher for this VRF.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfCreationTime": {
                      "type": "string",
                      "description": "The time at which this VRF entry was created.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfOperStatus": {
                      "type": "string",
                      "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                    },
                    "mplsL3VpnVrfActiveInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfAssociatedInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMidRteThresh": {
                      "type": "integer",
                      "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfHighRteThresh": {
                      "type": "integer",
                      "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMaxRoutes": {
                      "type": "integer",
                      "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfLastChanged": {
                      "type": "string",
                      "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfConfAdminStatus": {
                      "type": "string",
                      "description": "Indicates the desired operational status of this\n            VRF."
                    },
                    "mplsL3VpnVrfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfVpnId": "example-string",
                    "mplsL3VpnVrfDescription": "192.168.1.1",
                    "mplsL3VpnVrfRD": "example-string",
                    "mplsL3VpnVrfCreationTime": "example-string",
                    "mplsL3VpnVrfOperStatus": "up(1)",
                    "mplsL3VpnVrfActiveInterfaces": 0,
                    "mplsL3VpnVrfAssociatedInterfaces": 0,
                    "mplsL3VpnVrfConfMidRteThresh": 0,
                    "mplsL3VpnVrfConfHighRteThresh": 0,
                    "mplsL3VpnVrfConfMaxRoutes": 0,
                    "mplsL3VpnVrfConfLastChanged": "example-string",
                    "mplsL3VpnVrfConfRowStatus": "up(1)",
                    "mplsL3VpnVrfConfAdminStatus": "up(1)",
                    "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTTable": {
      "get": {
        "summary": "Get mplsL3VpnVrfRTTable data",
        "description": "Retrieve mplsL3VpnVrfRTTable operational data from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "This table specifies per-VRF route target association.\n        Each entry identifies a connectivity policy supported\n        as part of a VPN.",
                  "properties": {
                    "mplsL3VpnVrfRTEntry": {
                      "type": "array",
                      "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "mplsL3VpnVrfName": {
                            "type": "string",
                            "description": "mplsL3VpnVrfName",
                            "x-yang-type": "leafref"
                          },
                          "mplsL3VpnVrfRTIndex": {
                            "type": "integer",
                            "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfRTType": {
                            "type": "string",
                            "description": "The route target distribution type.",
                            "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                          },
                          "mplsL3VpnVrfRT": {
                            "type": "string",
                            "description": "The route target distribution policy.",
                            "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                          },
                          "mplsL3VpnVrfRTDescr": {
                            "type": "string",
                            "description": "Description of the route target.",
                            "x-yang-type": "snmp-framework:SnmpAdminString"
                          },
                          "mplsL3VpnVrfRTRowStatus": {
                            "type": "string",
                            "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          },
                          "mplsL3VpnVrfRTStorageType": {
                            "type": "string",
                            "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                            "x-yang-type": "snmpv2-tc:StorageType"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTTable": {
                    "mplsL3VpnVrfRTEntry": [
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRTIndex": 1,
                        "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRT": "example-string",
                        "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                        "mplsL3VpnVrfRTRowStatus": "up(1)",
                        "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRTIndex": 2,
                        "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRT": "example-string",
                        "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                        "mplsL3VpnVrfRTRowStatus": "up(1)",
                        "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRTIndex": 3,
                        "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRT": "example-string",
                        "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                        "mplsL3VpnVrfRTRowStatus": "up(1)",
                        "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTTable/mplsL3VpnVrfRTEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfRTEntry list",
        "description": "Retrieve list of mplsL3VpnVrfRTEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnVrfRTIndex": {
                        "type": "integer",
                        "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfRTType": {
                        "type": "string",
                        "description": "The route target distribution type.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                      },
                      "mplsL3VpnVrfRT": {
                        "type": "string",
                        "description": "The route target distribution policy.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                      },
                      "mplsL3VpnVrfRTDescr": {
                        "type": "string",
                        "description": "Description of the route target.",
                        "x-yang-type": "snmp-framework:SnmpAdminString"
                      },
                      "mplsL3VpnVrfRTRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "mplsL3VpnVrfRTStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfRTIndex": 1,
                      "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRT": "example-string",
                      "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                      "mplsL3VpnVrfRTRowStatus": "up(1)",
                      "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTTable/mplsL3VpnVrfRTEntry={mplsL3VpnVrfName mplsL3VpnVrfRTIndex mplsL3VpnVrfRTType}": {
      "get": {
        "summary": "Get mplsL3VpnVrfRTEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfRTEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnVrfRTIndex mplsL3VpnVrfRTType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRTIndex": {
                      "type": "integer",
                      "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRTType": {
                      "type": "string",
                      "description": "The route target distribution type.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                    },
                    "mplsL3VpnVrfRT": {
                      "type": "string",
                      "description": "The route target distribution policy.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfRTDescr": {
                      "type": "string",
                      "description": "Description of the route target.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRTRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfRTStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfRTIndex": 1,
                    "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRT": "example-string",
                    "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                    "mplsL3VpnVrfRTRowStatus": "up(1)",
                    "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteTable": {
      "get": {
        "summary": "Get mplsL3VpnVrfRteTable data",
        "description": "Retrieve mplsL3VpnVrfRteTable operational data from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "description": "This table specifies per-interface MPLS L3VPN VRF Table\n        routing information.  Entries in this table define VRF routing\n        entries associated with the specified MPLS/VPN interfaces.  Note\n        \n        that this table contains both BGP and Interior Gateway Protocol\n        IGP routes, as both may appear in the same VRF.",
                  "properties": {
                    "mplsL3VpnVrfRteEntry": {
                      "type": "array",
                      "description": "mplsL3VpnVrfRteEntry",
                      "items": {
                        "type": "object",
                        "properties": {
                          "mplsL3VpnVrfName": {
                            "type": "string",
                            "description": "mplsL3VpnVrfName",
                            "x-yang-type": "leafref"
                          },
                          "mplsL3VpnVrfRteInetCidrDestType": {
                            "type": "string",
                            "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                            "x-yang-type": "inet-address:InetAddressType"
                          },
                          "mplsL3VpnVrfRteInetCidrDest": {
                            "type": "string",
                            "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "mplsL3VpnVrfRteInetCidrPfxLen": {
                            "type": "string",
                            "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                            "x-yang-type": "inet-address:InetAddressPrefixLength"
                          },
                          "mplsL3VpnVrfRteInetCidrPolicy": {
                            "type": "string",
                            "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                            "x-yang-type": "yang:object-identifier-128"
                          },
                          "mplsL3VpnVrfRteInetCidrNHopType": {
                            "type": "string",
                            "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                            "x-yang-type": "inet-address:InetAddressType"
                          },
                          "mplsL3VpnVrfRteInetCidrNextHop": {
                            "type": "string",
                            "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                            "x-yang-type": "inet-address:InetAddress"
                          },
                          "mplsL3VpnVrfRteInetCidrIfIndex": {
                            "type": "string",
                            "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                            "x-yang-type": "if-mib:InterfaceIndexOrZero"
                          },
                          "mplsL3VpnVrfRteInetCidrType": {
                            "type": "string",
                            "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                          },
                          "mplsL3VpnVrfRteInetCidrProto": {
                            "type": "string",
                            "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                            "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                          },
                          "mplsL3VpnVrfRteInetCidrAge": {
                            "type": "integer",
                            "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                            "minimum": 0,
                            "maximum": 4294967295
                          },
                          "mplsL3VpnVrfRteInetCidrNextHopAS": {
                            "type": "string",
                            "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                            "format": "inet:as-number"
                          },
                          "mplsL3VpnVrfRteInetCidrMetric1": {
                            "type": "integer",
                            "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "mplsL3VpnVrfRteInetCidrMetric2": {
                            "type": "integer",
                            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "mplsL3VpnVrfRteInetCidrMetric3": {
                            "type": "integer",
                            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "mplsL3VpnVrfRteInetCidrMetric4": {
                            "type": "integer",
                            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "mplsL3VpnVrfRteInetCidrMetric5": {
                            "type": "integer",
                            "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                            "minimum": -2147483648,
                            "maximum": 2147483647
                          },
                          "mplsL3VpnVrfRteXCPointer": {
                            "type": "string",
                            "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                            "x-yang-type": "mpls-lsr:MplsIndexType"
                          },
                          "mplsL3VpnVrfRteInetCidrStatus": {
                            "type": "string",
                            "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                            "x-yang-type": "snmpv2-tc:RowStatus"
                          }
                        }
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteTable": {
                    "mplsL3VpnVrfRteEntry": [
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrDest": "example-string",
                        "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                        "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                        "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                        "mplsL3VpnVrfRteInetCidrIfIndex": "1",
                        "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrProto": "example-string",
                        "mplsL3VpnVrfRteInetCidrAge": 0,
                        "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                        "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                        "mplsL3VpnVrfRteXCPointer": "example-string",
                        "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrDest": "example-string",
                        "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                        "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                        "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                        "mplsL3VpnVrfRteInetCidrIfIndex": "2",
                        "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrProto": "example-string",
                        "mplsL3VpnVrfRteInetCidrAge": 0,
                        "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                        "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                        "mplsL3VpnVrfRteXCPointer": "example-string",
                        "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                      },
                      {
                        "mplsL3VpnVrfName": "interface-1",
                        "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrDest": "example-string",
                        "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                        "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                        "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                        "mplsL3VpnVrfRteInetCidrIfIndex": "3",
                        "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                        "mplsL3VpnVrfRteInetCidrProto": "example-string",
                        "mplsL3VpnVrfRteInetCidrAge": 0,
                        "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                        "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                        "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                        "mplsL3VpnVrfRteXCPointer": "example-string",
                        "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                      }
                    ]
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteTable/mplsL3VpnVrfRteEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfRteEntry list",
        "description": "Retrieve list of mplsL3VpnVrfRteEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "mplsL3VpnVrfRteEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnVrfRteInetCidrDestType": {
                        "type": "string",
                        "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "mplsL3VpnVrfRteInetCidrDest": {
                        "type": "string",
                        "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "mplsL3VpnVrfRteInetCidrPfxLen": {
                        "type": "string",
                        "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                        "x-yang-type": "inet-address:InetAddressPrefixLength"
                      },
                      "mplsL3VpnVrfRteInetCidrPolicy": {
                        "type": "string",
                        "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "mplsL3VpnVrfRteInetCidrNHopType": {
                        "type": "string",
                        "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "mplsL3VpnVrfRteInetCidrNextHop": {
                        "type": "string",
                        "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "mplsL3VpnVrfRteInetCidrIfIndex": {
                        "type": "string",
                        "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "mplsL3VpnVrfRteInetCidrType": {
                        "type": "string",
                        "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                      },
                      "mplsL3VpnVrfRteInetCidrProto": {
                        "type": "string",
                        "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                        "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                      },
                      "mplsL3VpnVrfRteInetCidrAge": {
                        "type": "integer",
                        "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfRteInetCidrNextHopAS": {
                        "type": "string",
                        "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                        "format": "inet:as-number"
                      },
                      "mplsL3VpnVrfRteInetCidrMetric1": {
                        "type": "integer",
                        "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric2": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric3": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric4": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric5": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteXCPointer": {
                        "type": "string",
                        "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                        "x-yang-type": "mpls-lsr:MplsIndexType"
                      },
                      "mplsL3VpnVrfRteInetCidrStatus": {
                        "type": "string",
                        "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrDest": "example-string",
                      "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                      "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                      "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                      "mplsL3VpnVrfRteInetCidrIfIndex": "example-string",
                      "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrProto": "example-string",
                      "mplsL3VpnVrfRteInetCidrAge": 0,
                      "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                      "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                      "mplsL3VpnVrfRteXCPointer": "example-string",
                      "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteTable/mplsL3VpnVrfRteEntry={mplsL3VpnVrfName mplsL3VpnVrfRteInetCidrDestType mplsL3VpnVrfRteInetCidrDest mplsL3VpnVrfRteInetCidrPfxLen mplsL3VpnVrfRteInetCidrPolicy mplsL3VpnVrfRteInetCidrNHopType mplsL3VpnVrfRteInetCidrNextHop}": {
      "get": {
        "summary": "Get mplsL3VpnVrfRteEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfRteEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnVrfRteInetCidrDestType mplsL3VpnVrfRteInetCidrDest mplsL3VpnVrfRteInetCidrPfxLen mplsL3VpnVrfRteInetCidrPolicy mplsL3VpnVrfRteInetCidrNHopType mplsL3VpnVrfRteInetCidrNextHop",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRteInetCidrDestType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrDest": {
                      "type": "string",
                      "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrPfxLen": {
                      "type": "string",
                      "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddressPrefixLength"
                    },
                    "mplsL3VpnVrfRteInetCidrPolicy": {
                      "type": "string",
                      "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "mplsL3VpnVrfRteInetCidrNHopType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrNextHop": {
                      "type": "string",
                      "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrIfIndex": {
                      "type": "string",
                      "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "mplsL3VpnVrfRteInetCidrType": {
                      "type": "string",
                      "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                    },
                    "mplsL3VpnVrfRteInetCidrProto": {
                      "type": "string",
                      "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                      "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                    },
                    "mplsL3VpnVrfRteInetCidrAge": {
                      "type": "integer",
                      "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRteInetCidrNextHopAS": {
                      "type": "string",
                      "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                      "format": "inet:as-number"
                    },
                    "mplsL3VpnVrfRteInetCidrMetric1": {
                      "type": "integer",
                      "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric2": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric3": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric4": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric5": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteXCPointer": {
                      "type": "string",
                      "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                      "x-yang-type": "mpls-lsr:MplsIndexType"
                    },
                    "mplsL3VpnVrfRteInetCidrStatus": {
                      "type": "string",
                      "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrDest": "example-string",
                    "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                    "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                    "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                    "mplsL3VpnVrfRteInetCidrIfIndex": "example-string",
                    "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrProto": "example-string",
                    "mplsL3VpnVrfRteInetCidrAge": 0,
                    "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                    "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                    "mplsL3VpnVrfRteXCPointer": "example-string",
                    "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry": {
      "get": {
        "summary": "Get mplsL3VpnIfConfEntry list",
        "description": "Retrieve list of mplsL3VpnIfConfEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnIfConfIndex": {
                        "type": "string",
                        "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                        "x-yang-type": "if-mib:InterfaceIndex"
                      },
                      "mplsL3VpnIfVpnClassification": {
                        "type": "string",
                        "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                      },
                      "mplsL3VpnIfVpnRouteDistProtocol": {
                        "type": "string",
                        "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                      },
                      "mplsL3VpnIfConfStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      },
                      "mplsL3VpnIfConfRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnIfConfIndex": "example-string",
                      "mplsL3VpnIfVpnClassification": "example-string",
                      "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                      "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                      "mplsL3VpnIfConfRowStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry={mplsL3VpnVrfName mplsL3VpnIfConfIndex}": {
      "get": {
        "summary": "Get mplsL3VpnIfConfEntry entry",
        "description": "Retrieve specific mplsL3VpnIfConfEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnIfConfIndex",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnIfConfIndex": {
                      "type": "string",
                      "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                      "x-yang-type": "if-mib:InterfaceIndex"
                    },
                    "mplsL3VpnIfVpnClassification": {
                      "type": "string",
                      "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                    },
                    "mplsL3VpnIfVpnRouteDistProtocol": {
                      "type": "string",
                      "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                    },
                    "mplsL3VpnIfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    },
                    "mplsL3VpnIfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnIfConfEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnIfConfIndex": "example-string",
                    "mplsL3VpnIfVpnClassification": "example-string",
                    "mplsL3VpnIfVpnRouteDistProtocol": "example-string",
                    "mplsL3VpnIfConfStorageType": "ethernetCsmacd(6)",
                    "mplsL3VpnIfConfRowStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfEntry list",
        "description": "Retrieve list of mplsL3VpnVrfEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                      },
                      "mplsL3VpnVrfVpnId": {
                        "type": "string",
                        "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                        "x-yang-type": "vpn-tc:VPNIdOrZero"
                      },
                      "mplsL3VpnVrfDescription": {
                        "type": "string",
                        "description": "The human-readable description of this VRF.",
                        "x-yang-type": "snmp-framework:SnmpAdminString"
                      },
                      "mplsL3VpnVrfRD": {
                        "type": "string",
                        "description": "The route distinguisher for this VRF.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                      },
                      "mplsL3VpnVrfCreationTime": {
                        "type": "string",
                        "description": "The time at which this VRF entry was created.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "mplsL3VpnVrfOperStatus": {
                        "type": "string",
                        "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                      },
                      "mplsL3VpnVrfActiveInterfaces": {
                        "type": "integer",
                        "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfAssociatedInterfaces": {
                        "type": "integer",
                        "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfMidRteThresh": {
                        "type": "integer",
                        "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfHighRteThresh": {
                        "type": "integer",
                        "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfMaxRoutes": {
                        "type": "integer",
                        "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfConfLastChanged": {
                        "type": "string",
                        "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                        "x-yang-type": "yang:timestamp"
                      },
                      "mplsL3VpnVrfConfRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "mplsL3VpnVrfConfAdminStatus": {
                        "type": "string",
                        "description": "Indicates the desired operational status of this\n            VRF."
                      },
                      "mplsL3VpnVrfConfStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfVpnId": "example-string",
                      "mplsL3VpnVrfDescription": "192.168.1.1",
                      "mplsL3VpnVrfRD": "example-string",
                      "mplsL3VpnVrfCreationTime": "example-string",
                      "mplsL3VpnVrfOperStatus": "up(1)",
                      "mplsL3VpnVrfActiveInterfaces": 0,
                      "mplsL3VpnVrfAssociatedInterfaces": 0,
                      "mplsL3VpnVrfConfMidRteThresh": 0,
                      "mplsL3VpnVrfConfHighRteThresh": 0,
                      "mplsL3VpnVrfConfMaxRoutes": 0,
                      "mplsL3VpnVrfConfLastChanged": "example-string",
                      "mplsL3VpnVrfConfRowStatus": "up(1)",
                      "mplsL3VpnVrfConfAdminStatus": "up(1)",
                      "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry={mplsL3VpnVrfName}": {
      "get": {
        "summary": "Get mplsL3VpnVrfEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                    },
                    "mplsL3VpnVrfVpnId": {
                      "type": "string",
                      "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                      "x-yang-type": "vpn-tc:VPNIdOrZero"
                    },
                    "mplsL3VpnVrfDescription": {
                      "type": "string",
                      "description": "The human-readable description of this VRF.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRD": {
                      "type": "string",
                      "description": "The route distinguisher for this VRF.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfCreationTime": {
                      "type": "string",
                      "description": "The time at which this VRF entry was created.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfOperStatus": {
                      "type": "string",
                      "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                    },
                    "mplsL3VpnVrfActiveInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfAssociatedInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMidRteThresh": {
                      "type": "integer",
                      "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfHighRteThresh": {
                      "type": "integer",
                      "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMaxRoutes": {
                      "type": "integer",
                      "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfLastChanged": {
                      "type": "string",
                      "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfConfAdminStatus": {
                      "type": "string",
                      "description": "Indicates the desired operational status of this\n            VRF."
                    },
                    "mplsL3VpnVrfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfVpnId": "example-string",
                    "mplsL3VpnVrfDescription": "192.168.1.1",
                    "mplsL3VpnVrfRD": "example-string",
                    "mplsL3VpnVrfCreationTime": "example-string",
                    "mplsL3VpnVrfOperStatus": "up(1)",
                    "mplsL3VpnVrfActiveInterfaces": 0,
                    "mplsL3VpnVrfAssociatedInterfaces": 0,
                    "mplsL3VpnVrfConfMidRteThresh": 0,
                    "mplsL3VpnVrfConfHighRteThresh": 0,
                    "mplsL3VpnVrfConfMaxRoutes": 0,
                    "mplsL3VpnVrfConfLastChanged": "example-string",
                    "mplsL3VpnVrfConfRowStatus": "up(1)",
                    "mplsL3VpnVrfConfAdminStatus": "up(1)",
                    "mplsL3VpnVrfConfStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfRTEntry list",
        "description": "Retrieve list of mplsL3VpnVrfRTEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnVrfRTIndex": {
                        "type": "integer",
                        "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfRTType": {
                        "type": "string",
                        "description": "The route target distribution type.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                      },
                      "mplsL3VpnVrfRT": {
                        "type": "string",
                        "description": "The route target distribution policy.",
                        "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                      },
                      "mplsL3VpnVrfRTDescr": {
                        "type": "string",
                        "description": "Description of the route target.",
                        "x-yang-type": "snmp-framework:SnmpAdminString"
                      },
                      "mplsL3VpnVrfRTRowStatus": {
                        "type": "string",
                        "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      },
                      "mplsL3VpnVrfRTStorageType": {
                        "type": "string",
                        "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                        "x-yang-type": "snmpv2-tc:StorageType"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfRTIndex": 1,
                      "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRT": "example-string",
                      "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                      "mplsL3VpnVrfRTRowStatus": "up(1)",
                      "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry={mplsL3VpnVrfName mplsL3VpnVrfRTIndex mplsL3VpnVrfRTType}": {
      "get": {
        "summary": "Get mplsL3VpnVrfRTEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfRTEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnVrfRTIndex mplsL3VpnVrfRTType",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRTIndex": {
                      "type": "integer",
                      "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRTType": {
                      "type": "string",
                      "description": "The route target distribution type.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                    },
                    "mplsL3VpnVrfRT": {
                      "type": "string",
                      "description": "The route target distribution policy.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfRTDescr": {
                      "type": "string",
                      "description": "Description of the route target.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRTRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfRTStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRTEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfRTIndex": 1,
                    "mplsL3VpnVrfRTType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRT": "example-string",
                    "mplsL3VpnVrfRTDescr": "GigabitEthernet1/0/1",
                    "mplsL3VpnVrfRTRowStatus": "up(1)",
                    "mplsL3VpnVrfRTStorageType": "ethernetCsmacd(6)"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry": {
      "get": {
        "summary": "Get mplsL3VpnVrfRteEntry list",
        "description": "Retrieve list of mplsL3VpnVrfRteEntry entries from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "array",
                  "description": "mplsL3VpnVrfRteEntry",
                  "items": {
                    "type": "object",
                    "properties": {
                      "mplsL3VpnVrfName": {
                        "type": "string",
                        "description": "mplsL3VpnVrfName",
                        "x-yang-type": "leafref"
                      },
                      "mplsL3VpnVrfRteInetCidrDestType": {
                        "type": "string",
                        "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "mplsL3VpnVrfRteInetCidrDest": {
                        "type": "string",
                        "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "mplsL3VpnVrfRteInetCidrPfxLen": {
                        "type": "string",
                        "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                        "x-yang-type": "inet-address:InetAddressPrefixLength"
                      },
                      "mplsL3VpnVrfRteInetCidrPolicy": {
                        "type": "string",
                        "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                        "x-yang-type": "yang:object-identifier-128"
                      },
                      "mplsL3VpnVrfRteInetCidrNHopType": {
                        "type": "string",
                        "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                        "x-yang-type": "inet-address:InetAddressType"
                      },
                      "mplsL3VpnVrfRteInetCidrNextHop": {
                        "type": "string",
                        "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                        "x-yang-type": "inet-address:InetAddress"
                      },
                      "mplsL3VpnVrfRteInetCidrIfIndex": {
                        "type": "string",
                        "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                        "x-yang-type": "if-mib:InterfaceIndexOrZero"
                      },
                      "mplsL3VpnVrfRteInetCidrType": {
                        "type": "string",
                        "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                      },
                      "mplsL3VpnVrfRteInetCidrProto": {
                        "type": "string",
                        "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                        "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                      },
                      "mplsL3VpnVrfRteInetCidrAge": {
                        "type": "integer",
                        "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                        "minimum": 0,
                        "maximum": 4294967295
                      },
                      "mplsL3VpnVrfRteInetCidrNextHopAS": {
                        "type": "string",
                        "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                        "format": "inet:as-number"
                      },
                      "mplsL3VpnVrfRteInetCidrMetric1": {
                        "type": "integer",
                        "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric2": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric3": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric4": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteInetCidrMetric5": {
                        "type": "integer",
                        "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                        "minimum": -2147483648,
                        "maximum": 2147483647
                      },
                      "mplsL3VpnVrfRteXCPointer": {
                        "type": "string",
                        "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                        "x-yang-type": "mpls-lsr:MplsIndexType"
                      },
                      "mplsL3VpnVrfRteInetCidrStatus": {
                        "type": "string",
                        "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                        "x-yang-type": "snmpv2-tc:RowStatus"
                      }
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry": [
                    {
                      "mplsL3VpnVrfName": "interface-1",
                      "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrDest": "example-string",
                      "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                      "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                      "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                      "mplsL3VpnVrfRteInetCidrIfIndex": "example-string",
                      "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                      "mplsL3VpnVrfRteInetCidrProto": "example-string",
                      "mplsL3VpnVrfRteInetCidrAge": 0,
                      "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                      "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                      "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                      "mplsL3VpnVrfRteXCPointer": "example-string",
                      "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                    }
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/data/MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry={mplsL3VpnVrfName mplsL3VpnVrfRteInetCidrDestType mplsL3VpnVrfRteInetCidrDest mplsL3VpnVrfRteInetCidrPfxLen mplsL3VpnVrfRteInetCidrPolicy mplsL3VpnVrfRteInetCidrNHopType mplsL3VpnVrfRteInetCidrNextHop}": {
      "get": {
        "summary": "Get mplsL3VpnVrfRteEntry entry",
        "description": "Retrieve specific mplsL3VpnVrfRteEntry entry by key from MIB",
        "tags": [
          "MPLS-L3VPN-STD-MIB"
        ],
        "parameters": [
          {
            "name": "mplsL3VpnVrfName mplsL3VpnVrfRteInetCidrDestType mplsL3VpnVrfRteInetCidrDest mplsL3VpnVrfRteInetCidrPfxLen mplsL3VpnVrfRteInetCidrPolicy mplsL3VpnVrfRteInetCidrNHopType mplsL3VpnVrfRteInetCidrNextHop",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            },
            "example": "1"
          }
        ],
        "responses": {
          "200": {
            "description": "Success",
            "content": {
              "application/yang-data+json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRteInetCidrDestType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrDest": {
                      "type": "string",
                      "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrPfxLen": {
                      "type": "string",
                      "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddressPrefixLength"
                    },
                    "mplsL3VpnVrfRteInetCidrPolicy": {
                      "type": "string",
                      "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "mplsL3VpnVrfRteInetCidrNHopType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrNextHop": {
                      "type": "string",
                      "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrIfIndex": {
                      "type": "string",
                      "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "mplsL3VpnVrfRteInetCidrType": {
                      "type": "string",
                      "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                    },
                    "mplsL3VpnVrfRteInetCidrProto": {
                      "type": "string",
                      "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                      "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                    },
                    "mplsL3VpnVrfRteInetCidrAge": {
                      "type": "integer",
                      "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRteInetCidrNextHopAS": {
                      "type": "string",
                      "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                      "format": "inet:as-number"
                    },
                    "mplsL3VpnVrfRteInetCidrMetric1": {
                      "type": "integer",
                      "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric2": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric3": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric4": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric5": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteXCPointer": {
                      "type": "string",
                      "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                      "x-yang-type": "mpls-lsr:MplsIndexType"
                    },
                    "mplsL3VpnVrfRteInetCidrStatus": {
                      "type": "string",
                      "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                },
                "example": {
                  "MPLS-L3VPN-STD-MIB:mplsL3VpnVrfRteEntry": {
                    "mplsL3VpnVrfName": "interface-1",
                    "mplsL3VpnVrfRteInetCidrDestType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrDest": "example-string",
                    "mplsL3VpnVrfRteInetCidrPfxLen": "example-string",
                    "mplsL3VpnVrfRteInetCidrPolicy": "example-string",
                    "mplsL3VpnVrfRteInetCidrNHopType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrNextHop": "example-string",
                    "mplsL3VpnVrfRteInetCidrIfIndex": "example-string",
                    "mplsL3VpnVrfRteInetCidrType": "ethernetCsmacd(6)",
                    "mplsL3VpnVrfRteInetCidrProto": "example-string",
                    "mplsL3VpnVrfRteInetCidrAge": 0,
                    "mplsL3VpnVrfRteInetCidrNextHopAS": "example-string",
                    "mplsL3VpnVrfRteInetCidrMetric1": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric2": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric3": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric4": -2147483648,
                    "mplsL3VpnVrfRteInetCidrMetric5": -2147483648,
                    "mplsL3VpnVrfRteXCPointer": "example-string",
                    "mplsL3VpnVrfRteInetCidrStatus": "up(1)"
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "MPLS-L3VPN-STD-MIB_MPLS-L3VPN-STD-MIB": {
        "type": "object",
        "description": "The number of VRFs that are configured on this node.",
        "properties": {
          "mplsL3VpnIfConfEntry": {
            "type": "array",
            "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
            "items": {
              "type": "object",
              "properties": {
                "mplsL3VpnVrfName": {
                  "type": "string",
                  "description": "mplsL3VpnVrfName",
                  "x-yang-type": "leafref"
                },
                "mplsL3VpnIfConfIndex": {
                  "type": "string",
                  "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                  "x-yang-type": "if-mib:InterfaceIndex"
                },
                "mplsL3VpnIfVpnClassification": {
                  "type": "string",
                  "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                },
                "mplsL3VpnIfVpnRouteDistProtocol": {
                  "type": "string",
                  "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                },
                "mplsL3VpnIfConfStorageType": {
                  "type": "string",
                  "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                  "x-yang-type": "snmpv2-tc:StorageType"
                },
                "mplsL3VpnIfConfRowStatus": {
                  "type": "string",
                  "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                }
              }
            }
          },
          "mplsL3VpnVrfEntry": {
            "type": "array",
            "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
            "items": {
              "type": "object",
              "properties": {
                "mplsL3VpnVrfName": {
                  "type": "string",
                  "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                  "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                },
                "mplsL3VpnVrfVpnId": {
                  "type": "string",
                  "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                  "x-yang-type": "vpn-tc:VPNIdOrZero"
                },
                "mplsL3VpnVrfDescription": {
                  "type": "string",
                  "description": "The human-readable description of this VRF.",
                  "x-yang-type": "snmp-framework:SnmpAdminString"
                },
                "mplsL3VpnVrfRD": {
                  "type": "string",
                  "description": "The route distinguisher for this VRF.",
                  "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                },
                "mplsL3VpnVrfCreationTime": {
                  "type": "string",
                  "description": "The time at which this VRF entry was created.",
                  "x-yang-type": "yang:timestamp"
                },
                "mplsL3VpnVrfOperStatus": {
                  "type": "string",
                  "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                },
                "mplsL3VpnVrfActiveInterfaces": {
                  "type": "integer",
                  "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfAssociatedInterfaces": {
                  "type": "integer",
                  "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfConfMidRteThresh": {
                  "type": "integer",
                  "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfConfHighRteThresh": {
                  "type": "integer",
                  "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfConfMaxRoutes": {
                  "type": "integer",
                  "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfConfLastChanged": {
                  "type": "string",
                  "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                  "x-yang-type": "yang:timestamp"
                },
                "mplsL3VpnVrfConfRowStatus": {
                  "type": "string",
                  "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                },
                "mplsL3VpnVrfConfAdminStatus": {
                  "type": "string",
                  "description": "Indicates the desired operational status of this\n            VRF."
                },
                "mplsL3VpnVrfConfStorageType": {
                  "type": "string",
                  "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                  "x-yang-type": "snmpv2-tc:StorageType"
                }
              }
            }
          },
          "mplsL3VpnVrfRTEntry": {
            "type": "array",
            "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
            "items": {
              "type": "object",
              "properties": {
                "mplsL3VpnVrfName": {
                  "type": "string",
                  "description": "mplsL3VpnVrfName",
                  "x-yang-type": "leafref"
                },
                "mplsL3VpnVrfRTIndex": {
                  "type": "integer",
                  "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfRTType": {
                  "type": "string",
                  "description": "The route target distribution type.",
                  "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                },
                "mplsL3VpnVrfRT": {
                  "type": "string",
                  "description": "The route target distribution policy.",
                  "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                },
                "mplsL3VpnVrfRTDescr": {
                  "type": "string",
                  "description": "Description of the route target.",
                  "x-yang-type": "snmp-framework:SnmpAdminString"
                },
                "mplsL3VpnVrfRTRowStatus": {
                  "type": "string",
                  "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                },
                "mplsL3VpnVrfRTStorageType": {
                  "type": "string",
                  "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                  "x-yang-type": "snmpv2-tc:StorageType"
                }
              }
            }
          },
          "mplsL3VpnVrfRteEntry": {
            "type": "array",
            "description": "mplsL3VpnVrfRteEntry",
            "items": {
              "type": "object",
              "properties": {
                "mplsL3VpnVrfName": {
                  "type": "string",
                  "description": "mplsL3VpnVrfName",
                  "x-yang-type": "leafref"
                },
                "mplsL3VpnVrfRteInetCidrDestType": {
                  "type": "string",
                  "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                  "x-yang-type": "inet-address:InetAddressType"
                },
                "mplsL3VpnVrfRteInetCidrDest": {
                  "type": "string",
                  "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "mplsL3VpnVrfRteInetCidrPfxLen": {
                  "type": "string",
                  "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                  "x-yang-type": "inet-address:InetAddressPrefixLength"
                },
                "mplsL3VpnVrfRteInetCidrPolicy": {
                  "type": "string",
                  "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                  "x-yang-type": "yang:object-identifier-128"
                },
                "mplsL3VpnVrfRteInetCidrNHopType": {
                  "type": "string",
                  "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                  "x-yang-type": "inet-address:InetAddressType"
                },
                "mplsL3VpnVrfRteInetCidrNextHop": {
                  "type": "string",
                  "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                  "x-yang-type": "inet-address:InetAddress"
                },
                "mplsL3VpnVrfRteInetCidrIfIndex": {
                  "type": "string",
                  "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                  "x-yang-type": "if-mib:InterfaceIndexOrZero"
                },
                "mplsL3VpnVrfRteInetCidrType": {
                  "type": "string",
                  "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                },
                "mplsL3VpnVrfRteInetCidrProto": {
                  "type": "string",
                  "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                  "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                },
                "mplsL3VpnVrfRteInetCidrAge": {
                  "type": "integer",
                  "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                  "minimum": 0,
                  "maximum": 4294967295
                },
                "mplsL3VpnVrfRteInetCidrNextHopAS": {
                  "type": "string",
                  "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                  "format": "inet:as-number"
                },
                "mplsL3VpnVrfRteInetCidrMetric1": {
                  "type": "integer",
                  "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "mplsL3VpnVrfRteInetCidrMetric2": {
                  "type": "integer",
                  "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "mplsL3VpnVrfRteInetCidrMetric3": {
                  "type": "integer",
                  "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "mplsL3VpnVrfRteInetCidrMetric4": {
                  "type": "integer",
                  "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "mplsL3VpnVrfRteInetCidrMetric5": {
                  "type": "integer",
                  "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                  "minimum": -2147483648,
                  "maximum": 2147483647
                },
                "mplsL3VpnVrfRteXCPointer": {
                  "type": "string",
                  "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                  "x-yang-type": "mpls-lsr:MplsIndexType"
                },
                "mplsL3VpnVrfRteInetCidrStatus": {
                  "type": "string",
                  "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                  "x-yang-type": "snmpv2-tc:RowStatus"
                }
              }
            }
          },
          "mplsL3VpnScalars": {
            "type": "object",
            "description": "The number of VRFs that are configured on this node.",
            "properties": {
              "mplsL3VpnConfiguredVrfs": {
                "type": "integer",
                "description": "The number of VRFs that are configured on this node.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsL3VpnActiveVrfs": {
                "type": "integer",
                "description": "The number of VRFs that are active on this node.\n          That is, those VRFs whose corresponding mplsL3VpnVrfOperStatus\n          object value is equal to operational (1).",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsL3VpnConnectedInterfaces": {
                "type": "integer",
                "description": "Total number of interfaces connected to a VRF.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsL3VpnNotificationEnable": {
                "type": "boolean",
                "description": "If this object is true, then it enables the\n          generation of all notifications defined in\n          this MIB.  This object's value should be\n          preserved across agent reboots."
              },
              "mplsL3VpnVrfConfMaxPossRts": {
                "type": "integer",
                "description": "Denotes maximum number of routes that the device\n          will allow all VRFs jointly to hold.  If this value is\n          set to 0, this indicates that the device is\n          unable to determine the absolute maximum.  In this\n          case, the configured maximum MAY not actually\n          be allowed by the device.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsL3VpnVrfConfRteMxThrshTime": {
                "type": "integer",
                "description": "Denotes the interval in seconds, at which the route max threshold\n          notification may be reissued after the maximum value has been\n          exceeded (or has been reached if mplsL3VpnVrfConfMaxRoutes and\n          mplsL3VpnVrfConfHighRteThresh are equal) and the initial\n          notification has been issued.  This value is intended to prevent\n          continuous generation of notifications by an agent in the event\n          that routes are continually added to a VRF after it has reached\n          its maximum value.  If this value is set to 0, the agent should\n          only issue a single notification at the time that the maximum\n          threshold has been reached, and should not issue any more\n          notifications until the value of routes has fallen below the\n          configured threshold value.  This is the recommended default\n          behavior.",
                "minimum": 0,
                "maximum": 4294967295
              },
              "mplsL3VpnIllLblRcvThrsh": {
                "type": "integer",
                "description": "The number of illegally received labels above which\n          the mplsNumVrfSecIllglLblThrshExcd notification\n          is issued.  The persistence of this value mimics\n          that of the device's configuration.",
                "minimum": 0,
                "maximum": 4294967295
              }
            }
          },
          "mplsL3VpnIfConfTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS capability\n        and associated information.",
            "properties": {
              "mplsL3VpnIfConfEntry": {
                "type": "array",
                "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
                "items": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnIfConfIndex": {
                      "type": "string",
                      "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
                      "x-yang-type": "if-mib:InterfaceIndex"
                    },
                    "mplsL3VpnIfVpnClassification": {
                      "type": "string",
                      "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
                    },
                    "mplsL3VpnIfVpnRouteDistProtocol": {
                      "type": "string",
                      "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
                    },
                    "mplsL3VpnIfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    },
                    "mplsL3VpnIfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                }
              }
            }
          },
          "mplsL3VpnVrfTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS L3VPN\n        VRF Table capability and associated information.\n        Entries in this table define VRF routing instances\n        associated with MPLS/VPN interfaces.  Note that\n        multiple interfaces can belong to the same VRF\n        instance.  The collection of all VRF instances\n        comprises an actual VPN.",
            "properties": {
              "mplsL3VpnVrfEntry": {
                "type": "array",
                "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
                "items": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
                    },
                    "mplsL3VpnVrfVpnId": {
                      "type": "string",
                      "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
                      "x-yang-type": "vpn-tc:VPNIdOrZero"
                    },
                    "mplsL3VpnVrfDescription": {
                      "type": "string",
                      "description": "The human-readable description of this VRF.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRD": {
                      "type": "string",
                      "description": "The route distinguisher for this VRF.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfCreationTime": {
                      "type": "string",
                      "description": "The time at which this VRF entry was created.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfOperStatus": {
                      "type": "string",
                      "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
                    },
                    "mplsL3VpnVrfActiveInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfAssociatedInterfaces": {
                      "type": "integer",
                      "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMidRteThresh": {
                      "type": "integer",
                      "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfHighRteThresh": {
                      "type": "integer",
                      "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfMaxRoutes": {
                      "type": "integer",
                      "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfConfLastChanged": {
                      "type": "string",
                      "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
                      "x-yang-type": "yang:timestamp"
                    },
                    "mplsL3VpnVrfConfRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfConfAdminStatus": {
                      "type": "string",
                      "description": "Indicates the desired operational status of this\n            VRF."
                    },
                    "mplsL3VpnVrfConfStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                }
              }
            }
          },
          "mplsL3VpnVrfRTTable": {
            "type": "object",
            "description": "This table specifies per-VRF route target association.\n        Each entry identifies a connectivity policy supported\n        as part of a VPN.",
            "properties": {
              "mplsL3VpnVrfRTEntry": {
                "type": "array",
                "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
                "items": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRTIndex": {
                      "type": "integer",
                      "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRTType": {
                      "type": "string",
                      "description": "The route target distribution type.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
                    },
                    "mplsL3VpnVrfRT": {
                      "type": "string",
                      "description": "The route target distribution policy.",
                      "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
                    },
                    "mplsL3VpnVrfRTDescr": {
                      "type": "string",
                      "description": "Description of the route target.",
                      "x-yang-type": "snmp-framework:SnmpAdminString"
                    },
                    "mplsL3VpnVrfRTRowStatus": {
                      "type": "string",
                      "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    },
                    "mplsL3VpnVrfRTStorageType": {
                      "type": "string",
                      "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
                      "x-yang-type": "snmpv2-tc:StorageType"
                    }
                  }
                }
              }
            }
          },
          "mplsL3VpnVrfRteTable": {
            "type": "object",
            "description": "This table specifies per-interface MPLS L3VPN VRF Table\n        routing information.  Entries in this table define VRF routing\n        entries associated with the specified MPLS/VPN interfaces.  Note\n        \n        that this table contains both BGP and Interior Gateway Protocol\n        IGP routes, as both may appear in the same VRF.",
            "properties": {
              "mplsL3VpnVrfRteEntry": {
                "type": "array",
                "description": "mplsL3VpnVrfRteEntry",
                "items": {
                  "type": "object",
                  "properties": {
                    "mplsL3VpnVrfName": {
                      "type": "string",
                      "description": "mplsL3VpnVrfName",
                      "x-yang-type": "leafref"
                    },
                    "mplsL3VpnVrfRteInetCidrDestType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrDest": {
                      "type": "string",
                      "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrPfxLen": {
                      "type": "string",
                      "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
                      "x-yang-type": "inet-address:InetAddressPrefixLength"
                    },
                    "mplsL3VpnVrfRteInetCidrPolicy": {
                      "type": "string",
                      "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
                      "x-yang-type": "yang:object-identifier-128"
                    },
                    "mplsL3VpnVrfRteInetCidrNHopType": {
                      "type": "string",
                      "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
                      "x-yang-type": "inet-address:InetAddressType"
                    },
                    "mplsL3VpnVrfRteInetCidrNextHop": {
                      "type": "string",
                      "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
                      "x-yang-type": "inet-address:InetAddress"
                    },
                    "mplsL3VpnVrfRteInetCidrIfIndex": {
                      "type": "string",
                      "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
                      "x-yang-type": "if-mib:InterfaceIndexOrZero"
                    },
                    "mplsL3VpnVrfRteInetCidrType": {
                      "type": "string",
                      "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
                    },
                    "mplsL3VpnVrfRteInetCidrProto": {
                      "type": "string",
                      "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
                      "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
                    },
                    "mplsL3VpnVrfRteInetCidrAge": {
                      "type": "integer",
                      "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
                      "minimum": 0,
                      "maximum": 4294967295
                    },
                    "mplsL3VpnVrfRteInetCidrNextHopAS": {
                      "type": "string",
                      "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
                      "format": "inet:as-number"
                    },
                    "mplsL3VpnVrfRteInetCidrMetric1": {
                      "type": "integer",
                      "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric2": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric3": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric4": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteInetCidrMetric5": {
                      "type": "integer",
                      "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
                      "minimum": -2147483648,
                      "maximum": 2147483647
                    },
                    "mplsL3VpnVrfRteXCPointer": {
                      "type": "string",
                      "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
                      "x-yang-type": "mpls-lsr:MplsIndexType"
                    },
                    "mplsL3VpnVrfRteInetCidrStatus": {
                      "type": "string",
                      "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
                      "x-yang-type": "snmpv2-tc:RowStatus"
                    }
                  }
                }
              }
            }
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_object-1": {
        "type": "object",
        "description": "object-1",
        "properties": {
          "mplsL3VpnVrfName": {
            "type": "string",
            "description": "mplsL3VpnVrfName",
            "x-yang-type": "leafref"
          },
          "mplsL3VpnVrfPerfCurrNumRoutes": {
            "type": "string",
            "description": "mplsL3VpnVrfPerfCurrNumRoutes",
            "x-yang-type": "leafref"
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_object-2": {
        "type": "object",
        "description": "object-2",
        "properties": {
          "mplsL3VpnVrfName": {
            "type": "string",
            "description": "mplsL3VpnVrfName",
            "x-yang-type": "leafref"
          },
          "mplsL3VpnVrfConfHighRteThresh": {
            "type": "string",
            "description": "mplsL3VpnVrfConfHighRteThresh",
            "x-yang-type": "leafref"
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_mplsL3VpnIfConfEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every interface capable of supporting MPLS L3VPN.\n          Each entry in this table is meant to correspond to\n          an entry in the Interfaces Table.",
        "items": {
          "type": "object",
          "properties": {
            "mplsL3VpnVrfName": {
              "type": "string",
              "description": "mplsL3VpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsL3VpnIfConfIndex": {
              "type": "string",
              "description": "This is a unique index for an entry in the\n            mplsL3VpnIfConfTable.  A non-zero index for an\n            entry indicates the ifIndex for the corresponding\n            interface entry in the MPLS-VPN-layer in the ifTable.\n            Note that this table does not necessarily correspond\n            one-to-one with all entries in the Interface MIB\n            having an ifType of MPLS-layer; rather, only those\n            that are enabled for MPLS L3VPN functionality.",
              "x-yang-type": "if-mib:InterfaceIndex"
            },
            "mplsL3VpnIfVpnClassification": {
              "type": "string",
              "description": "Denotes whether this link participates in a\n            carrier's carrier, enterprise, or inter-provider\n            scenario."
            },
            "mplsL3VpnIfVpnRouteDistProtocol": {
              "type": "string",
              "description": "Denotes the route distribution protocol across the\n            PE-CE link.  Note that more than one routing protocol\n            may be enabled at the same time; thus, this object is\n            specified as a bitmask.  For example, static(5) and\n            ospf(2) are a typical configuration."
            },
            "mplsL3VpnIfConfStorageType": {
              "type": "string",
              "description": "The storage type for this VPN If entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
              "x-yang-type": "snmpv2-tc:StorageType"
            },
            "mplsL3VpnIfConfRowStatus": {
              "type": "string",
              "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  Rows in this\n            table signify that the specified interface is\n            associated with this VRF.  If the row creation\n            operation succeeds, the interface will have been\n            associated with the specified VRF, otherwise the\n            agent MUST not allow the association.  If the agent\n            only allows read-only operations on this table, it\n            MUST create entries in this table as they are created\n            on the device.  When a row in this table is in\n            active(1) state, no objects in that row can be\n            modified except mplsL3VpnIfConfStorageType and\n            mplsL3VpnIfConfRowStatus.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_mplsL3VpnVrfEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          every VRF capable of supporting MPLS L3VPN.  The\n          indexing provides an ordering of VRFs per-VPN\n          interface.",
        "items": {
          "type": "object",
          "properties": {
            "mplsL3VpnVrfName": {
              "type": "string",
              "description": "The human-readable name of this VPN.  This MAY\n            be equivalent to the [RFC2685] VPN-ID, but may\n            also vary.  If it is set to the VPN ID, it MUST\n            be equivalent to the value of mplsL3VpnVrfVpnId.\n            It is strongly recommended that all sites supporting\n            VRFs that are part of the same VPN use the same\n            naming convention for VRFs as well as the same VPN\n            ID.",
              "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnName"
            },
            "mplsL3VpnVrfVpnId": {
              "type": "string",
              "description": "The VPN ID as specified in [RFC2685].  If a VPN ID\n            has not been specified for this VRF, then this\n            variable SHOULD be set to a zero-length OCTET\n            STRING.",
              "x-yang-type": "vpn-tc:VPNIdOrZero"
            },
            "mplsL3VpnVrfDescription": {
              "type": "string",
              "description": "The human-readable description of this VRF.",
              "x-yang-type": "snmp-framework:SnmpAdminString"
            },
            "mplsL3VpnVrfRD": {
              "type": "string",
              "description": "The route distinguisher for this VRF.",
              "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
            },
            "mplsL3VpnVrfCreationTime": {
              "type": "string",
              "description": "The time at which this VRF entry was created.",
              "x-yang-type": "yang:timestamp"
            },
            "mplsL3VpnVrfOperStatus": {
              "type": "string",
              "description": "Denotes whether or not a VRF is operational.  A VRF is\n            up(1) when there is at least one interface associated\n            with the VRF whose ifOperStatus is up(1).  A VRF is\n            down(2) when:\n            a. There does not exist at least one interface whose\n               ifOperStatus is up(1).\n            b. There are no interfaces associated with the VRF."
            },
            "mplsL3VpnVrfActiveInterfaces": {
              "type": "integer",
              "description": "Total number of interfaces connected to this VRF with\n            ifOperStatus = up(1).\n            \n            This value should increase when an interface is associated\n            with the corresponding VRF and its corresponding ifOperStatus\n            is equal to up(1).  If an interface is associated whose\n            ifOperStatus is not up(1), then the value is not incremented\n            until such time as it transitions to this state.\n            \n            This value should be decremented when an interface is\n            disassociated with a VRF or the corresponding ifOperStatus\n            transitions out of the up(1) state to any other state.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfAssociatedInterfaces": {
              "type": "integer",
              "description": "Total number of interfaces connected to this VRF\n            (independent of ifOperStatus type).",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfConfMidRteThresh": {
              "type": "integer",
              "description": "Denotes mid-level water marker for the number\n            of routes that this VRF may hold.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfConfHighRteThresh": {
              "type": "integer",
              "description": "Denotes high-level water marker for the number of\n            routes that this VRF may hold.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfConfMaxRoutes": {
              "type": "integer",
              "description": "Denotes maximum number of routes that this VRF is\n            configured to hold.  This value MUST be less than or\n            equal to mplsL3VpnVrfConfMaxPossRts unless it is set\n            to 0.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfConfLastChanged": {
              "type": "string",
              "description": "The value of sysUpTime at the time of the last\n            change of this table entry, which includes changes of\n            VRF parameters defined in this table or addition or\n            deletion of interfaces associated with this VRF.",
              "x-yang-type": "yang:timestamp"
            },
            "mplsL3VpnVrfConfRowStatus": {
              "type": "string",
              "description": "This variable is used to create, modify, and/or\n            delete a row in this table.\n            \n            When a row in this table is in active(1) state, no\n            objects in that row can be modified except\n            mplsL3VpnVrfConfAdminStatus, mplsL3VpnVrfConfRowStatus,\n            and mplsL3VpnVrfConfStorageType.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "mplsL3VpnVrfConfAdminStatus": {
              "type": "string",
              "description": "Indicates the desired operational status of this\n            VRF."
            },
            "mplsL3VpnVrfConfStorageType": {
              "type": "string",
              "description": "The storage type for this VPN VRF entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_mplsL3VpnVrfRTEntry": {
        "type": "array",
        "description": "An entry in this table is created by an LSR for\n          each route target configured for a VRF supporting\n          a MPLS L3VPN instance.  The indexing provides an\n          ordering per-VRF instance.  See [RFC4364] for a\n          complete definition of a route target.",
        "items": {
          "type": "object",
          "properties": {
            "mplsL3VpnVrfName": {
              "type": "string",
              "description": "mplsL3VpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsL3VpnVrfRTIndex": {
              "type": "integer",
              "description": "Auxiliary index for route targets configured for a\n            particular VRF.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfRTType": {
              "type": "string",
              "description": "The route target distribution type.",
              "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRtType"
            },
            "mplsL3VpnVrfRT": {
              "type": "string",
              "description": "The route target distribution policy.",
              "x-yang-type": "MPLS-L3VPN-STD-MIB:MplsL3VpnRouteDistinguisher"
            },
            "mplsL3VpnVrfRTDescr": {
              "type": "string",
              "description": "Description of the route target.",
              "x-yang-type": "snmp-framework:SnmpAdminString"
            },
            "mplsL3VpnVrfRTRowStatus": {
              "type": "string",
              "description": "This variable is used to create, modify, and/or\n            delete a row in this table.  When a row in this\n            table is in active(1) state, no objects in that row\n            can be modified except mplsL3VpnVrfRTRowStatus.",
              "x-yang-type": "snmpv2-tc:RowStatus"
            },
            "mplsL3VpnVrfRTStorageType": {
              "type": "string",
              "description": "The storage type for this VPN route target (RT) entry.\n            Conceptual rows having the value 'permanent'\n            need not allow write access to any columnar\n            objects in the row.",
              "x-yang-type": "snmpv2-tc:StorageType"
            }
          }
        }
      },
      "MPLS-L3VPN-STD-MIB_mplsL3VpnVrfRteEntry": {
        "type": "array",
        "description": "mplsL3VpnVrfRteEntry",
        "items": {
          "type": "object",
          "properties": {
            "mplsL3VpnVrfName": {
              "type": "string",
              "description": "mplsL3VpnVrfName",
              "x-yang-type": "leafref"
            },
            "mplsL3VpnVrfRteInetCidrDestType": {
              "type": "string",
              "description": "The type of the mplsL3VpnVrfRteInetCidrDest address, as\n            defined in the InetAddress MIB.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsL3VpnVrfRteInetCidrDest": {
              "type": "string",
              "description": "The destination IP address of this route.\n            \n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrDestType object.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then\n            the bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsL3VpnVrfRteInetCidrPfxLen": {
              "type": "string",
              "description": "Indicates the number of leading one bits that form the\n            \n            mask to be logical-ANDed with the destination address\n            before being compared to the value in the\n            mplsL3VpnVrfRteInetCidrDest field.\n            \n            The values for the index objects\n            mplsL3VpnVrfRteInetCidrDest and\n            mplsL3VpnVrfRteInetCidrPfxLen must be consistent.  When\n            the value of mplsL3VpnVrfRteInetCidrDest is x, then the\n            bitwise logical-AND of x with the value of the mask\n            formed from the corresponding index object\n            mplsL3VpnVrfRteInetCidrPfxLen MUST be\n            equal to x.  If not, then the index pair is not\n            consistent and an inconsistentName error must be\n            returned on SET or CREATE requests.",
              "x-yang-type": "inet-address:InetAddressPrefixLength"
            },
            "mplsL3VpnVrfRteInetCidrPolicy": {
              "type": "string",
              "description": "This object is an opaque object without any defined\n            semantics.  Its purpose is to serve as an additional\n            index that may delineate between multiple entries to\n            the same destination.  The value { 0 0 } shall be used\n            as the default value for this object.",
              "x-yang-type": "yang:object-identifier-128"
            },
            "mplsL3VpnVrfRteInetCidrNHopType": {
              "type": "string",
              "description": "The type of the mplsL3VpnVrfRteInetCidrNextHop address,\n            as defined in the InetAddress MIB.\n            \n            Value should be set to unknown(0) for non-remote\n            routes.\n            \n            Only those address types that may appear in an actual\n            routing table are allowed as values of this object.",
              "x-yang-type": "inet-address:InetAddressType"
            },
            "mplsL3VpnVrfRteInetCidrNextHop": {
              "type": "string",
              "description": "On remote routes, the address of the next system en\n            route.  For non-remote routes, a zero-length string.\n            The type of this address is determined by the value of\n            the mplsL3VpnVrfRteInetCidrNHopType object.",
              "x-yang-type": "inet-address:InetAddress"
            },
            "mplsL3VpnVrfRteInetCidrIfIndex": {
              "type": "string",
              "description": "The ifIndex value that identifies the local interface\n            through which the next hop of this route should be\n            reached.  A value of 0 is valid and represents the\n            scenario where no interface is specified.",
              "x-yang-type": "if-mib:InterfaceIndexOrZero"
            },
            "mplsL3VpnVrfRteInetCidrType": {
              "type": "string",
              "description": "The type of route.  Note that local(3) refers to a\n            route for which the next hop is the final destination;\n            remote(4) refers to a route for which the next hop is\n            not the final destination.\n            \n            Routes that do not result in traffic forwarding or\n            rejection should not be displayed even if the\n            implementation keeps them stored internally.\n            \n            reject(2) refers to a route that, if matched, discards\n            the message as unreachable and returns a notification\n            (e.g., ICMP error) to the message sender.  This is used\n            in some protocols as a means of correctly aggregating\n            routes.\n            \n            blackhole(5) refers to a route that, if matched,\n            discards the message silently."
            },
            "mplsL3VpnVrfRteInetCidrProto": {
              "type": "string",
              "description": "The routing mechanism via which this route was learned.\n            Inclusion of values for gateway routing protocols is\n            not intended to imply that hosts should support those\n            protocols.",
              "x-yang-type": "iana-rtproto:IANAipRouteProtocol"
            },
            "mplsL3VpnVrfRteInetCidrAge": {
              "type": "integer",
              "description": "The number of seconds since this route was last updated\n            or otherwise determined to be correct.  Note that no\n            semantics of 'too old' can be implied except through\n            knowledge of the routing protocol by which the route\n            was learned.",
              "minimum": 0,
              "maximum": 4294967295
            },
            "mplsL3VpnVrfRteInetCidrNextHopAS": {
              "type": "string",
              "description": "The Autonomous System Number of the next hop.  The\n            semantics of this object are determined by the\n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  When this\n            object is unknown or not relevant, its value should\n            be set to zero.",
              "format": "inet:as-number"
            },
            "mplsL3VpnVrfRteInetCidrMetric1": {
              "type": "integer",
              "description": "The primary routing metric for this route.  The\n            semantics of this metric are determined by the\n            \n            routing protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this\n            metric is not used, its value should be set to\n            -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsL3VpnVrfRteInetCidrMetric2": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsL3VpnVrfRteInetCidrMetric3": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto\n            value.  If this metric is not used, its value should be\n            set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsL3VpnVrfRteInetCidrMetric4": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric\n            is not used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsL3VpnVrfRteInetCidrMetric5": {
              "type": "integer",
              "description": "An alternate routing metric for this route.  The\n            semantics of this metric are determined by the routing\n            protocol specified in the route's\n            mplsL3VpnVrfRteInetCidrProto value.  If this metric is\n            not used, its value should be set to -1.",
              "minimum": -2147483648,
              "maximum": 2147483647
            },
            "mplsL3VpnVrfRteXCPointer": {
              "type": "string",
              "description": "Index into mplsXCTable that identifies which cross-\n            connect entry is associated with this VRF route entry\n            by containing the mplsXCIndex of that cross-connect entry.\n            The string containing the single-octet 0x00 indicates that\n            a label stack is not associated with this route entry.  This\n            can be the case because the label bindings have not yet\n            been established, or because some change in the agent has\n            removed them.\n            \n            When the label stack associated with this VRF route is created,\n            it MUST establish the associated cross-connect\n            entry in the mplsXCTable and then set that index to the value\n            of this object.  Changes to the cross-connect object in the\n            mplsXCTable MUST automatically be reflected in the value of\n            this object.  If this object represents a static routing entry,\n            then the manager must ensure that this entry is maintained\n            consistently in the corresponding mplsXCTable as well.",
              "x-yang-type": "mpls-lsr:MplsIndexType"
            },
            "mplsL3VpnVrfRteInetCidrStatus": {
              "type": "string",
              "description": "The row status variable, used according to row\n            installation and removal conventions.\n            \n            A row entry cannot be modified when the status is\n            marked as active(1).",
              "x-yang-type": "snmpv2-tc:RowStatus"
            }
          }
        }
      }
    },
    "securitySchemes": {
      "basicAuth": {
        "type": "http",
        "scheme": "basic"
      }
    }
  },
  "security": [
    {
      "basicAuth": []
    }
  ],
  "tags": [
    {
      "name": "MPLS-L3VPN-STD-MIB",
      "description": "MIB operations for MPLS-L3VPN-STD-MIB"
    }
  ]
}